//@version=6
indicator('ICT SMC Indicator Bundle', 'ICTSMC', overlay=true, max_labels_count=500, max_lines_count=500, max_boxes_count=500, max_bars_back=5000)

// Combined script generated from repository indicators:
// - ICT HTF Candles (fadi)
// - FXN Asian Session Range
// - ICT Concepts [LuxAlgo]
// - Smart Money Concepts [LuxAlgo]
// - VWAP MTF
// The original scripts have been concatenated and adjusted to run under a single Pine Script v5 indicator.

// =================================================================================================
// ICT HTF Candles (fadi)
// =================================================================================================

type Candle
	float o
	float c
	float h
	float l
    int o_time
	int o_idx
	int c_idx
	int h_idx
	int l_idx
    string dow
	box body
	line wick_up
	line wick_down
    label dow_label

type Trace
	line o
	line c
	line h
	line l
	label o_l
	label c_l
	label h_l
	label l_l

type Imbalance
	box b
	int idx

type CandleSettings
	bool show
	string htf
	int max_display

type Settings
	int max_sets
	color bull_body
	color bull_border
	color bull_wick
	color bear_body
	color bear_border
	color bear_wick
	int offset
	int buffer
	int htf_buffer
	int width
	bool use_custom_daily
    string custom_daily
    bool daily_name
	bool trace_show
	color trace_o_color
	string trace_o_style
	int trace_o_size
	color trace_c_color
	string trace_c_style
	int trace_c_size
	color trace_h_color
	string trace_h_style
	int trace_h_size
	color trace_l_color
	string trace_l_style
	int trace_l_size
	string trace_anchor
	bool label_show
	color label_color
	string label_size
    string label_position
    string label_alignment
	bool fvg_show
	color fvg_color
	bool vi_show
	color vi_color
	bool htf_label_show
	color htf_label_color
	string htf_label_size
	bool htf_timer_show
	color htf_timer_color
	string htf_timer_size
    color dow_color
    string dow_size

type CandleSet
	array<Candle> candles
	array<Imbalance> imbalances
	CandleSettings settings
	label tfNameTop
    label tfNameBottom
	label tfTimerTop
    label tfTimerBottom

type Helper
	string name = 'Helper'

Settings settings = Settings.new()

var CandleSettings SettingsHTF1 = CandleSettings.new()
var CandleSettings SettingsHTF2 = CandleSettings.new()
var CandleSettings SettingsHTF3 = CandleSettings.new()
var CandleSettings SettingsHTF4 = CandleSettings.new()
var CandleSettings SettingsHTF5 = CandleSettings.new()
var CandleSettings SettingsHTF6 = CandleSettings.new()

var array<Candle> candles_1 = array.new<Candle>(0)
var array<Candle> candles_2 = array.new<Candle>(0)
var array<Candle> candles_3 = array.new<Candle>(0)
var array<Candle> candles_4 = array.new<Candle>(0)
var array<Candle> candles_5 = array.new<Candle>(0)
var array<Candle> candles_6 = array.new<Candle>(0)

var array<Imbalance> imbalances_1 = array.new<Imbalance>()
var array<Imbalance> imbalances_2 = array.new<Imbalance>()
var array<Imbalance> imbalances_3 = array.new<Imbalance>()
var array<Imbalance> imbalances_4 = array.new<Imbalance>()
var array<Imbalance> imbalances_5 = array.new<Imbalance>()
var array<Imbalance> imbalances_6 = array.new<Imbalance>()

var CandleSet htf1 = CandleSet.new()
htf1.settings := SettingsHTF1
htf1.candles := candles_1
htf1.imbalances := imbalances_1

var CandleSet htf2 = CandleSet.new()
htf2.settings := SettingsHTF2
htf2.candles := candles_2
htf2.imbalances := imbalances_2

var CandleSet htf3 = CandleSet.new()
htf3.settings := SettingsHTF3
htf3.candles := candles_3
htf3.imbalances := imbalances_3

var CandleSet htf4 = CandleSet.new()
htf4.settings := SettingsHTF4
htf4.candles := candles_4
htf4.imbalances := imbalances_4

var CandleSet htf5 = CandleSet.new()
htf5.settings := SettingsHTF5
htf5.candles := candles_5
htf5.imbalances := imbalances_5

var CandleSet htf6 = CandleSet.new()
htf6.settings := SettingsHTF6
htf6.candles := candles_6
htf6.imbalances := imbalances_6

//+------------------------------------------------------------------------------------------------------------+//
//+--- Settings                                                                                             ---+//
//+------------------------------------------------------------------------------------------------------------+//

string group_style              = "Styling  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string group_label              = "Label Settings  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string group_imbalance          = "Imbalance  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string group_trace              = "Trace  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

htf1.settings.show              := input.bool(true, 'HTF 1      ', inline = 'htf1')
htf_1                           = input.timeframe('5', '', inline = 'htf1')
htf1.settings.htf := htf_1
htf1.settings.max_display       := input.int(10, '', inline = 'htf1')

htf2.settings.show              := input.bool(true, 'HTF 2      ', inline = 'htf2')
htf_2                           = input.timeframe('15', '', inline = 'htf2')
htf2.settings.htf := htf_2
htf2.settings.max_display       := input.int(10, '', inline = 'htf2')

htf3.settings.show              := input.bool(true, 'HTF 3      ', inline = 'htf3')
htf_3                           = input.timeframe('60', '', inline = 'htf3')
htf3.settings.htf := htf_3
htf3.settings.max_display       := input.int(10, '', inline = 'htf3')

htf4.settings.show              := input.bool(true, 'HTF 4      ', inline = 'htf4')
htf_4                           = input.timeframe('240', '', inline = 'htf4')
htf4.settings.htf               := htf_4
htf4.settings.max_display       := input.int(10, '', inline = 'htf4')

htf5.settings.show              := input.bool(true, 'HTF 5      ', inline = 'htf5')
htf_5                           = input.timeframe('1D', '', inline = 'htf5')
htf5.settings.htf := htf_5
htf5.settings.max_display       := input.int(10, '', inline = 'htf5')

htf6.settings.show              := input.bool(true, 'HTF 6      ', inline = 'htf6')
htf_6                           = input.timeframe('1W', '', inline = 'htf6')
htf6.settings.htf               := htf_6
htf6.settings.max_display       := input.int(10, '', inline = 'htf6')

settings.max_sets               := input.int(6, 'Limit to next HTFs only', minval = 1, maxval = 6)
settings.use_custom_daily       := input.bool(false, 'Custom daily candle open     ', inline='customdaily')
settings.custom_daily           := input.string('Midnight', '', options=['Midnight', '8:30', '9:30'], inline='customdaily')
settings.bull_body              := input.color(color.new(color.green, 10), 'Body  ', inline = 'body', group=group_style)
settings.bear_body              := input.color(color.new(color.red, 10), '', inline = 'body', group=group_style)
settings.bull_border            := input.color(color.new(color.black, 10), 'Borders', inline = 'borders', group=group_style)
settings.bear_border            := input.color(color.new(color.black, 10), '', inline = 'borders', group=group_style)
settings.bull_wick              := input.color(color.new(color.black, 10), 'Wick  ', inline = 'wick', group=group_style)
settings.bear_wick              := input.color(color.new(color.black, 10), '', inline = 'wick', group=group_style)

settings.offset                 := input.int(10, 'padding from current candles', minval = 1, group=group_style)
settings.buffer                 := input.int(1, 'space between candles', minval = 1, maxval = 4, group=group_style)
settings.htf_buffer             := input.int(10, 'space between Higher Timeframes', minval = 1, maxval = 10, group=group_style)
settings.width                  := input.int(1, 'Candle Width', minval = 1, maxval = 4, group=group_style) * 2

settings.htf_label_show         := input.bool(true, 'HTF Label           ', group=group_label, inline = 'HTFlabel')
settings.htf_label_color        := input.color(color.new(color.black, 10), '', group=group_label, inline = 'HTFlabel')
settings.htf_label_size         := input.string(size.large, '', [size.tiny, size.small, size.normal, size.large, size.huge], group=group_label, inline = 'HTFlabel')

settings.label_position         := input.string("Both", 'Label Positions', options=['Both', 'Top', 'Bottom'], group=group_label)
settings.label_alignment        := input.string("Align", "Label Alignment", options=['Align', 'Follow Candles'], group=group_label)

settings.htf_timer_show         := input.bool(true, 'Remaining time      ', inline = 'timer', group=group_label)
settings.htf_timer_color        := input.color(color.new(color.black, 10), '', inline = 'timer', group=group_label)
settings.htf_timer_size         := input.string(size.normal, '', [size.tiny, size.small, size.normal, size.large, size.huge], group=group_label, inline = 'timer')

settings.daily_name             := input.bool(false, 'Interval Value        ', group=group_label, inline = 'dow')
settings.dow_color              := input.color(color.black , '', group=group_label, inline = 'dow')
settings.dow_size               := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], group=group_label, inline = 'dow')

settings.fvg_show               := input.bool(true, 'Fair Value Gap   ', group = group_imbalance, inline = 'fvg')
settings.fvg_color              := input.color(color.new(color.gray, 80), '', inline = 'fvg', group = group_imbalance)

settings.vi_show                := input.bool(true, 'Volume Imbalance', group = group_imbalance, inline = 'vi')
settings.vi_color               := input.color(color.new(color.red, 50), '', inline = 'vi', group = group_imbalance)

settings.trace_show             := input.bool(false, 'Trace lines', group = group_trace)
settings.trace_o_color          := input.color(color.new(color.gray, 50), 'Open    ', inline = '1', group = group_trace)
settings.trace_o_style          := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '1', group = group_trace)
settings.trace_o_size           := input.int(1, '', options = [1, 2, 3, 4], inline = '1', group = group_trace)
settings.trace_c_color          := input.color(color.new(color.gray, 50), 'Close    ', inline = '2', group = group_trace)
settings.trace_c_style          := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '2', group = group_trace)
settings.trace_c_size           := input.int(1, '', options = [1, 2, 3, 4], inline = '2', group = group_trace)
settings.trace_h_color          := input.color(color.new(color.gray, 50), 'High     ', inline = '3', group = group_trace)
settings.trace_h_style          := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '3', group = group_trace)
settings.trace_h_size           := input.int(1, '', options = [1, 2, 3, 4], inline = '3', group = group_trace)
settings.trace_l_color          := input.color(color.new(color.gray, 50), 'Low     ', inline = '4', group = group_trace)
settings.trace_l_style          := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '4', group = group_trace)
settings.trace_l_size           := input.int(1, '', options = [1, 2, 3, 4], inline = '4', group = group_trace)
settings.trace_anchor           := input.string('First Timeframe', 'Anchor to', options = ['First Timeframe', 'Last Timeframe'], group = group_trace)

settings.label_show             := input.bool(false, 'Price Label           ', inline = 'label')
settings.label_color            := input.color(color.new(color.black, 10), '', inline = 'label')
settings.label_size             := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline = 'label')

//+------------------------------------------------------------------------------------------------------------+//
//+--- Variables                                                                                            ---+//
//+------------------------------------------------------------------------------------------------------------+//

Helper helper = Helper.new()
var Trace trace = Trace.new()
color color_transparent = #ffffff00

//+------------------------------------------------------------------------------------------------------------+//
//+--- Internal Functions                                                                                   ---+//
//+------------------------------------------------------------------------------------------------------------+//

method LineStyle(Helper helper, string style) =>
    helper.name := style
    out = switch style
        '----' => line.style_dashed
        '····' => line.style_dotted
        => line.style_solid
    out

method DayofWeek(Helper helper, int index) =>
    helper.name := 'DOW'
    switch
        index == 1 => 'M'
        index == 2 => 'T'
        index == 3 => 'W'
        index == 4 => 'T'
        index == 5 => 'F'
        index == 6 => 'S'
        index == 7 => 'S'
        na(index) => ''

method ValidTimeframe(Helper helper, string HTF) =>
    helper.name := HTF
    if timeframe.in_seconds(HTF) >= timeframe.in_seconds('D') and timeframe.in_seconds(HTF) > timeframe.in_seconds()
        true
    else
        n1 = timeframe.in_seconds()
        n2 = timeframe.in_seconds(HTF)
        n3 = n1 % n2
        n1 < n2 and math.round(n2 / n1) == n2 / n1


method RemainingTime(Helper helper, string HTF) =>
    helper.name := HTF
    if barstate.isrealtime
        timeRemaining = (time_close(HTF) - timenow) / 1000
        days = math.floor(timeRemaining / 86400)
        hours = math.floor((timeRemaining - days * 86400) / 3600)
        minutes = math.floor((timeRemaining - days * 86400 - hours * 3600) / 60)
        seconds = math.floor(timeRemaining - days * 86400 - hours * 3600 - minutes * 60)

        r = str.tostring(seconds, '00')
        if minutes > 0 or hours > 0 or days > 0
            r := str.tostring(minutes, '00') + ':' + r
            r
        if hours > 0 or days > 0
            r := str.tostring(hours, '00') + ':' + r
            r
        if days > 0
            r := str.tostring(days) + 'D ' + r
            r
        r
    else
        'n/a'

method HTFName(Helper helper, string HTF) =>
    helper.name := 'HTFName'
    formatted = HTF

    seconds = timeframe.in_seconds(HTF)
    if seconds < 60
        formatted := str.tostring(seconds) + 's'
        formatted
    else if seconds / 60 < 60
        formatted := str.tostring(seconds / 60) + 'm'
        formatted
    else if seconds / 60 / 60 < 24
        formatted := str.tostring(seconds / 60 / 60) + 'H'
        formatted
    formatted

method HTFEnabled(Helper helper) =>
    helper.name := 'HTFEnabled'
    int enabled = 0
    enabled := enabled + (htf1.settings.show ? 1 : 0)
    enabled := enabled + (htf2.settings.show ? 1 : 0)
    enabled := enabled + (htf3.settings.show ? 1 : 0)
    enabled := enabled + (htf4.settings.show ? 1 : 0)
    enabled := enabled + (htf5.settings.show ? 1 : 0)
    enabled := enabled + (htf6.settings.show ? 1 : 0)
    int last = math.min(enabled, settings.max_sets)

    last

method CandleSetHigh(Helper helper, array<Candle> candles, float h) =>
    helper.name := 'CandlesSetHigh'
    float _h = h
    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.h > _h
                _h := c.h
                _h
    _h

method CandleSetLow(Helper helper, array<Candle> candles, float l) =>
    helper.name := 'CandlesSetLow'
    float _l = l
    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.l < _l
                _l := c.l
                _l
    _l

method CandlesHigh(Helper helper, array<Candle> candles) =>
    helper.name := 'CandlesHigh'
    h = 0.0
    int cnt = 0
    int last = helper.HTFEnabled()

    if htf1.settings.show and helper.ValidTimeframe(htf1.settings.htf)
        h := helper.CandleSetHigh(htf1.candles, h)
        cnt := cnt + 1
    if htf2.settings.show and helper.ValidTimeframe(htf2.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf2.candles, h)
        cnt := cnt + 1
    if htf3.settings.show and helper.ValidTimeframe(htf3.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf3.candles, h)
        cnt := cnt + 1
    if htf4.settings.show and helper.ValidTimeframe(htf4.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf4.candles, h)
        cnt := cnt + 1
    if htf5.settings.show and helper.ValidTimeframe(htf5.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf5.candles, h)
        cnt := cnt + 1
    if htf6.settings.show and helper.ValidTimeframe(htf6.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf6.candles, h)

    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.h > h
                h := c.h
    h

method CandlesLow(Helper helper, array<Candle> candles, float h) =>
    helper.name := 'CandlesLow'
    l = h
    int cnt = 0
    int last = helper.HTFEnabled()

    if htf1.settings.show and helper.ValidTimeframe(htf1.settings.htf)
        l := helper.CandleSetLow(htf1.candles, l)
        cnt := cnt + 1
    if htf2.settings.show and helper.ValidTimeframe(htf2.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf2.candles, l)
        cnt := cnt + 1
    if htf3.settings.show and helper.ValidTimeframe(htf3.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf3.candles, l)
        cnt := cnt + 1
    if htf4.settings.show and helper.ValidTimeframe(htf4.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf4.candles, l)
        cnt := cnt + 1
    if htf5.settings.show and helper.ValidTimeframe(htf5.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf5.candles, l)
        cnt := cnt + 1
    if htf6.settings.show and helper.ValidTimeframe(htf6.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf6.candles, l)

    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.l < l
                l := c.l
    l

method UpdateTime(CandleSet candleSet, int offset) =>
    if settings.htf_timer_show and (barstate.isrealtime or barstate.islast)
        string tmr = '(' + helper.RemainingTime(candleSet.settings.htf) + ')'

        if not na(candleSet.tfTimerTop)
            candleSet.tfTimerTop.set_text(tmr)

        if not na(candleSet.tfTimerBottom)
            candleSet.tfTimerBottom.set_text(tmr)
    candleSet

method Reorder(CandleSet candleSet, int offset) =>
    size = candleSet.candles.size()

    if size > 0
        for i = size - 1 to 0 by 1
            Candle candle = candleSet.candles.get(i)
            t_buffer = offset + (settings.width + settings.buffer) * (size - i - 1)
            box.set_left(candle.body, bar_index + t_buffer)
            box.set_right(candle.body, bar_index + settings.width + t_buffer)
            line.set_x1(candle.wick_up, bar_index + settings.width / 2 + t_buffer)
            line.set_x2(candle.wick_up, bar_index + settings.width / 2 + t_buffer)
            line.set_x1(candle.wick_down, bar_index + settings.width / 2 + t_buffer)
            line.set_x2(candle.wick_down, bar_index + settings.width / 2 + t_buffer)

            if settings.daily_name //and candleSet.settings.htf == '1D'
                if not na(candle.dow_label)
                    candle.dow_label.set_y(candle.h)
                    candle.dow_label.set_x(bar_index + settings.width / 2 + t_buffer)
                    candle.dow_label.set_text(candle.dow)
                else
                    candle.dow_label := label.new(bar_index + settings.width / 2 + t_buffer, candle.h, candle.dow, color = color_transparent, textcolor = settings.dow_color, style = label.style_label_down, size = settings.dow_size)

    top = 0.0
    bottom = 0.0

    if settings.label_alignment == 'Align'
        top := helper.CandlesHigh(candleSet.candles)
        bottom := helper.CandlesLow(candleSet.candles, top)
    if settings.label_alignment == 'Follow Candles'
        top := helper.CandleSetHigh(candleSet.candles, 0)
        bottom := helper.CandleSetLow(candleSet.candles, top)

    left = bar_index + offset + (settings.width + settings.buffer) * (size - 1) / 2

    if settings.htf_label_show
        string lblt = helper.HTFName(candleSet.settings.htf)
        string lbll = lblt
        if settings.htf_timer_show
            lblt := lblt + '\n'
            lbll := '\n' + lbll
        if settings.daily_name
            lblt := lblt + '\n'

        string tmr = '(' + helper.RemainingTime(candleSet.settings.htf) + ')' + (settings.daily_name ? '\n' : '')
        if settings.label_position == 'Both' or settings.label_position == 'Top'
            
            if not na(candleSet.tfNameTop)
                candleSet.tfNameTop.set_xy(left, top)
            else
                candleSet.tfNameTop := label.new(left, top, lblt, color = color_transparent, textcolor = settings.htf_label_color, style = label.style_label_down, size = settings.htf_label_size)
            if settings.htf_timer_show
                if not na(candleSet.tfTimerTop)
                    candleSet.tfTimerTop.set_xy(left, top)
                else
                    candleSet.tfTimerTop := label.new(left, top, tmr, color = color_transparent, textcolor = settings.htf_timer_color, style = label.style_label_down, size = settings.htf_timer_size)

        if settings.label_position == 'Both' or settings.label_position == 'Bottom'
            if not na(candleSet.tfNameBottom)
                candleSet.tfNameBottom.set_xy(left, bottom)
            else
                candleSet.tfNameBottom := label.new(left, bottom, lbll, color = color_transparent, textcolor = settings.htf_label_color, style = label.style_label_up, size = settings.htf_label_size)
            if settings.htf_timer_show
                if settings.htf_timer_show
                    if not na(candleSet.tfTimerBottom)
                        candleSet.tfTimerBottom.set_xy(left, bottom)
                    else
                        candleSet.tfTimerBottom := label.new(left, bottom, tmr, color = color_transparent, textcolor = settings.htf_timer_color, style = label.style_label_up, size = settings.htf_timer_size)

    candleSet

method FindImbalance(CandleSet candleSet) =>
    if barstate.isrealtime or barstate.islast
        if candleSet.imbalances.size() > 0
            for i = candleSet.imbalances.size() - 1 to 0 by 1
                Imbalance del = candleSet.imbalances.get(i)
                box.delete(del.b)
                candleSet.imbalances.pop()

        if candleSet.candles.size() > 3 and settings.fvg_show
            for i = 0 to candleSet.candles.size() - 3 by 1
                candle1 = candleSet.candles.get(i)
                candle2 = candleSet.candles.get(i + 2)
                candle3 = candleSet.candles.get(i + 1)

                if candle1.l > candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
                    Imbalance imb = Imbalance.new()
                    imb.b := box.new(box.get_left(candle2.body), candle2.h, box.get_right(candle1.body), candle1.l, bgcolor = settings.fvg_color, border_color = color_transparent, xloc = xloc.bar_index)
                    candleSet.imbalances.push(imb)
                if candle1.h < candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
                    Imbalance imb = Imbalance.new()
                    imb.b := box.new(box.get_right(candle1.body), candle1.h, box.get_left(candle2.body), candle2.l, bgcolor = settings.fvg_color, border_color = color_transparent)
                    candleSet.imbalances.push(imb)
                box temp = box.copy(candle3.body)
                box.delete(candle3.body)
                candle3.body := temp
                candle3.body

        if candleSet.candles.size() > 2 and settings.vi_show
            for i = 0 to candleSet.candles.size() - 2 by 1
                candle1 = candleSet.candles.get(i)
                candle2 = candleSet.candles.get(i + 1)
                if candle1.l < candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
                    Imbalance imb = Imbalance.new()
                    imb.b := box.new(box.get_left(candle2.body), math.min(candle1.o, candle1.c), box.get_right(candle1.body), math.max(candle2.o, candle2.c), bgcolor = settings.vi_color, border_color = color_transparent)
                    candleSet.imbalances.push(imb)
                if candle1.h > candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
                    Imbalance imb = Imbalance.new()
                    imb.b := box.new(box.get_right(candle1.body), math.min(candle2.o, candle2.c), box.get_left(candle2.body), math.max(candle1.o, candle1.c), bgcolor = settings.vi_color, border_color = color_transparent)
                    candleSet.imbalances.push(imb)
    candleSet

method Monitor(CandleSet candleSet) =>
    HTFBarTime = time(candleSet.settings.htf, 'america/New_York')
    isNewHTFCandle = ta.change(HTFBarTime) > 0

    if settings.use_custom_daily
        int _830 = 0
        if isNewHTFCandle
            _830 := timestamp("America/New_York", year(time), month(time), dayofmonth(time), 0, 0) + 30600000
        if candleSet.settings.htf == '1D'
            if settings.custom_daily == 'Midnight'
                isNewHTFCandle := dayofweek(time, 'America/New_York') != dayofweek(time - (time - time[1]), 'America/New_York')
            if settings.custom_daily == '8:30'    
                // Get 8:30 AM New York time for today 
                isNewHTFCandle := not na(time(timeframe.period, "0830-0831:123456", 'America/New_York')) and na(time(timeframe.period, "0830-0831:123456", 'America/New_York')[1])
            if settings.custom_daily == '9:30'    
                // Get 9:30 AM New York time for today 
                isNewHTFCandle := not na(time(timeframe.period, "0930-0931:123456", 'America/New_York')) and na(time(timeframe.period, "0930-0931:123456", 'America/New_York')[1])
    if isNewHTFCandle
        Candle candle = Candle.new()
        candle.o := open
        candle.c := close
        candle.h := high
        candle.l := low
        candle.o_time := time
        candle.o_idx := bar_index
        candle.c_idx := bar_index
        candle.h_idx := bar_index
        candle.l_idx := bar_index
        candle.dow := switch
            candleSet.settings.htf == '1D' =>
                helper.DayofWeek(dayofweek(time_tradingday, "America/New_York"))
            str.tonumber(candleSet.settings.htf) < 60 =>
                str.format_time(candle.o_time, 'm', 'America/New_York')
            str.tonumber(candleSet.settings.htf) >= 60 =>
                str.format_time(candle.o_time, 'H', 'America/New_York')
            candleSet.settings.htf == '1M' =>
                str.format_time(candle.o_time, 'M', 'America/New_York')
            =>
                ''
        log.info('dow: {1} |{0}|', candle.dow, candleSet.settings.htf)
        bull = candle.c > candle.o

        candle.body := box.new(bar_index, math.max(candle.o, candle.c), bar_index + 2, math.min(candle.o, candle.c), bull ? settings.bull_border : settings.bear_border, 1, bgcolor = bull ? settings.bull_body : settings.bear_body)
        candle.wick_up := line.new(bar_index + 1, candle.h, bar_index, math.max(candle.o, candle.c), color = bull ? settings.bull_wick : settings.bear_wick)
        candle.wick_down := line.new(bar_index + 1, math.min(candle.o, candle.c), bar_index, candle.l, color = bull ? settings.bull_wick : settings.bear_wick)

        candleSet.candles.unshift(candle)

        if candleSet.candles.size() > candleSet.settings.max_display
            Candle delCandle = array.pop(candleSet.candles)
            box.delete(delCandle.body)
            line.delete(delCandle.wick_up)
            line.delete(delCandle.wick_down)
            delCandle.dow_label.delete()

    candleSet

method Update(CandleSet candleSet, int offset, bool showTrace) =>
    if candleSet.candles.size() > 0
        Candle candle = candleSet.candles.first()
        candle.h_idx := high > candle.h ? bar_index : candle.h_idx
        candle.h := high > candle.h ? high : candle.h
        candle.l_idx := low < candle.l ? bar_index : candle.l_idx
        candle.l := low < candle.l ? low : candle.l
        candle.c := close
        candle.c_idx := bar_index

        bull = candle.c > candle.o

        box.set_top(candle.body, candle.o)
        box.set_bottom(candle.body, candle.c)
        box.set_bgcolor(candle.body, bull ? settings.bull_body : settings.bear_body)
        box.set_border_color(candle.body, bull ? settings.bull_border : settings.bear_border)
        line.set_color(candle.wick_up, bull ? settings.bull_wick : settings.bear_wick)
        line.set_color(candle.wick_down, bull ? settings.bull_wick : settings.bear_wick)
        line.set_y1(candle.wick_up, candle.h)
        line.set_y2(candle.wick_up, math.max(candle.o, candle.c))
        line.set_y1(candle.wick_down, candle.l)
        line.set_y2(candle.wick_down, math.min(candle.o, candle.c))

        if barstate.isrealtime or barstate.islast
            candleSet.Reorder(offset)
            if settings.trace_show and showTrace
                if bar_index - candle.o_idx < 5000
                    if na(trace.o)
                        trace.o := line.new(candle.o_idx, candle.o, box.get_left(candle.body), candle.o, xloc = xloc.bar_index, color = settings.trace_o_color, style = helper.LineStyle(settings.trace_o_style), width = settings.trace_o_size)
                        trace.o
                    else
                        line.set_xy1(trace.o, candle.o_idx, candle.o)
                        line.set_xy2(trace.o, box.get_left(candle.body), candle.o)

                    if settings.label_show
                        if na(trace.o_l)
                            trace.o_l := label.new(box.get_right(candle.body), candle.o, str.tostring(candle.o), textalign = text.align_center, style = label.style_label_left, size = settings.label_size, color = color_transparent, textcolor = settings.label_color)
                            trace.o_l
                        else
                            label.set_xy(trace.o_l, box.get_right(candle.body), candle.o)
                            label.set_text(trace.o_l, str.tostring(candle.o))

                if bar_index - candle.c_idx < 5000
                    if na(trace.c)
                        trace.c := line.new(candle.c_idx, candle.c, box.get_left(candle.body), candle.c, xloc = xloc.bar_index, color = settings.trace_c_color, style = helper.LineStyle(settings.trace_c_style), width = settings.trace_c_size)
                        trace.c
                    else
                        line.set_xy1(trace.c, candle.c_idx, candle.c)
                        line.set_xy2(trace.c, box.get_left(candle.body), candle.c)

                    if settings.label_show
                        if na(trace.c_l)
                            trace.c_l := label.new(box.get_right(candle.body), candle.c, str.tostring(candle.c), textalign = text.align_center, style = label.style_label_left, size = settings.label_size, color = color_transparent, textcolor = settings.label_color)
                            trace.c_l
                        else
                            label.set_xy(trace.c_l, box.get_right(candle.body), candle.c)
                            label.set_text(trace.c_l, str.tostring(candle.c))

                if bar_index - candle.h_idx < 5000
                    if na(trace.h)
                        trace.h := line.new(candle.h_idx, candle.h, line.get_x1(candle.wick_up), candle.h, xloc = xloc.bar_index, color = settings.trace_h_color, style = helper.LineStyle(settings.trace_h_style), width = settings.trace_h_size)
                        trace.h
                    else
                        line.set_xy1(trace.h, candle.h_idx, candle.h)
                        line.set_xy2(trace.h, line.get_x1(candle.wick_up), candle.h)

                    if settings.label_show
                        if na(trace.h_l)
                            trace.h_l := label.new(box.get_right(candle.body), candle.h, str.tostring(candle.h), textalign = text.align_center, style = label.style_label_left, size = settings.label_size, color = color_transparent, textcolor = settings.label_color)
                            trace.h_l
                        else
                            label.set_xy(trace.h_l, box.get_right(candle.body), candle.h)
                            label.set_text(trace.h_l, str.tostring(candle.h))

                if bar_index - candle.l_idx < 5000
                    if na(trace.l)
                        trace.l := line.new(candle.l_idx, candle.l, line.get_x1(candle.wick_down), candle.l, xloc = xloc.bar_index, color = settings.trace_l_color, style = helper.LineStyle(settings.trace_l_style), width = settings.trace_l_size)
                        trace.l
                    else
                        line.set_xy1(trace.l, candle.l_idx, candle.l)
                        line.set_xy2(trace.l, line.get_x1(candle.wick_down), candle.l)

                    if settings.label_show
                        if na(trace.l_l)
                            trace.l_l := label.new(box.get_right(candle.body), candle.l, str.tostring(candle.l), textalign = text.align_center, style = label.style_label_left, size = settings.label_size, color = color_transparent, textcolor = settings.label_color)
                            trace.l_l
                        else
                            label.set_xy(trace.l_l, box.get_right(candle.body), candle.l)
                            label.set_text(trace.l_l, str.tostring(candle.l))
    candleSet

int cnt = 0
int last = helper.HTFEnabled()

CandleSet htf1Monitor = htf1.Monitor()
CandleSet htf2Monitor = htf2.Monitor()
CandleSet htf3Monitor = htf3.Monitor()
CandleSet htf4Monitor = htf4.Monitor()
CandleSet htf5Monitor = htf5.Monitor()
CandleSet htf6Monitor = htf6.Monitor()

int offset = settings.offset
if htf1.settings.show and helper.ValidTimeframe(htf1.settings.htf)
    bool showTrace = false
    if settings.trace_anchor == 'First Timeframe'
        showTrace := true
        showTrace
    if settings.trace_anchor == 'Last Timeframe' and settings.max_sets == 1
        showTrace := true
        showTrace
    htf1.UpdateTime(offset)
    htf1Monitor.Update(offset, showTrace).FindImbalance()
    cnt := cnt + 1
    offset := offset + (cnt > 0 ? htf1.candles.size() * settings.width + (htf1.candles.size() > 0 ? (htf1.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer : 0)
    offset
if htf2.settings.show and helper.ValidTimeframe(htf2.settings.htf) and cnt < last
    bool showTrace = false
    if settings.trace_anchor == 'First Timeframe' and cnt == 0
        showTrace := true
        showTrace
    if settings.trace_anchor == 'Last Timeframe' and cnt == last - 1
        showTrace := true
        showTrace
    htf2.UpdateTime(offset)
    htf2Monitor.Update(offset, showTrace).FindImbalance()
    cnt := cnt + 1
    offset := offset + (cnt > 0 ? htf2.candles.size() * settings.width + (htf2.candles.size() > 0 ? (htf2.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer : 0)
    offset
if htf3.settings.show and helper.ValidTimeframe(htf3.settings.htf) and cnt < last
    bool showTrace = false
    if settings.trace_anchor == 'First Timeframe' and cnt == 0
        showTrace := true
        showTrace
    if settings.trace_anchor == 'Last Timeframe' and cnt == last - 1
        showTrace := true
        showTrace
    htf3.UpdateTime(offset)
    htf3Monitor.Update(offset, showTrace).FindImbalance()
    cnt := cnt + 1
    offset := offset + (cnt > 0 ? htf3.candles.size() * settings.width + (htf3.candles.size() > 0 ? (htf3.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer : 0)
    offset
if htf4.settings.show and helper.ValidTimeframe(htf4.settings.htf) and cnt < last
    bool showTrace = false
    if settings.trace_anchor == 'First Timeframe' and cnt == 0
        showTrace := true
        showTrace
    if settings.trace_anchor == 'Last Timeframe' and cnt == last - 1
        showTrace := true
        showTrace
    htf4.UpdateTime(offset)
    htf4Monitor.Update(offset, showTrace).FindImbalance()
    cnt := cnt + 1
    offset := offset + (cnt > 0 ? htf4.candles.size() * settings.width + (htf4.candles.size() > 0 ? (htf4.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer : 0)
    offset
if htf5.settings.show and helper.ValidTimeframe(htf5.settings.htf) and cnt < last
    bool showTrace = false
    if settings.trace_anchor == 'First Timeframe' and cnt == 0
        showTrace := true
        showTrace
    if settings.trace_anchor == 'Last Timeframe' and cnt == last - 1
        showTrace := true
        showTrace
    htf5.UpdateTime(offset)
    htf5Monitor.Update(offset, showTrace).FindImbalance()
    cnt := cnt + 1
    offset := offset + (cnt > 0 ? htf5.candles.size() * settings.width + (htf5.candles.size() > 0 ? (htf5.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer : 0)
    offset
if htf6.settings.show and helper.ValidTimeframe(htf6.settings.htf) and cnt < last
    bool showTrace = false
    if settings.trace_anchor == 'First Timeframe' and cnt == 0
        showTrace := true
        showTrace
    if settings.trace_anchor == 'Last Timeframe'
        showTrace := true
        showTrace
    htf6.UpdateTime(offset)
    htf6Monitor.Update(offset, showTrace).FindImbalance()

// =================================================================================================
// FXN Asian Session Range
// =================================================================================================
//*************************************
// Discontinued Indicator - No Longer supported. Please update to by using the latest version now called "Diddly - Charts (Asian, London & New York Session + Weekdays)"
//*************************************

// Get User Inputs
user_ssth = input.string(title="Start Session Hour (EST)", defval="20", options=["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])
user_sstm = input.string(title="Start Session Minute (EST)", defval="00", options=["00", "15", "30", "45"])

user_esth = input.string(title="End Session Hour (EST)", defval="02", options=["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])
user_estm = input.string(title="End Session Minute (EST)", defval="00", options=["00", "15", "30", "45"])

user_elth = input.string(title="Extend Session Lines Until Hour (EST)", defval="11", options=["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])
user_eltm = input.string(title="Extend Session Lines Until Minute (EST)", defval="30", options=["00", "15", "30", "45"])



user_box_line_color = input.string(title="Asian Range Border Color", defval="blue", options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
boxLineWidth = input.int(title="Asian Box Line Width", defval=1, minval=0, maxval=10)
user_box_line_style = input.string(title="Asian Box Line Style", defval="solid", options=["solid", "dashed", "dotted"])

sessionLineWidth = input.int(title="Session High / Low / Mid Line Width", defval=2, minval=0, maxval=20)
user_upperlower_line_style = input.string(title="Session High / Low Line Style", defval="dotted", options=["solid", "dashed", "dotted"])

user_midline_color = input.string(title="Middle Range Line Color", defval="orange", options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
user_middle_line_style = input.string(title="Middle Range Line Style", defval="dotted", options=["solid", "dashed", "dotted"])

user_text_color = input.string(title="Text Color", defval="blue", options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
user_label_size = input.string(title="Text Size", defval="normal", options=["tiny", "small", "normal", "large"])


// London Session Inputs
show_london_session = input.bool(title="Show London Session Box", defval=true)
show_london_session_rng = input.bool(title="Show London Session Range Pips", defval=true)


london_ssth = input.string(title="London Start Hour (EST)", defval="03", options=["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])
london_sstm = input.string(title="London Start Minute (EST)", defval="00", options=["00", "15", "30", "45"])

london_esth = input.string(title="London End Hour (EST)", defval="07", options=["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])
london_estm = input.string(title="London End Minute (EST)", defval="00", options=["00", "15", "30", "45"])


luser_box_line_color = input.string(title="London Range Border Color", defval="teal", options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
lboxLineWidth = input.int(title="London Box Line Width", defval=1, minval=0, maxval=10)
luser_box_line_style = input.string(title="London Box Line Style", defval="solid", options=["solid", "dashed", "dotted"])

lsessionLineWidth = input.int(title="Session High / Low / Mid Line Width", defval=2, minval=0, maxval=20)
luser_upperlower_line_style = input.string(title="Session High / Low Line Style", defval="dotted", options=["solid", "dashed", "dotted"])

luser_midline_color = input.string(title="Middle Range Line Color", defval="teal", options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
luser_middle_line_style = input.string(title="Middle Range Line Style", defval="dotted", options=["solid", "dashed", "dotted"])

luser_text_color = input.string(title="Text Color", defval="teal", options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
luser_label_size = input.string(title="Text Size", defval="normal", options=["tiny", "small", "normal", "large"])

// End London


// New York Session Inputs
show_ny_session = input.bool(title="Show New York Session Box", defval=true)
show_ny_session_rng = input.bool(title="Show New York Session Range Pips", defval=true)

ny_ssth = input.string(title="New York Start Hour (EST)", defval="08", options=["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])
ny_sstm = input.string(title="New York Start Minute (EST)", defval="00", options=["00", "15", "30", "45"])

ny_esth = input.string(title="New York End Hour (EST)", defval="12", options=["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])
ny_estm = input.string(title="New York End Minute (EST)", defval="00", options=["00", "15", "30", "45"])


nuser_box_line_color = input.string(title="New York Range Border Color", defval="silver", options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
nboxLineWidth = input.int(title="New York Box Line Width", defval=1, minval=0, maxval=10)
nuser_box_line_style = input.string(title="New York Box Line Style", defval="solid", options=["solid", "dashed", "dotted"])

nsessionLineWidth = input.int(title="Session High / Low / Mid Line Width", defval=2, minval=0, maxval=20)
nuser_upperlower_line_style = input.string(title="Session High / Low Line Style", defval="dotted", options=["solid", "dashed", "dotted"])

nuser_midline_color = input.string(title="Middle Range Line Color", defval="silver", options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
nuser_middle_line_style = input.string(title="Middle Range Line Style", defval="dotted", options=["solid", "dashed", "dotted"])

nuser_text_color = input.string(title="Text Color", defval="silver", options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
nuser_label_size = input.string(title="Text Size", defval="normal", options=["tiny", "small", "normal", "large"])

showADR = input.bool(title="Show Average Daily Range", defval=true)
is_forex_pips = input.bool(title="Display average range as forex pips?", defval=true)
daily_adr_user = input.int(title="Show ADR for x days", defval=1, minval=0)
daily_adr_length = input.int(title="ADR Length parameter (Days - default 3 weeks, 21 days)", defval=21, minval=0)

showPreviousDayHiLo = input.bool(title="Show Previous Days High / Low", defval=true)
previousDayHiLoColor = input.string(title="Previous Days Line Color", defval="yellow", options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
supportLineWidth = input.int(title="Previous Days Line Width", defval=1, minval=0, maxval=10)
previousDayHiLoLineStyle = input.string(title="Previous Days Line Style", defval="dashed", options=["solid", "dashed", "dotted"])
showHiLoPriceRange = input.bool(title="Show Previous Days Range", defval=false)
showHiLoPriceLabel = input.bool(title="Show Line Label (YH / YL)", defval=false)


showLastWeeklyHiLo = input.bool(title="Show Last Weeks High / Low", defval=true)
lastWeeklyHiLoColor = input.string(title="Last Week Line Color", defval="orange", options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
supportLastWeekLineWidth = input.int(title="Last Week Line Width", defval=1, minval=0, maxval=10)
lastWeeklyHiLoStyle = input.string(title="Last Week Line Style", defval="dashed", options=["solid", "dashed", "dotted"])
lastWeeklyHiLoShowLabel = input.bool(title="Show Line Label (PWH / PWL)", defval=true)


showWeeklyHiLo = input.bool(title="Show This Weeks High / Low", defval=false)
weeklyHiLoColor = input.string(title="This Weeks Line Color", defval="olive", options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
supportWeekLineWidth = input.int(title="This Weeks Line Width", defval=1, minval=0, maxval=10)
weeklyHiLoStyle = input.string(title="This Weeks Line Style", defval="dashed", options=["solid", "dashed", "dotted"])
weeklyHiLoShowLabel = input.bool(title="Show Line Label (WH / WL)", defval=false)

showHiLoTime = input.bool(title="Show Hi / Low Time of Day (Always Displays Eastern Standard Time)", defval=false)


// End User Inputs



// Asian Input Convertions
line_color = user_box_line_color == "aqua" ? color.aqua : user_box_line_color == "black" ? color.black : user_box_line_color == "blue" ? color.blue : user_box_line_color == "fuchsia" ? color.fuchsia : user_box_line_color == "gray" ? color.gray : user_box_line_color == "green" ? color.green : user_box_line_color == "lime" ? color.lime : user_box_line_color == "maroon" ? color.maroon : user_box_line_color == "navy" ? color.navy : user_box_line_color == "olive" ? color.olive : user_box_line_color == "orange" ? color.orange : user_box_line_color == "purple" ? color.purple : user_box_line_color == "red" ? color.red : user_box_line_color == "silver" ? color.silver : user_box_line_color == "teal" ? color.teal : user_box_line_color == "white" ? color.white : user_box_line_color == "yellow" ? color.yellow : color.black
midline_color = user_midline_color == "aqua" ? color.aqua : user_midline_color == "black" ? color.black : user_midline_color == "blue" ? color.blue : user_midline_color == "fuchsia" ? color.fuchsia : user_midline_color == "gray" ? color.gray : user_midline_color == "green" ? color.green : user_midline_color == "lime" ? color.lime : user_midline_color == "maroon" ? color.maroon : user_midline_color == "navy" ? color.navy : user_midline_color == "olive" ? color.olive : user_midline_color == "orange" ? color.orange : user_midline_color == "purple" ? color.purple : user_midline_color == "red" ? color.red : user_midline_color == "silver" ? color.silver : user_midline_color == "teal" ? color.teal : user_midline_color == "white" ? color.white : user_midline_color == "yellow" ? color.yellow : color.black
text_color = user_text_color == "aqua" ? color.aqua : user_text_color == "black" ? color.black : user_text_color == "blue" ? color.blue : user_text_color == "fuchsia" ? color.fuchsia : user_text_color == "gray" ? color.gray : user_text_color == "green" ? color.green : user_text_color == "lime" ? color.lime : user_text_color == "maroon" ? color.maroon : user_text_color == "navy" ? color.navy : user_text_color == "olive" ? color.olive : user_text_color == "orange" ? color.orange : user_text_color == "purple" ? color.purple : user_text_color == "red" ? color.red : user_text_color == "silver" ? color.silver : user_text_color == "teal" ? color.teal : user_text_color == "white" ? color.white : user_text_color == "yellow" ? color.yellow : color.black

box_line_style = user_box_line_style == "solid" ? line.style_solid : user_box_line_style == "dashed" ? line.style_dashed : user_box_line_style == "dotted" ? line.style_dotted : line.style_solid
upperlower_line_style = user_upperlower_line_style == "solid" ? line.style_solid : user_upperlower_line_style == "dashed" ? line.style_dashed : user_upperlower_line_style == "dotted" ? line.style_dotted : line.style_solid
middle_line_style = user_middle_line_style == "solid" ? line.style_solid : user_middle_line_style == "dashed" ? line.style_dashed : user_middle_line_style == "dotted" ? line.style_dotted : line.style_solid

labelsize = user_label_size == "tiny" ? size.tiny : user_label_size == "small" ? size.small : user_label_size == "normal" ? size.normal : user_label_size == "large" ? size.large : size.normal
//

// London Input Convertions
lline_color = luser_box_line_color == "aqua" ? color.aqua : luser_box_line_color == "black" ? color.black : luser_box_line_color == "blue" ? color.blue : luser_box_line_color == "fuchsia" ? color.fuchsia : luser_box_line_color == "gray" ? color.gray : luser_box_line_color == "green" ? color.green : luser_box_line_color == "lime" ? color.lime : luser_box_line_color == "maroon" ? color.maroon : luser_box_line_color == "navy" ? color.navy : luser_box_line_color == "olive" ? color.olive : luser_box_line_color == "orange" ? color.orange : luser_box_line_color == "purple" ? color.purple : luser_box_line_color == "red" ? color.red : luser_box_line_color == "silver" ? color.silver : luser_box_line_color == "teal" ? color.teal : luser_box_line_color == "white" ? color.white : luser_box_line_color == "yellow" ? color.yellow : color.black
lmidline_color = luser_midline_color == "aqua" ? color.aqua : luser_midline_color == "black" ? color.black : luser_midline_color == "blue" ? color.blue : luser_midline_color == "fuchsia" ? color.fuchsia : luser_midline_color == "gray" ? color.gray : luser_midline_color == "green" ? color.green : luser_midline_color == "lime" ? color.lime : luser_midline_color == "maroon" ? color.maroon : luser_midline_color == "navy" ? color.navy : luser_midline_color == "olive" ? color.olive : luser_midline_color == "orange" ? color.orange : luser_midline_color == "purple" ? color.purple : luser_midline_color == "red" ? color.red : luser_midline_color == "silver" ? color.silver : luser_midline_color == "teal" ? color.teal : luser_midline_color == "white" ? color.white : luser_midline_color == "yellow" ? color.yellow : color.black
ltext_color = luser_text_color == "aqua" ? color.aqua : luser_text_color == "black" ? color.black : luser_text_color == "blue" ? color.blue : luser_text_color == "fuchsia" ? color.fuchsia : luser_text_color == "gray" ? color.gray : luser_text_color == "green" ? color.green : luser_text_color == "lime" ? color.lime : luser_text_color == "maroon" ? color.maroon : luser_text_color == "navy" ? color.navy : luser_text_color == "olive" ? color.olive : luser_text_color == "orange" ? color.orange : luser_text_color == "purple" ? color.purple : luser_text_color == "red" ? color.red : luser_text_color == "silver" ? color.silver : luser_text_color == "teal" ? color.teal : luser_text_color == "white" ? color.white : luser_text_color == "yellow" ? color.yellow : color.black

lbox_line_style = luser_box_line_style == "solid" ? line.style_solid : luser_box_line_style == "dashed" ? line.style_dashed : luser_box_line_style == "dotted" ? line.style_dotted : line.style_solid
lupperlower_line_style = luser_upperlower_line_style == "solid" ? line.style_solid : luser_upperlower_line_style == "dashed" ? line.style_dashed : luser_upperlower_line_style == "dotted" ? line.style_dotted : line.style_solid
lmiddle_line_style = luser_middle_line_style == "solid" ? line.style_solid : luser_middle_line_style == "dashed" ? line.style_dashed : luser_middle_line_style == "dotted" ? line.style_dotted : line.style_solid

llabelsize = luser_label_size == "tiny" ? size.tiny : luser_label_size == "small" ? size.small : luser_label_size == "normal" ? size.normal : luser_label_size == "large" ? size.large : size.normal
//

// New York Input Convertions
nline_color = nuser_box_line_color == "aqua" ? color.aqua : nuser_box_line_color == "black" ? color.black : nuser_box_line_color == "blue" ? color.blue : nuser_box_line_color == "fuchsia" ? color.fuchsia : nuser_box_line_color == "gray" ? color.gray : nuser_box_line_color == "green" ? color.green : nuser_box_line_color == "lime" ? color.lime : nuser_box_line_color == "maroon" ? color.maroon : nuser_box_line_color == "navy" ? color.navy : nuser_box_line_color == "olive" ? color.olive : nuser_box_line_color == "orange" ? color.orange : nuser_box_line_color == "purple" ? color.purple : nuser_box_line_color == "red" ? color.red : nuser_box_line_color == "silver" ? color.silver : nuser_box_line_color == "teal" ? color.teal : nuser_box_line_color == "white" ? color.white : nuser_box_line_color == "yellow" ? color.yellow : color.black
nmidline_color = nuser_midline_color == "aqua" ? color.aqua : nuser_midline_color == "black" ? color.black : nuser_midline_color == "blue" ? color.blue : nuser_midline_color == "fuchsia" ? color.fuchsia : nuser_midline_color == "gray" ? color.gray : nuser_midline_color == "green" ? color.green : nuser_midline_color == "lime" ? color.lime : nuser_midline_color == "maroon" ? color.maroon : nuser_midline_color == "navy" ? color.navy : nuser_midline_color == "olive" ? color.olive : nuser_midline_color == "orange" ? color.orange : nuser_midline_color == "purple" ? color.purple : nuser_midline_color == "red" ? color.red : nuser_midline_color == "silver" ? color.silver : nuser_midline_color == "teal" ? color.teal : nuser_midline_color == "white" ? color.white : nuser_midline_color == "yellow" ? color.yellow : color.black
ntext_color = nuser_text_color == "aqua" ? color.aqua : nuser_text_color == "black" ? color.black : nuser_text_color == "blue" ? color.blue : nuser_text_color == "fuchsia" ? color.fuchsia : nuser_text_color == "gray" ? color.gray : nuser_text_color == "green" ? color.green : nuser_text_color == "lime" ? color.lime : nuser_text_color == "maroon" ? color.maroon : nuser_text_color == "navy" ? color.navy : nuser_text_color == "olive" ? color.olive : nuser_text_color == "orange" ? color.orange : nuser_text_color == "purple" ? color.purple : nuser_text_color == "red" ? color.red : nuser_text_color == "silver" ? color.silver : nuser_text_color == "teal" ? color.teal : nuser_text_color == "white" ? color.white : nuser_text_color == "yellow" ? color.yellow : color.black

nbox_line_style = nuser_box_line_style == "solid" ? line.style_solid : nuser_box_line_style == "dashed" ? line.style_dashed : nuser_box_line_style == "dotted" ? line.style_dotted : line.style_solid
nupperlower_line_style = nuser_upperlower_line_style == "solid" ? line.style_solid : nuser_upperlower_line_style == "dashed" ? line.style_dashed : nuser_upperlower_line_style == "dotted" ? line.style_dotted : line.style_solid
nmiddle_line_style = nuser_middle_line_style == "solid" ? line.style_solid : nuser_middle_line_style == "dashed" ? line.style_dashed : nuser_middle_line_style == "dotted" ? line.style_dotted : line.style_solid

nlabelsize = nuser_label_size == "tiny" ? size.tiny : nuser_label_size == "small" ? size.small : nuser_label_size == "normal" ? size.normal : nuser_label_size == "large" ? size.large : size.normal

// ADR Reset Period for Weekend
// If weekend then need to adjust
// the user input period for how long
// back they want to see the ADR
daily_adr = daily_adr_user
if dayofweek == dayofweek.sunday
    daily_adr := daily_adr + 1
if dayofweek == dayofweek.saturday
    daily_adr := daily_adr + 1
//

// High Low Support / resistance
lblTP = 70

support_line_color = previousDayHiLoColor == "aqua" ? color.aqua : previousDayHiLoColor == "black" ? color.black : previousDayHiLoColor == "blue" ? color.blue : previousDayHiLoColor == "fuchsia" ? color.fuchsia : previousDayHiLoColor == "gray" ? color.gray : previousDayHiLoColor == "green" ? color.green : previousDayHiLoColor == "lime" ? color.lime : previousDayHiLoColor == "maroon" ? color.maroon : previousDayHiLoColor == "navy" ? color.navy : previousDayHiLoColor == "olive" ? color.olive : previousDayHiLoColor == "orange" ? color.orange : previousDayHiLoColor == "purple" ? color.purple : previousDayHiLoColor == "red" ? color.red : previousDayHiLoColor == "silver" ? color.silver : previousDayHiLoColor == "teal" ? color.teal : previousDayHiLoColor == "white" ? color.white : previousDayHiLoColor == "yellow" ? color.yellow : color.black
support_line_label_color = previousDayHiLoColor == "aqua" ? color.new(color.aqua,lblTP) : previousDayHiLoColor == "black" ? color.new(color.black,lblTP) : previousDayHiLoColor == "blue" ? color.new(color.blue,lblTP) : previousDayHiLoColor == "fuchsia" ? color.new(color.fuchsia,lblTP) : previousDayHiLoColor == "gray" ? color.new(color.gray,lblTP) : previousDayHiLoColor == "green" ? color.new(color.green,lblTP) : previousDayHiLoColor == "lime" ? color.new(color.lime,lblTP) : previousDayHiLoColor == "maroon" ? color.new(color.maroon,lblTP) : previousDayHiLoColor == "navy" ? color.new(color.navy,lblTP) : previousDayHiLoColor == "olive" ? color.new(color.olive,lblTP) : previousDayHiLoColor == "orange" ? color.new(color.orange,lblTP) : previousDayHiLoColor == "purple" ? color.new(color.purple,lblTP) : previousDayHiLoColor == "red" ? color.new(color.red,lblTP) : previousDayHiLoColor == "silver" ? color.new(color.silver,lblTP) : previousDayHiLoColor == "teal" ? color.new(color.teal,lblTP) : previousDayHiLoColor == "white" ? color.new(color.white,lblTP) : previousDayHiLoColor == "yellow" ? color.new(color.yellow,lblTP) : color.new(color.black,lblTP)

support_line_style = previousDayHiLoLineStyle == "solid" ? line.style_solid : previousDayHiLoLineStyle == "dashed" ? line.style_dashed : previousDayHiLoLineStyle == "dotted" ? line.style_dotted : line.style_solid


support_last_week_line_color = lastWeeklyHiLoColor == "aqua" ? color.aqua : lastWeeklyHiLoColor == "black" ? color.black : lastWeeklyHiLoColor == "blue" ? color.blue : lastWeeklyHiLoColor == "fuchsia" ? color.fuchsia : lastWeeklyHiLoColor == "gray" ? color.gray : lastWeeklyHiLoColor == "green" ? color.green : lastWeeklyHiLoColor == "lime" ? color.lime : lastWeeklyHiLoColor == "maroon" ? color.maroon : lastWeeklyHiLoColor == "navy" ? color.navy : lastWeeklyHiLoColor == "olive" ? color.olive : lastWeeklyHiLoColor == "orange" ? color.orange : lastWeeklyHiLoColor == "purple" ? color.purple : lastWeeklyHiLoColor == "red" ? color.red : lastWeeklyHiLoColor == "silver" ? color.silver : lastWeeklyHiLoColor == "teal" ? color.teal : lastWeeklyHiLoColor == "white" ? color.white : lastWeeklyHiLoColor == "yellow" ? color.yellow : color.black
support_last_week_line_label_color = lastWeeklyHiLoColor == "aqua" ? color.new(color.aqua,lblTP) : lastWeeklyHiLoColor == "black" ? color.new(color.black,lblTP) : lastWeeklyHiLoColor == "blue" ? color.new(color.blue,lblTP) : lastWeeklyHiLoColor == "fuchsia" ? color.new(color.fuchsia,lblTP) : lastWeeklyHiLoColor == "gray" ? color.new(color.gray,lblTP) : lastWeeklyHiLoColor == "green" ? color.new(color.green,lblTP) : lastWeeklyHiLoColor == "lime" ? color.new(color.lime,lblTP) : lastWeeklyHiLoColor == "maroon" ? color.new(color.maroon,lblTP) : lastWeeklyHiLoColor == "navy" ? color.new(color.navy,lblTP) : lastWeeklyHiLoColor == "olive" ? color.new(color.olive,lblTP) : lastWeeklyHiLoColor == "orange" ? color.new(color.orange,lblTP) : lastWeeklyHiLoColor == "purple" ? color.new(color.purple,lblTP) : lastWeeklyHiLoColor == "red" ? color.new(color.red,lblTP) : lastWeeklyHiLoColor == "silver" ? color.new(color.silver,lblTP) : lastWeeklyHiLoColor == "teal" ? color.new(color.teal,lblTP) : lastWeeklyHiLoColor == "white" ? color.new(color.white,lblTP) : lastWeeklyHiLoColor == "yellow" ? color.new(color.yellow,lblTP) : color.new(color.black,lblTP)

support_last_week_line_style = lastWeeklyHiLoStyle == "solid" ? line.style_solid : lastWeeklyHiLoStyle == "dashed" ? line.style_dashed : lastWeeklyHiLoStyle == "dotted" ? line.style_dotted : line.style_solid

wlineTP = 30
support_week_line_color = weeklyHiLoColor == "aqua" ? color.new(color.aqua,wlineTP) : weeklyHiLoColor == "black" ? color.new(color.black,wlineTP) : weeklyHiLoColor == "blue" ? color.new(color.blue,wlineTP) : weeklyHiLoColor == "fuchsia" ? color.new(color.fuchsia,wlineTP) : weeklyHiLoColor == "gray" ? color.new(color.gray,wlineTP) : weeklyHiLoColor == "green" ? color.new(color.green,wlineTP) : weeklyHiLoColor == "lime" ? color.new(color.lime,wlineTP) : weeklyHiLoColor == "maroon" ? color.new(color.maroon,wlineTP) : weeklyHiLoColor == "navy" ? color.new(color.navy,wlineTP) : weeklyHiLoColor == "olive" ? color.new(color.olive,wlineTP) : weeklyHiLoColor == "orange" ? color.new(color.orange,wlineTP) : weeklyHiLoColor == "purple" ? color.new(color.purple,wlineTP) : weeklyHiLoColor == "red" ? color.new(color.red,wlineTP) : weeklyHiLoColor == "silver" ? color.new(color.silver,wlineTP) : weeklyHiLoColor == "teal" ? color.new(color.teal,wlineTP) : weeklyHiLoColor == "white" ? color.new(color.white,wlineTP) : weeklyHiLoColor == "yellow" ? color.new(color.yellow,wlineTP) : color.new(color.black,wlineTP)
support_week_line_style = weeklyHiLoStyle == "solid" ? line.style_solid : weeklyHiLoStyle == "dashed" ? line.style_dashed : weeklyHiLoStyle == "dotted" ? line.style_dotted : line.style_solid



chart_time_period_int = timeframe.period == "1" ? 1 : timeframe.period == "3" ? 3 : timeframe.period == "5" ? 5 : timeframe.period == "15" ? 15 : timeframe.period == "30" ? 30 : timeframe.period == "45" ? 45 : 15
tickerExchangeOffset = 4

// Asian Session
int start_session_hour_int = 0
int end_session_hour_int = 0
int end_line_hour_int = 0

start_session_hour_int := user_ssth == "00" ? 0 : user_ssth == "01" ? 1 : user_ssth == "02" ? 2 : user_ssth == "03" ? 3 : user_ssth == "04" ? 4 : user_ssth == "05" ? 5 : user_ssth == "06" ? 6 : user_ssth == "07" ? 7 : user_ssth == "08" ? 8 : user_ssth == "09" ? 9 : user_ssth == "10" ? 10 : user_ssth == "11" ? 11 : user_ssth == "12" ? 12 : user_ssth == "13" ? 13 : user_ssth == "14" ? 14 : user_ssth == "15" ? 15 : user_ssth == "16" ? 16 : user_ssth == "17" ? 17 : user_ssth == "18" ? 18 : user_ssth == "19" ? 19 : user_ssth == "20" ? 20 : user_ssth == "21" ? 21 : user_ssth == "22" ? 22 : user_ssth == "23" ? 23 : 0
start_session_minute_int = user_sstm == "00" ? 0 : user_sstm == "15" ? 15 : user_sstm == "30" ? 30 : user_sstm == "45" ? 45 : 0

end_session_hour_int := user_esth == "00" ? 0 : user_esth == "01" ? 1 : user_esth == "02" ? 2 : user_esth == "03" ? 3 : user_esth == "04" ? 4 : user_esth == "05" ? 5 : user_esth == "06" ? 6 : user_esth == "07" ? 7 : user_esth == "08" ? 8 : user_esth == "09" ? 9 : user_esth == "10" ? 10 : user_esth == "11" ? 11 : user_esth == "12" ? 12 : user_esth == "13" ? 13 : user_esth == "14" ? 14 : user_esth == "15" ? 15 : user_esth == "16" ? 16 : user_esth == "17" ? 17 : user_esth == "18" ? 18 : user_esth == "19" ? 19 : user_esth == "20" ? 20 : user_esth == "21" ? 21 : user_esth == "22" ? 22 : user_esth == "23" ? 23 : 0
end_session_minute_int = user_estm == "00" ? 0 : user_estm == "15" ? 15 : user_estm == "30" ? 30 : user_estm == "45" ? 45 : 0

end_line_hour_int := user_elth == "00" ? 0 : user_elth == "01" ? 1 : user_elth == "02" ? 2 : user_elth == "03" ? 3 : user_elth == "04" ? 4 : user_elth == "05" ? 5 : user_elth == "06" ? 6 : user_elth == "07" ? 7 : user_elth == "08" ? 8 : user_elth == "09" ? 9 : user_elth == "10" ? 10 : user_elth == "11" ? 11 : user_elth == "12" ? 12 : user_elth == "13" ? 13 : user_elth == "14" ? 14 : user_elth == "15" ? 15 : user_elth == "16" ? 16 : user_elth == "17" ? 17 : user_elth == "18" ? 18 : user_elth == "19" ? 19 : user_elth == "20" ? 20 : user_elth == "21" ? 21 : user_elth == "22" ? 22 : user_elth == "23" ? 23 : 0
end_line_minute_int = user_eltm == "00" ? 0 : user_eltm == "15" ? 15 : user_eltm == "30" ? 30 : user_eltm == "45" ? 45 : 0

end_session_minute_int_offset = (end_session_minute_int + chart_time_period_int)

// End Section

// London Session
int london_start_session_hour_int = 0
int london_end_session_hour_int = 0

london_start_session_hour_int := london_ssth == "00" ? 0 : london_ssth == "01" ? 1 : london_ssth == "02" ? 2 : london_ssth == "03" ? 3 : london_ssth == "04" ? 4 : london_ssth == "05" ? 5 : london_ssth == "06" ? 6 : london_ssth == "07" ? 7 : london_ssth == "08" ? 8 : london_ssth == "09" ? 9 : london_ssth == "10" ? 10 : london_ssth == "11" ? 11 : london_ssth == "12" ? 12 : london_ssth == "13" ? 13 : london_ssth == "14" ? 14 : london_ssth == "15" ? 15 : london_ssth == "16" ? 16 : london_ssth == "17" ? 17 : london_ssth == "18" ? 18 : london_ssth == "19" ? 19 : london_ssth == "20" ? 20 : london_ssth == "21" ? 21 : london_ssth == "22" ? 22 : london_ssth == "23" ? 23 : 0
london_start_session_minute_int = london_sstm == "00" ? 0 : london_sstm == "15" ? 15 : london_sstm == "30" ? 30 : london_sstm == "45" ? 45 : 0

london_end_session_hour_int := london_esth == "00" ? 0 : london_esth == "01" ? 1 : london_esth == "02" ? 2 : london_esth == "03" ? 3 : london_esth == "04" ? 4 : london_esth == "05" ? 5 : london_esth == "06" ? 6 : london_esth == "07" ? 7 : london_esth == "08" ? 8 : london_esth == "09" ? 9 : london_esth == "10" ? 10 : london_esth == "11" ? 11 : london_esth == "12" ? 12 : london_esth == "13" ? 13 : london_esth == "14" ? 14 : london_esth == "15" ? 15 : london_esth == "16" ? 16 : london_esth == "17" ? 17 : london_esth == "18" ? 18 : london_esth == "19" ? 19 : london_esth == "20" ? 20 : london_esth == "21" ? 21 : london_esth == "22" ? 22 : london_esth == "23" ? 23 : 0
london_end_session_minute_int = london_estm == "00" ? 0 : london_estm == "15" ? 15 : london_estm == "30" ? 30 : london_estm == "45" ? 45 : 0


london_end_session_minute_int_offset = (london_end_session_minute_int + chart_time_period_int)

// End Section

// Check Chart Period to see if aspects should display
isValidResolution() => not (timeframe.isdwm or timeframe.period == "120" or timeframe.period == "240" or timeframe.period == "180" or timeframe.period == "360")
isBelowHourValidResolution() => not (timeframe.isdwm or timeframe.period == "120" or timeframe.period == "240" or timeframe.period == "180" or timeframe.period == "360")


// NY Session
int ny_start_session_hour_int = 0
int ny_end_session_hour_int = 0

ny_start_session_hour_int := ny_ssth == "00" ? 0 : ny_ssth == "01" ? 1 : ny_ssth == "02" ? 2 : ny_ssth == "03" ? 3 : ny_ssth == "04" ? 4 : ny_ssth == "05" ? 5 : ny_ssth == "06" ? 6 : ny_ssth == "07" ? 7 : ny_ssth == "08" ? 8 : ny_ssth == "09" ? 9 : ny_ssth == "10" ? 10 : ny_ssth == "11" ? 11 : ny_ssth == "12" ? 12 : ny_ssth == "13" ? 13 : ny_ssth == "14" ? 14 : ny_ssth == "15" ? 15 : ny_ssth == "16" ? 16 : ny_ssth == "17" ? 17 : ny_ssth == "18" ? 18 : ny_ssth == "19" ? 19 : ny_ssth == "20" ? 20 : ny_ssth == "21" ? 21 : ny_ssth == "22" ? 22 : ny_ssth == "23" ? 23 : 0
ny_start_session_minute_int = ny_sstm == "00" ? 0 : ny_sstm == "15" ? 15 : ny_sstm == "30" ? 30 : ny_sstm == "45" ? 45 : 0

ny_end_session_hour_int := ny_esth == "00" ? 0 : ny_esth == "01" ? 1 : ny_esth == "02" ? 2 : ny_esth == "03" ? 3 : ny_esth == "04" ? 4 : ny_esth == "05" ? 5 : ny_esth == "06" ? 6 : ny_esth == "07" ? 7 : ny_esth == "08" ? 8 : ny_esth == "09" ? 9 : ny_esth == "10" ? 10 : ny_esth == "11" ? 11 : ny_esth == "12" ? 12 : ny_esth == "13" ? 13 : ny_esth == "14" ? 14 : ny_esth == "15" ? 15 : ny_esth == "16" ? 16 : ny_esth == "17" ? 17 : ny_esth == "18" ? 18 : ny_esth == "19" ? 19 : ny_esth == "20" ? 20 : ny_esth == "21" ? 21 : ny_esth == "22" ? 22 : ny_esth == "23" ? 23 : 0
ny_end_session_minute_int = ny_estm == "00" ? 0 : ny_estm == "15" ? 15 : ny_estm == "30" ? 30 : ny_estm == "45" ? 45 : 0


ny_end_session_minute_int_offset = (ny_end_session_minute_int + chart_time_period_int)

// End Section


// Support Structures Time Details
start_support_hour_int = 17
start_support_minute_int = 0
end_support_hour_int = 17
end_support_minute_int = 0
// End Section

// Forex.com use a different server time that other brokers
// So need to adjust
if (syminfo.timezone == "Etc/UTC")
    start_session_hour_int := start_session_hour_int + tickerExchangeOffset
    end_session_hour_int := end_session_hour_int + tickerExchangeOffset
    end_line_hour_int := end_line_hour_int + tickerExchangeOffset
    
    london_start_session_hour_int := london_start_session_hour_int + tickerExchangeOffset
    london_end_session_hour_int := london_end_session_hour_int + tickerExchangeOffset

    ny_start_session_hour_int := ny_start_session_hour_int + tickerExchangeOffset
    ny_end_session_hour_int := ny_end_session_hour_int + tickerExchangeOffset
    
    start_support_hour_int := start_support_hour_int + tickerExchangeOffset
    end_support_hour_int := end_support_hour_int + tickerExchangeOffset

    // Asian Condition    
    // Need to check the adjusted time to make sure it is correct
    if (start_session_hour_int >= 24)
        if (start_session_hour_int == 24)
            user_ssth := "00"
        else
            user_ssth := "0" + str.tostring(start_session_hour_int - 24)
    else
        if (start_session_hour_int < 10)
            user_ssth := "0" + str.tostring(start_session_hour_int)
        else
            user_ssth := str.tostring(start_session_hour_int)
    

    if (end_session_hour_int >= 24)
        if (end_session_hour_int == 24)
            user_esth := "00"
        else
            user_esth := "0" + str.tostring(end_session_hour_int - 24)
    else
        if (end_session_hour_int < 10)
            user_esth := "0" + str.tostring(end_session_hour_int)
        else
            user_esth := str.tostring(end_session_hour_int)

    // End Condition

    // London Condition
    // Need to check the adjusted time to make sure it is correct
    if (london_start_session_hour_int >= 24)
        if (london_start_session_hour_int == 24)
            london_ssth := "00"
        else
            london_ssth := "0" + str.tostring(london_start_session_hour_int - 24)
    else
        if (london_start_session_hour_int < 10)
            london_ssth := "0" + str.tostring(london_start_session_hour_int)
        else
            london_ssth := str.tostring(london_start_session_hour_int)
    

    if (london_end_session_hour_int >= 24)
        if (london_end_session_hour_int == 24)
            london_esth := "00"
        else
            london_esth := "0" + str.tostring(london_end_session_hour_int - 24)
    else
        if (london_end_session_hour_int < 10)
            london_esth := "0" + str.tostring(london_end_session_hour_int)
        else
            london_esth := str.tostring(london_end_session_hour_int)

    // End Condition

    // New York Condition
    // Need to check the adjusted time to make sure it is correct
    if (ny_start_session_hour_int >= 24)
        if (ny_start_session_hour_int == 24)
            ny_ssth := "00"
        else
            ny_ssth := "0" + str.tostring(ny_start_session_hour_int - 24)
    else
        if (ny_start_session_hour_int < 10)
            ny_ssth := "0" + str.tostring(ny_start_session_hour_int)
        else
            ny_ssth := str.tostring(ny_start_session_hour_int)
    

    if (ny_end_session_hour_int >= 24)
        if (ny_end_session_hour_int == 24)
            ny_esth := "00"
        else
            ny_esth := "0" + str.tostring(ny_end_session_hour_int - 24)
    else
        if (ny_end_session_hour_int < 10)
            ny_esth := "0" + str.tostring(ny_end_session_hour_int)
        else
            ny_esth := str.tostring(ny_end_session_hour_int)

    // End Condition
    
// End Section

// this is the tradable session, from end of Asia to the end of NY 
trd_ses = (user_esth) + (user_estm) + "-" + (ny_esth) + (ny_estm)
//
rth_ses = ""
london_rth_ses = ""
ny_rth_ses = ""

rth_fill_ses = ""
london_rth_fill_ses = ""
ny_rth_fill_ses = ""

// RM changed the session details, rather than using offset to the user input minute
// So conditional logic is not required.
// Note - Not 100% sure why this complex logic was introduced. There could be knockon issues, so have retained existing logic remmed out.
// Actually looks like the extended logic is due to the back fill of the range
rth_ses := (user_ssth) + (user_sstm) + "-" + (user_esth) + user_estm
london_rth_ses := (london_ssth) + (london_sstm) + "-" + (london_esth) +  london_estm
ny_rth_ses := (ny_ssth) + (ny_sstm) + "-" + (ny_esth) + ny_estm

// Check the timeframe and the expected time and adjust appropiately
if (timeframe.period == "5" or timeframe.period == "3" or timeframe.period == "1") and end_session_minute_int == 0
    rth_fill_ses := (user_ssth) + (user_sstm) + "-" + (user_esth) + "0" + str.tostring(end_session_minute_int_offset)
else
    rth_fill_ses := (user_ssth) + (user_sstm) + "-" + (user_esth) + str.tostring(end_session_minute_int_offset)

if (timeframe.period == "5" or timeframe.period == "3" or timeframe.period == "1")  and london_end_session_minute_int == 0
    london_rth_fill_ses := (london_ssth) + (london_sstm) + "-" + (london_esth) +  "0" + str.tostring(london_end_session_minute_int_offset)
else
    london_rth_fill_ses := (london_ssth) + (london_sstm) + "-" + (london_esth) + str.tostring(london_end_session_minute_int_offset)


if (timeframe.period == "5" or timeframe.period == "3" or timeframe.period == "1")  and ny_end_session_minute_int == 0
    ny_rth_fill_ses := (ny_ssth) + (ny_sstm) + "-" + (ny_esth) + "0" + str.tostring(ny_end_session_minute_int_offset)
else
    ny_rth_fill_ses := (ny_ssth) + (ny_sstm) + "-" + (ny_esth) + str.tostring(ny_end_session_minute_int_offset)
 
// End Remove Logic Section

// End User Inputs

// General Functions
open_bar(ses) => 
    t = time("D", ses) 
    na(t[1]) and not na(t) or t[1] < t

is_open(ses) =>
    not na(time(timeframe.period, ses))


is_end_day() => 
    hour == 16 and minute == 45 ? true : false

is_new_day() => 
    syminfo.timezone == "Etc/UTC" and hour == 0 and minute == 0 ? true : syminfo.timezone != "Etc/UTC" and hour == 20 and minute == 0 ? true : false


get_label_offset(session) =>
    //o = 12//(barssince(not session[2]))
    //(o >= 12 and o <= 24) ? time[12] : time[24]
    (timeframe.period == "1") ? time[180] : (timeframe.period == "3") ? time[60] : (timeframe.period == "5") ? time[36] : (timeframe.period == "15") ? time[12] : (timeframe.period == "60") ? time[3] : time[12]

// With a new trading day starting at 5pm EST.
// When moving to new day need to check if the server
// still perceives is yesterday when the new trading day has started
is_new_day_switch_period() => 
    (hour >= 20 and minute == 0) and (hour <= 23 and minute <= 59) ? true: false


timerange(res, sess) => not na(time(res, sess))
//


// Calculate ADR
adr(length) =>
    barRange = high - low
    ta.sma(barRange[1], length)
to_pips(val) =>
    is_forex_pips ? math.round(val/syminfo.mintick/10) : math.round(val/syminfo.mintick)


day_adr = request.security(syminfo.tickerid, 'D', adr(daily_adr_length), lookahead=barmerge.lookahead_on)
one_day = 1000 * 60 * 60 * 24
// End ADR Calculation    


srcHi = high
srcLo = low

// Construct Asian Session Range
var session_hi = 10e-10
var session_lo = 10e10

startTimeDelta = 24 - start_session_hour_int + 1
endTimeDelta = 24 - start_session_hour_int + 1

startTimeAlignment() => (hour + startTimeDelta) > 24? 0 : 1


//
isStartTimeAlignment = startTimeAlignment()

endBoxTimeAlignment() => start_session_hour_int >= end_session_hour_int and (hour + startTimeDelta) > 24? 1 : start_session_hour_int >= end_session_hour_int and (hour + startTimeDelta) <= 24? 0 : start_session_hour_int < end_session_hour_int and (hour + startTimeDelta) > 24? 0 : -1
isEndBoxTimeAlignment = endBoxTimeAlignment()


endTimeAlignment() => start_session_hour_int >= end_session_hour_int and (hour + startTimeDelta) > 24? 1 : start_session_hour_int >= end_session_hour_int and (hour + startTimeDelta) <= 24? 0 : start_session_hour_int < end_session_hour_int and isEndBoxTimeAlignment == 0? 1 : start_session_hour_int < end_session_hour_int and (hour + endTimeDelta) > 24? -1 : 0
// Change above to support end of session being on the same day as the start on EST
//endTimeAlignment() => (hour) >= (start_session_hour_int) and isStartTimeAlignment == 0? 0 : 1

isEndTimeAlignment = endTimeAlignment()

FromDate = timestamp(year, month, dayofmonth - isStartTimeAlignment, start_session_hour_int, start_session_minute_int)
ToDate = timestamp(year, month, dayofmonth + isEndBoxTimeAlignment, end_session_hour_int, end_session_minute_int) - chart_time_period_int

LineFromDate = timestamp(year, month, dayofmonth + isEndBoxTimeAlignment, end_session_hour_int, end_session_minute_int) - chart_time_period_int
LineToDate = timestamp(year, month, dayofmonth + isEndTimeAlignment, end_line_hour_int, end_line_minute_int)

// When a new period begins, reset hi/lo.
session_hi := ta.change(FromDate) != 0 ? srcHi : math.max(srcHi, session_hi)
session_lo := ta.change(FromDate) != 0 ? srcLo : math.min(srcLo, session_lo)

inSession = not na(time(timeframe.period, rth_ses))

rth_open_bar = open_bar(rth_ses)
rth_is_open = is_open(rth_ses)
rth_low = float(na)
rth_low := rth_is_open ? rth_open_bar ? low : math.min(rth_low[1], low) : rth_low[1]
rth_high = float(na)
rth_high := rth_is_open ? rth_open_bar ? high : math.max(rth_high[1], high) : rth_high[1]
rth_mid = (rth_low + rth_high) / 2

float sessionRange = na
var label sessionRangeLabel = na

// Build the Asian Box
trl = line.new(FromDate, rth_low, ToDate, rth_low, xloc=xloc.bar_time, color=line_color, style=box_line_style, width = boxLineWidth)
line.delete(trl[1])

trh = line.new(FromDate, rth_high, ToDate, rth_high, xloc=xloc.bar_time, color=line_color, style=box_line_style, width = boxLineWidth)
line.delete(trh[1])

trm = line.new(FromDate, rth_mid, ToDate, rth_mid, xloc=xloc.bar_time, color=midline_color, style=middle_line_style, width = sessionLineWidth)
line.delete(trm[1])

startBox = line.new(FromDate, rth_high, FromDate, rth_low, extend=extend.none, xloc=xloc.bar_time, color=line_color, style=box_line_style, width=boxLineWidth)
line.delete(startBox[1])

endBox = line.new(ToDate, rth_high, ToDate, rth_low, extend=extend.none, xloc=xloc.bar_time, color=line_color, style=box_line_style, width=boxLineWidth)
line.delete(endBox[1])
// End Section

//if not inSession and inSession[1]

//Apply the High / Low / Mid Session Lines for London / NY
tl = line.new(LineFromDate, rth_low, LineToDate, rth_low, xloc=xloc.bar_time, color=line_color, style=upperlower_line_style, width = sessionLineWidth)
line.delete(tl[1])

th = line.new(LineFromDate, rth_high, LineToDate, rth_high, xloc=xloc.bar_time, color=line_color, style=upperlower_line_style, width = sessionLineWidth)
line.delete(th[1])

tm = line.new(LineFromDate, rth_mid, LineToDate, rth_mid, xloc=xloc.bar_time, color=midline_color, style=middle_line_style, width = sessionLineWidth)
line.delete(tm[1])
// End Section


//Formula For Opening Range
highRes = rth_high
lowRes = rth_low

lineColor = color.new(color.white,100)
//timerange(res, sess) => not na(time(res, sess)) ? 1 : 0

//Plot Statements For Opening Range Lines
openRangeHigh = plot(timerange(timeframe.period, rth_fill_ses) and isBelowHourValidResolution() ? highRes : na, color=lineColor, style=plot.style_line, linewidth=1,  show_last=5, editable=false)
openRangeLow = plot(timerange(timeframe.period, rth_fill_ses) and isBelowHourValidResolution() ? lowRes : na, color=lineColor, style=plot.style_line, linewidth=1,  show_last=5, editable=false)
bgcolor(timerange(timeframe.period, rth_ses) and isBelowHourValidResolution() ? color.new(color.silver, 100) : na, title="Asian Session Background Color")


fill(openRangeHigh, openRangeLow, color=isBelowHourValidResolution() ? color.new(color.blue, 90) : na, title="Fill Asian Range Color")

if (not inSession and inSession[1] and isBelowHourValidResolution())
    sessionRange := ((rth_high[1]-rth_low[1])/(syminfo.mintick))/10
    labelTime = get_label_offset(inSession)

    label.delete(sessionRangeLabel)
    if ((timeframe.isintraday or timeframe.isdaily) and showADR and (timenow - time) < (one_day * daily_adr))
        sessionRangeLabel := label.new(labelTime, rth_low[1], "A = " + str.tostring(sessionRange) + "\nADR = " + str.tostring(to_pips(day_adr)), xloc.bar_time, yloc.price, color.new(color.black,100), label.style_label_up, text_color, labelsize)
    else
        sessionRangeLabel := label.new(labelTime, rth_low[1], "A = " + str.tostring(sessionRange), xloc.bar_time, yloc.price, color.new(color.black,100), label.style_label_up, text_color, labelsize)

// End Sesction

// Construct London Session Range
var london_hi = 10e-10
var london_lo = 10e10

londonStartTimeDelta = 24 - london_start_session_hour_int + 1
londonEndTimeDelta = 24 - london_end_session_hour_int + 1

startLondonTimeAlignment() => (hour + londonStartTimeDelta) > 24? 0 : 1
isLondonStartTimeAlignment = startLondonTimeAlignment()

// These function deal with the shift of the box from one day to the next
// At the moment they appear a little early. But wonder whether that is a 
// Nice feature to show the user that the session is about to start

endLondonTimeAlignment() => (hour) >= (london_start_session_hour_int) and isLondonStartTimeAlignment == 0? 0 : 1
// Cause issue with displaying - works better with the above statement
//endLondonTimeAlignment() => (hour) >= (london_start_session_hour_int) and (minute) >= (london_start_session_minute_int - chart_time_period_int) and isLondonStartTimeAlignment == 0? 0 : 1
isLondonEndTimeAlignment = endLondonTimeAlignment()

float london_range = na
var label londonRangeLabel = na

LondonFromDate = timestamp(year, month, dayofmonth - isLondonStartTimeAlignment, london_start_session_hour_int, london_start_session_minute_int)
LondonToDate = timestamp(year, month, dayofmonth - isLondonEndTimeAlignment, london_end_session_hour_int, london_end_session_minute_int) - chart_time_period_int


// When a new period begins, reset hi/lo.
london_hi := ta.change(LondonFromDate) != 0 ? srcHi : math.max(srcHi, london_hi)
london_lo := ta.change(LondonFromDate) != 0 ? srcLo : math.min(srcLo, london_lo)

inLondonSession = not na(time(timeframe.period, london_rth_ses))

london_rth_open_bar = open_bar(london_rth_ses)
london_rth_is_open = is_open(london_rth_ses)
london_rth_low = float(na)
london_rth_low := london_rth_is_open ? london_rth_open_bar ? low : math.min(london_rth_low[1], low) : london_rth_low[1]
london_rth_high = float(na)
london_rth_high := london_rth_is_open ? london_rth_open_bar ? high : math.max(london_rth_high[1], high) : london_rth_high[1]
london_rth_mid = (london_rth_low + london_rth_high) / 2

if (show_london_session and isValidResolution())
    
    //if inSession
    // Build the Asian Box
    ltrl = line.new(LondonFromDate, london_rth_low, LondonToDate, london_rth_low, xloc=xloc.bar_time, color=lline_color, style=lbox_line_style, width = lboxLineWidth)
    line.delete(ltrl[1])
    
    ltrh = line.new(LondonFromDate, london_rth_high, LondonToDate, london_rth_high, xloc=xloc.bar_time, color=lline_color, style=lbox_line_style, width = lboxLineWidth)
    line.delete(ltrh[1])
    
    ltrm = line.new(LondonFromDate, london_rth_mid, LondonToDate, london_rth_mid, xloc=xloc.bar_time, color=lmidline_color, style=lmiddle_line_style, width = lsessionLineWidth)
    line.delete(ltrm[1])
    
    londonStartBox = line.new(LondonFromDate, london_rth_high, LondonFromDate, london_rth_low, extend=extend.none, xloc=xloc.bar_time, color=lline_color, style=lbox_line_style, width=lboxLineWidth)
    line.delete(londonStartBox[1])
    
    londonEndBox = line.new(LondonToDate, london_rth_high, LondonToDate, london_rth_low, extend=extend.none, xloc=xloc.bar_time, color=lline_color, style=lbox_line_style, width=lboxLineWidth)
    line.delete(londonEndBox[1])
    // End Section
    
    //if not inSession and inSession[1]
    
    //Apply the High / Low / Mid Session Lines for London / NY
    //tl = line.new(LineFromDate, rth_low, LineToDate, rth_low, xloc=xloc.bar_time, color=line_color, style=upperlower_line_style, width = sessionLineWidth)
    //line.delete(tl[1])
    
    //th = line.new(LineFromDate, rth_high, LineToDate, rth_high, xloc=xloc.bar_time, color=line_color, style=upperlower_line_style, width = sessionLineWidth)
    //line.delete(th[1])
    
    //tm = line.new(LineFromDate, rth_mid, LineToDate, rth_mid, xloc=xloc.bar_time, color=midline_color, style=middle_line_style, width = sessionLineWidth)
    //line.delete(tm[1])
    // End Section
    
    // End Condition
    
//Formula For Opening Range
londonHighRes = london_rth_high
londonLowRes = london_rth_low

LondonLineColor = color.new(color.white,100)

//Plot Statements For Opening Range Lines
londonOpenRangeHigh = plot(timerange(timeframe.period, london_rth_fill_ses) and show_london_session and isBelowHourValidResolution() ? londonHighRes : na, color=LondonLineColor, style=plot.style_line, linewidth=1,  show_last=5, editable=false)
londonOpenRangeLow = plot(timerange(timeframe.period, london_rth_fill_ses) and show_london_session and isBelowHourValidResolution() ? londonLowRes : na, color=LondonLineColor, style=plot.style_line, linewidth=1,  show_last=5, editable=false)
bgcolor(timerange(timeframe.period, london_rth_fill_ses) and show_london_session and isBelowHourValidResolution() ? color.new(color.silver, 100) : na, title="London Session Background Color")
fill(londonOpenRangeHigh, londonOpenRangeLow, color=show_london_session and isBelowHourValidResolution() ? color.new(color.teal, 90) : na, title="Fill London Range Color")

if show_london_session_rng and not inLondonSession and inLondonSession[1] and isBelowHourValidResolution()
    london_range := ((london_rth_high[1]-london_rth_low[1])/(syminfo.mintick))/10
    londonLabelTime = get_label_offset(inLondonSession)

    label.delete(londonRangeLabel)
    londonRangeLabel := label.new(londonLabelTime, london_rth_low[1], "L = " + str.tostring(london_range), xloc.bar_time, yloc.price, color.new(color.black,100), label.style_label_up, ltext_color, llabelsize)

// End Sesction


// Construct New York Session Range
var ny_hi = 10e-10
var ny_lo = 10e10

nyStartTimeDelta = 24 - ny_start_session_hour_int + 1
nyEndTimeDelta = 24 - ny_end_session_hour_int + 1

startNyTimeAlignment() => (hour + nyStartTimeDelta) > 24? 0 : 1
isNyStartTimeAlignment = startNyTimeAlignment()


endNyTimeAlignment() => (hour) >= (ny_start_session_hour_int)  and isNyStartTimeAlignment == 0? 0 : 1
//endNyTimeAlignment() => (hour) >= (ny_start_session_hour_int) and (minute) >= (ny_start_session_minute_int - chart_time_period_int) and isNyStartTimeAlignment == 0? 0 : 1
isNyEndTimeAlignment = endNyTimeAlignment()


float ny_range = na
var label nyRangeLabel = na

NyFromDate = timestamp(year, month, dayofmonth - isNyStartTimeAlignment, ny_start_session_hour_int, ny_start_session_minute_int)
NyToDate = timestamp(year, month, dayofmonth - isNyEndTimeAlignment, ny_end_session_hour_int, ny_end_session_minute_int) - chart_time_period_int


// When a new period begins, reset hi/lo.
ny_hi := ta.change(NyFromDate) != 0 ? srcHi : math.max(srcHi, ny_hi)
ny_lo := ta.change(NyFromDate) != 0 ? srcLo : math.min(srcLo, ny_lo)

inNySession = not na(time(timeframe.period, ny_rth_ses))

ny_rth_open_bar = open_bar(ny_rth_ses)
ny_rth_is_open = is_open(ny_rth_ses)
ny_rth_low = float(na)
ny_rth_low := ny_rth_is_open ? ny_rth_open_bar ? low : math.min(ny_rth_low[1], low) : ny_rth_low[1]
ny_rth_high = float(na)
ny_rth_high := ny_rth_is_open ? ny_rth_open_bar ? high : math.max(ny_rth_high[1], high) : ny_rth_high[1]
ny_rth_mid = (ny_rth_low + ny_rth_high) / 2

if (show_ny_session and isValidResolution())
    
    //if inSession
    // Build the Asian Box
    ntrl = line.new(NyFromDate, ny_rth_low, NyToDate, ny_rth_low, xloc=xloc.bar_time, color=nline_color, style=nbox_line_style, width = nboxLineWidth)
    line.delete(ntrl[1])
    
    ntrh = line.new(NyFromDate, ny_rth_high, NyToDate, ny_rth_high, xloc=xloc.bar_time, color=nline_color, style=nbox_line_style, width = nboxLineWidth)
    line.delete(ntrh[1])
    
    ntrm = line.new(NyFromDate, ny_rth_mid, NyToDate, ny_rth_mid, xloc=xloc.bar_time, color=nmidline_color, style=nmiddle_line_style, width = nsessionLineWidth)
    line.delete(ntrm[1])
    
    nyStartBox = line.new(NyFromDate, ny_rth_high, NyFromDate, ny_rth_low, extend=extend.none, xloc=xloc.bar_time, color=nline_color, style=nbox_line_style, width=nboxLineWidth)
    line.delete(nyStartBox[1])
    
    nyEndBox = line.new(NyToDate, ny_rth_high, NyToDate, ny_rth_low, extend=extend.none, xloc=xloc.bar_time, color=nline_color, style=nbox_line_style, width=nboxLineWidth)
    line.delete(nyEndBox[1])
    // End Section
    
    //if not inSession and inSession[1]
    
    //Apply the High / Low / Mid Session Lines for London / NY
    //tl = line.new(LineFromDate, rth_low, LineToDate, rth_low, xloc=xloc.bar_time, color=line_color, style=upperlower_line_style, width = sessionLineWidth)
    //line.delete(tl[1])
    
    //th = line.new(LineFromDate, rth_high, LineToDate, rth_high, xloc=xloc.bar_time, color=line_color, style=upperlower_line_style, width = sessionLineWidth)
    //line.delete(th[1])
    
    //tm = line.new(LineFromDate, rth_mid, LineToDate, rth_mid, xloc=xloc.bar_time, color=midline_color, style=middle_line_style, width = sessionLineWidth)
    //line.delete(tm[1])
    // End Section
    
    // End Condition
    
//Formula For Opening Range
nyHighRes = ny_rth_high
nyLowRes = ny_rth_low

NyLineColor = color.new(color.white,100)

//Plot Statements For Opening Range Lines
nyOpenRangeHigh = plot(timerange(timeframe.period, ny_rth_fill_ses) and show_ny_session and isBelowHourValidResolution() ? nyHighRes : na, color=NyLineColor, style=plot.style_line, linewidth=1,  show_last=5, editable=false)
nyOpenRangeLow = plot(timerange(timeframe.period, ny_rth_fill_ses) and show_ny_session and isBelowHourValidResolution() ? nyLowRes : na, color=NyLineColor, style=plot.style_line, linewidth=1,  show_last=5, editable=false)
bgcolor(timerange(timeframe.period, ny_rth_fill_ses) and show_ny_session and isBelowHourValidResolution() ? color.new(color.silver, 100) : na, title="New York Session Background Color")
fill(nyOpenRangeHigh, nyOpenRangeLow, color=show_ny_session and isBelowHourValidResolution() ? color.new(color.silver, 90) : na, title="Fill New York Range Color")

if show_ny_session_rng and not inNySession and inNySession[1] and isBelowHourValidResolution()
    ny_range := ((ny_rth_high[1]-ny_rth_low[1])/(syminfo.mintick))/10
    nyLabelTime = get_label_offset(inNySession)

    label.delete(nyRangeLabel)
    nyRangeLabel := label.new(nyLabelTime, ny_rth_low[1], "N = " + str.tostring(ny_range), xloc.bar_time, yloc.price, color.new(color.black,100), label.style_label_up, ntext_color, nlabelsize)

// End Sesction



getData(r, s) => request.security(syminfo.tickerid, r, s, barmerge.gaps_off, barmerge.lookahead_on) 

pdh = getData('D', high[1])
pdl = getData('D', low[1])

wh = getData('1W', high[0])
wl = getData('1W', low[0])

lwh = getData('1W', high[1])
lwl = getData('1W', low[1])

float pdh_label_price = na
float pdl_label_price = na
int checkSwitch = 1

if (is_new_day_switch_period())
    pdh_label_price := getData('D', high[1])
    pdl_label_price := getData('D', low[1])
    checkSwitch := 0
else
    pdh_label_price := getData('D', high[0])
    pdl_label_price := getData('D', low[0])
    checkSwitch := 1
    


supportStartTimeDelta = 24 - start_session_hour_int + 1
supportEndTimeDelta = 24 - start_session_hour_int + 1

supportStartTimeAlignment() => (hour + supportStartTimeDelta) > 24? 0 : 1
isSupportStartTimeAlignment = supportStartTimeAlignment()

supportEndTimeAlignment() => (hour + supportEndTimeDelta) > 24? 1 : 0
isSupportEndTimeAlignment = supportEndTimeAlignment()



//SupportFromStartWeekDate = timestamp(startWeekYear, startWeekMonth, startWeekDayofMonth - isSupportStartTimeAlignment, start_support_hour_int, start_support_minute_int)
SupportFromStartWeekDate = timestamp(year, month, dayofmonth - isSupportStartTimeAlignment, start_support_hour_int, start_support_minute_int)
SupportFromDate = timestamp(year, month, dayofmonth - isSupportStartTimeAlignment, start_support_hour_int, start_support_minute_int)
SupportToDate = timestamp(year, month, dayofmonth + isSupportEndTimeAlignment, end_support_hour_int, end_support_minute_int) - chart_time_period_int

if (showPreviousDayHiLo and isBelowHourValidResolution())


    
    // Build the Previous support line Box
    yesterdayHighLine = line.new(SupportFromDate, pdh, SupportToDate, pdh, xloc=xloc.bar_time, extend=extend.none, color=support_line_color, style=support_line_style, width = supportLineWidth)
    line.delete(yesterdayHighLine[1])

    yesterdayLowLine = line.new(SupportFromDate, pdl, SupportToDate, pdl, xloc=xloc.bar_time, extend=extend.none, color=support_line_color, style=support_line_style, width = supportLineWidth)
    line.delete(yesterdayLowLine[1])


    pdCheckIsNewDay = is_new_day()
    // Show the label
    if (showHiLoPriceRange and pdCheckIsNewDay)

        if (showHiLoPriceLabel)
            // Add Previous Day High
            label pdHi_label = label.new(time - (time-time[1])*15, pdh_label_price, "YH (" + str.tostring(((pdh_label_price-pdl_label_price)/(syminfo.mintick))/10) + ")", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_line_label_color, nlabelsize)
            label.delete(pdHi_label[1])
    
            // Add Previous Day Low
            label pdLow_label = label.new(time - (time-time[1])*14, pdl_label_price, "YL", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_line_label_color, nlabelsize)
            label.delete(pdLow_label[1])
        else
            // Add Previous Day High
            label pdHi_label = label.new(time - (time-time[1])*15, pdh_label_price, str.tostring(((pdh_label_price-pdl_label_price)/(syminfo.mintick))/10), xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_line_label_color, nlabelsize)
            label.delete(pdHi_label[1])
    


    if (showHiLoPriceLabel and not showHiLoPriceRange and pdCheckIsNewDay)
    
        // Add Previous Day High
        label pdHi_label = label.new(time - (time-time[1])*14, pdh_label_price, "YH", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_line_label_color, nlabelsize)
        label.delete(pdHi_label[1])

        // Add Previous Day Low
        label pdLow_label = label.new(time - (time-time[1])*14, pdl_label_price, "YL", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_line_label_color, nlabelsize)
        label.delete(pdLow_label[1])
    
if (showWeeklyHiLo and isBelowHourValidResolution()) 

    // Build the week high lo support line Box
    weekHighLine = line.new(SupportFromStartWeekDate, wh, SupportToDate, wh, xloc=xloc.bar_time, extend=extend.none, color=support_week_line_color, style=support_line_style, width = supportLineWidth)
    line.delete(weekHighLine[1])

    weekLowLine = line.new(SupportFromStartWeekDate, wl, SupportToDate, wl, xloc=xloc.bar_time, extend=extend.none, color=support_week_line_color, style=support_line_style, width = supportLineWidth)
    line.delete(weekLowLine[1])

    // Show the label
    if (weeklyHiLoShowLabel and is_new_day())

        // Add Week High
        label wkHi_label = label.new(time - (time-time[1])*14, wh, "WH", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_week_line_color, nlabelsize)
        label.delete(wkHi_label[1])

        // Add Week Low
        label wkLow_label = label.new(time - (time-time[1])*14, wl, "WL", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_week_line_color, nlabelsize)
        label.delete(wkLow_label[1])

var label lwkLow_label = na

if (showLastWeeklyHiLo and isBelowHourValidResolution())

    // Build the week high lo support line Box
    weekLastHighLine = line.new(SupportFromStartWeekDate, lwh, SupportToDate, lwh, xloc=xloc.bar_time, extend=extend.none, color=support_last_week_line_color, style=support_last_week_line_style, width = supportLastWeekLineWidth)
    line.delete(weekLastHighLine[1])

    weekLastLowLine = line.new(SupportFromStartWeekDate, lwl, SupportToDate, lwl, xloc=xloc.bar_time, extend=extend.none, color=support_last_week_line_color, style=support_last_week_line_style, width = supportLastWeekLineWidth)
    line.delete(weekLastLowLine[1])

    // Show the label
    if (lastWeeklyHiLoShowLabel and is_new_day())

        // Add Week High
        label lwkHi_label = label.new(time - (time-time[1])*14, lwh, "PWH", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_last_week_line_label_color, nlabelsize)
        label.delete(lwkHi_label[1])

        // Add Week Low
        //label wkLow_label = label.new(x=bar_index[4], y=lwl, text="PWL", color=color.new(color.black,100), style=label.style_none, textcolor=support_last_week_line_label_color, size=nlabelsize)
        lwkLow_label := label.new(time - (time-time[1])*14, lwl, "PWL", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_last_week_line_label_color, nlabelsize)
        label.delete(lwkLow_label[1])

// Show Hi / Low of Day Time

    
//f_print(_txt) => var _lbl = label(na), label.delete(_lbl), _lbl := label.new(time + (time-time[1])*3, high, _txt, xloc.bar_time, yloc.price, size = size.large)

endOfDay = is_end_day()
//rsi = rsi(close, 7)
//hb = highestbars(rsi, 20)


var int highOfDayHour = na
var int highOfDayMinute = na
var int lowOfDayHour = na
var int lowOfDayMinute = na
var int hourIndexNullHour = na

lookbackLength = 95


hb = ta.highestbars(lookbackLength)
highBarIndex = -hb

highBarTime = time[highBarIndex]
highBarHour = hour[highBarIndex]
highBarMinute = minute[highBarIndex]


lb = ta.lowestbars(lookbackLength)
lowBarIndex = -lb

lowBarTime = time[lowBarIndex]
lowBarHour = hour[lowBarIndex]
lowBarMinute = minute[lowBarIndex]


if (showHiLoTime and isValidResolution() and endOfDay)
    
    highOfDayHour := highBarHour
    lowOfDayHour := lowBarHour

    label.new(bar_index[10], high[highBarIndex], "HOD: " + str.tostring(highOfDayHour) + ":" + str.tostring(highBarMinute), style=label.style_none, textcolor=color.silver)
    label.new(bar_index[10], low[lowBarIndex], "LOD: " + str.tostring(lowOfDayHour) + ":" + str.tostring(lowBarMinute), style=label.style_none, textcolor=color.silver)

hourIndexNullHour := ta.valuewhen(not na(highOfDayHour), highOfDayHour, 0)


// Check whether an alert needs to be fired

// Alert for whether prices has closed outside the range

inTradableSession = not na(time(timeframe.period, trd_ses))

isCloseBelow = false
isCloseAbove = false

//if (not inSession and inSession[1] and isBelowHourValidResolution())
if (inTradableSession and close[1] >= rth_low and close < rth_low)
    isCloseBelow := true
    
if (inTradableSession and close[1] <= rth_high and close > rth_high)
    isCloseAbove := true


alertcondition((isCloseBelow or isCloseAbove), title='Asian Range Break', message='Price has closed outside the Asian Session Range.')

// Debugger Section
//
f_print(_txt) => var label _lbl = na, label.delete(_lbl), _lbl := label.new(time + (time-time[1])*3, high, _txt, xloc.bar_time, yloc.price, size = size.large)
//
//if (not inSession and inSession[1])
//if (not inSession and (inLondonSession or inNySession))
//    f_print(str.tostring(rth_high) + "\n" + str.tostring(rth_low))
//if (isCloseBelow or isCloseAbove)
//    f_print("Break Occured=" + trd_ses)

//f_print("ny_rth_fill_ses = " + ny_rth_fill_ses + "\nlondon_rth_ses=" + london_rth_ses + "\nny_rth_ses=" + ny_rth_ses + "\nisLondonEndTimeAlignment=" + str.tostring(isLondonEndTimeAlignment) + "\nlondon_start_session_minute_int=" + str.tostring(london_start_session_minute_int)) 
//f_print("isEndTimeAlignment = " + str.tostring(isEndTimeAlignment) + " " + " isEndBoxTimeAlignment=" + str.tostring(isEndBoxTimeAlignment)) 
//f_print("from Date = " + str.tostring(dayofmonth - 1 - isSupportStartTimeAlignment) + "\npd_rth_low = " + str.tostring(pd_rth_low) + "\nstart_support_hour_int = " + str.tostring(start_support_hour_int) + "\nhigh_range = " + str.tostring(high_range) + "\nlow_range=" + str.tostring(low_range)) 
//f_print("rth_ses = " + (rth_ses) + "\nTimezone = " + syminfo.timezone + "\nisLondonEndTimeAlignment = " + str.tostring(isLondonEndTimeAlignment) + "\nlondon_end_session_hour_int = " + str.tostring(london_end_session_hour_int) + "\nisStartTimeAlignment = " + str.tostring(isStartTimeAlignment)) 
//f_print("Bars since=" + str.tostring(round(barssince(not inSession[2]))) + " sess=")

// =================================================================================================
// ICT Concepts [LuxAlgo]
// =================================================================================================
// indicator("ICT Concepts [LuxAlgo]", ...) // merged into bundle
//-----------------------------------------------------------------------------}
//Strings
//-----------------------------------------------------------------------------{
o          = 'Options'
sp1        = '       '
sp2        = '              '
hl         = 'High / Low    ' + sp1
ny_        = 'New York'       + sp1
lo_        = 'London Open'
lc_        = 'London Close'
as_        = 'Asian'      

//-----------------------------------------------------------------------------}
//Settings
//-----------------------------------------------------------------------------{
i_mode     = input.string(         'Present'      , title = 'Mode'                   , options =['Present', 'Historical']                                              )

//Market Structure Shift
showMS     = input.bool  (           true         , title = ''                       ,   group = 'Market Structures', inline = 'MS'                                    )
len        = input.int   (             5          , title = '     Length   ' +sp2    ,   group = 'Market Structures', inline = 'MS'       , minval = 3, maxval =  10   )

iMSS       = input.bool  (           true         , title = '       MSS'     +sp1    ,   group = 'Market Structures', inline = 'M1'                                    )
cMSSbl     = input.color (color.new(#00e6a1,  0), title = 'bullish'                ,   group = 'Market Structures', inline = 'M1'                                    )
cMSSbr     = input.color (color.new(#e60400,  0), title = 'bearish'                ,   group = 'Market Structures', inline = 'M1'                                    )

iBOS       = input.bool  (           true         , title = '       BOS'     +sp1    ,   group = 'Market Structures', inline = 'BS'                                    )
cBOSbl     = input.color (color.new(#00e6a1,  0), title = 'bullish'                ,   group = 'Market Structures', inline = 'BS'                                    )
cBOSbr     = input.color (color.new(#e60400,  0), title = 'bearish'                ,   group = 'Market Structures', inline = 'BS'                                    )

//Displacement
sDispl     = input.bool  (           false        , title = 'Show Displacement'      ,   group = 'Displacement'                                                        )

perc_Body  = 0.36 // input.int(   36, minval=1, maxval=36) / 100
bxBack     = 10   // input.int(   10, minval=0, maxval=10)

sVimbl     = input.bool  (           true         , title = ''                       ,   group = 'Volume Imbalance' , inline = 'VI'                                    )
visVim     = input.int   (             2          , title = "   # Visible VI's  "+sp1,   group = 'Volume Imbalance' , inline = 'VI'      , minval = 2, maxval = 100    ) 
cVimbl     = input.color (color.new(#06b2d0,  0), title = ''                       ,   group = 'Volume Imbalance' , inline = 'VI'                                    )

//Order Blocks  
showOB     = input.bool  (           true         , title = 'Show Order Blocks'      ,   group = 'Order Blocks'                                                        )
length     = input.int   (            10          , title = 'Swing Lookback'         ,   group = 'Order Blocks'                          , minval = 3                  )
showBull   = input.int   (             1          , title = 'Show Last Bullish OB'   ,   group = 'Order Blocks'                          , minval = 0                  )
showBear   = input.int   (             1          , title = 'Show Last Bearish OB'   ,   group = 'Order Blocks'                          , minval = 0                  )
useBody    = input.bool  (           true         , title = 'Use Candle Body'                                                                                          )

//OB Style
bullCss    = input.color (color.new(#3e89fa,  0), title = 'Bullish OB  '           ,   group = 'Order Blocks'     , inline = 'bullcss'                               )
bullBrkCss = input.color (color.new(#4785f9, 85), title = 'Bullish Break  '        ,   group = 'Order Blocks'     , inline = 'bullcss'                               )

bearCss    = input.color (color.new(#FF3131,  0), title = 'Bearish OB'             ,   group = 'Order Blocks'     , inline = 'bearcss'                               )
bearBrkCss = input.color (color.new(#f9ff57, 85), title = 'Bearish Break'          ,   group = 'Order Blocks'     , inline = 'bearcss'                               )

showLabels = input.bool  (          false, title = 'Show Historical Polarity Changes',   group = 'Order Blocks'                                                        )

//Liquidity   
showLq     = input.bool  (           true         , title = 'Show Liquidity'         ,   group = 'Liquidity'                                                           )
a     = 10 / input.float (             4          , title = 'margin'                 ,   group = 'Liquidity'   , step = 0.1, minval = 2, maxval =   7                  )
visLiq     = input.int   (             2          , title = '# Visible Liq. boxes'   ,   group = 'Liquidity'
           ,                                       minval = 1         , maxval = 50  , tooltip = 'In the same direction'                                               )
cLIQ_B     = input.color (color.new(#fa451c,  0), title = 'Buyside Liquidity  '    ,   group = 'Liquidity'                                                           )
cLIQ_S     = input.color (color.new(#1ce4fa,  0), title = 'Sellside Liquidity'     ,   group = 'Liquidity'                                                           )

//FVG      
shwFVG     = input.bool  (           true         , title = 'Show FVGs'              ,   group = 'Fair Value Gaps'                                                     )
i_BPR      = input.bool  (           false        , title = 'Balance Price Range'    ,   group = 'Fair Value Gaps'                                                     )
i_FVG      = input.string(           'FVG'        , title = o                        ,   group = 'Fair Value Gaps'  , options=['FVG', 'IFVG']                           
           ,                                                                           tooltip = 'Fair Value Gaps\nor\nImplied Fair Value Gaps'                        )
visBxs     = input.int   (             2          , title = '# Visible FVG\'s'       ,   group = 'Fair Value Gaps'
           ,                                       minval = 1         , maxval = 20  , tooltip = 'In the same direction'                                               )

//FVG Style
cFVGbl     = input.color (color.new(#00e676,  0), title = 'Bullish FVG  '          ,   group = 'Fair Value Gaps'  , inline = 'FVGbl'                                 )
cFVGblBR   = input.color (color.new(#808000,  0), title = 'Break'                  ,   group = 'Fair Value Gaps'  , inline = 'FVGbl'                                 )
cFVGbr     = input.color (color.new(#ff5252,  0), title = 'Bearish FVG '           ,   group = 'Fair Value Gaps'  , inline = 'FVGbr'                                 )
cFVGbrBR   = input.color (color.new(#FF0000,  0), title = 'Break'                  ,   group = 'Fair Value Gaps'  , inline = 'FVGbr'                                 )

//NWOG/NDOG 
iNWOG      = input.bool  (           true         , title = ''        , inline='NWOG',   group = 'NWOG/NDOG'                                                           )
cNWOG1     = input.color (color.new(#ff5252, 28), title = 'NWOG    ', inline='NWOG',   group = 'NWOG/NDOG'                                                           )
cNWOG2     = input.color (color.new(#b2b5be, 50), title = ''        , inline='NWOG',   group = 'NWOG/NDOG'                                                           )
maxNWOG    = input.int   (             3          , title = 'Show max', inline='NWOG',   group = 'NWOG/NDOG'                , minval = 0, maxval =  50                 )

iNDOG      = input.bool  (           false        , title = ''        , inline='NDOG',   group = 'NWOG/NDOG'                                                           )
cNDOG1     = input.color (color.new(#ff9800, 20), title = 'NDOG    ', inline='NDOG',   group = 'NWOG/NDOG'                                                           )
cNDOG2     = input.color (color.new(#4dd0e1, 65), title =    ''     , inline='NDOG',   group = 'NWOG/NDOG'                                                           )
maxNDOG    = input.int   (             1          , title = 'Show max', inline='NDOG',   group = 'NWOG/NDOG'                , minval = 0, maxval =  50                 )

//Fibonacci 
iFib       = input.string(           'NONE'      , title = 'Fibonacci between last: ',   group = 'Fibonacci', options=['FVG', 'BPR', 'OB', 'Liq', 'VI', 'NWOG', 'NONE'])
iExt       = input.bool  (           false       , title = 'Extend lines'            ,   group = 'Fibonacci'                                                           )

//Killzones 
showKZ     = input.bool  (           false        , title = 'Show Killzones'         ,   group = 'Killzones'                                                           )
//New York
showNy     = input.bool  (           true         , title = ny_      , inline = 'ny' ,   group = 'Killzones'                                                           ) and showKZ
nyCss      = input.color (color.new(#ff5d00, 93), title = ''       , inline = 'ny' ,   group = 'Killzones'                                                           )
//London Open
showLdno   = input.bool  (           true         , title = lo_      , inline = 'lo' ,   group = 'Killzones'                                                           ) and showKZ
ldnoCss    = input.color (color.new(#00bcd4, 93), title = ''       , inline = 'lo' ,   group = 'Killzones'                                                           )
//London Close
showLdnc   = input.bool  (           true         , title = lc_      , inline = 'lc' ,   group = 'Killzones'                                                           ) and showKZ
ldncCss    = input.color (color.new(#2157f3, 93), title = ''       , inline = 'lc' ,   group = 'Killzones'                                                           )
//Asian
showAsia   = input.bool  (           true         , title = as_ + sp2, inline = 'as' ,   group = 'Killzones'                                                           ) and showKZ
asiaCss    = input.color (color.new(#e91e63, 93), title = ''       , inline = 'as' ,   group = 'Killzones'                                                           )

//-----------------------------------------------------------------------------}
//General Calculations
//-----------------------------------------------------------------------------{
n          =                      bar_index
hi         =                      high  
lo         =                      low   
tf_msec    = timeframe.in_seconds(timeframe.period) * 1000
maxSize    =        50
atr        = ta.atr(10)
per        = i_mode == 'Present' ? last_bar_index - bar_index <=  500 : true
perB       = last_bar_index - bar_index <= 1000  ? true : false
xloc       = iFib   ==   'OB'    ? xloc.bar_time : xloc.bar_index
ext        = iExt                ?  extend.right : extend.none
plus       = iFib   ==   'OB'    ?  tf_msec * 50 : 50
mx         = math.max(close , open)
mn         = math.min(close , open)
body       = math.abs(close - open)
meanBody   = ta.sma  (body  ,  len)
max        = useBody ?  mx  : high
min        = useBody ?  mn  : low
blBrkConf  = 0
brBrkConf  = 0
r          = color.r(chart.bg_color)
g          = color.g(chart.bg_color)
b          = color.b(chart.bg_color)
isDark     = r < 80 and g < 80 and b < 80

//-----------------------------------------------------------------------------}
//User Defined Types
//-----------------------------------------------------------------------------{
type ZZ 
    int   [] d
    int   [] x 
    float [] y 
    bool  [] b

type ln_d
    line  l
    int   d

type _2ln_lb
    line  l1
    line  l2
    label lb

type bx_ln
    box   b 
    line  l 

type bx_ln_lb
    box   bx
    line  ln
    label lb 

type mss 
    int     dir
    line [] l_mssBl
    line [] l_mssBr
    line [] l_bosBl
    line [] l_bosBr
    label[] lbMssBl
    label[] lbMssBr
    label[] lbBosBl
    label[] lbBosBr

type liq
    box   bx
    bool  broken
    bool  brokenTop
    bool  brokenBtm
    line  ln

type ob
    float   top       = na
    float   btm       = na
    int     loc       = bar_index
    bool    breaker   = false
    int     break_loc = na

type swing
    float y = na
    int   x = na
    bool  crossed = false

type FVG 
    box box 
    bool active
    int  pos 

var mss MSS = mss.new(
 0
 , array.new < line  >()
 , array.new < line  >() 
 , array.new < line  >()
 , array.new < line  >()
 , array.new < label >() 
 , array.new < label >()
 , array.new < label >()
 , array.new < label >()
 )

//-----------------------------------------------------------------------------}
//Variables
//-----------------------------------------------------------------------------{
maxVimb = 2

var float friCp = na, var int friCi = na // Friday Close price/index
var float monOp = na, var int monOi = na // Monday Open  price/index

var float prDCp = na, var int prDCi = na // Previous Day Open price/index
var float cuDOp = na, var int cuDOi = na // Current  Day Open price/index

var _2ln_lb [] Vimbal     = array.new<  _2ln_lb >() 

var   liq   [] b_liq_B    = array.new<    liq   >(1, liq.new(na, false, false, false, na))
var   liq   [] b_liq_S    = array.new<    liq   >(1, liq.new(na, false, false, false, na))

var    ob   [] bullish_ob = array.new<    ob    >()
var    ob   [] bearish_ob = array.new<    ob    >()

var bx_ln   [] bl_NWOG    = array.new<   bx_ln  >()
var bx_ln   [] bl_NDOG    = array.new<   bx_ln  >()

var bx_ln_lb[] a_bx_ln_lb = array.new< bx_ln_lb >()

var FVG     [] bFVG_UP    = array.new<    FVG   >()
var FVG     [] bFVG_DN    = array.new<    FVG   >()

var FVG     [] bBPR_UP    = array.new<    FVG   >()
var FVG     [] bBPR_DN    = array.new<    FVG   >()

var  ZZ         aZZ       =
 ZZ.new(
 array.new < int    >(maxSize,  0),
 array.new < int    >(maxSize,  0),
 array.new < float  >(maxSize, na),
 array.new < bool   >(maxSize, false))

var line _diag = line.new(na, na, na, na, color=color.new(color.silver, 50), style=line.style_dashed, xloc= xloc            )
var line _vert = line.new(na, na, na, na, color=color.new(color.silver, 50), style=line.style_dotted, xloc= xloc            )
var line _zero = line.new(na, na, na, na, color=color.new(color.silver,  5), style=line.style_solid , xloc= xloc, extend=ext)
var line _0236 = line.new(na, na, na, na, color=color.new(color.orange, 25), style=line.style_solid , xloc= xloc, extend=ext)
var line _0382 = line.new(na, na, na, na, color=color.new(color.yellow, 25), style=line.style_solid , xloc= xloc, extend=ext)
var line _0500 = line.new(na, na, na, na, color=color.new(color.green , 25), style=line.style_solid , xloc= xloc, extend=ext)
var line _0618 = line.new(na, na, na, na, color=color.new(color.yellow, 25), style=line.style_solid , xloc= xloc, extend=ext)
var line _0786 = line.new(na, na, na, na, color=color.new(color.orange, 25), style=line.style_solid , xloc= xloc, extend=ext)
var line _one_ = line.new(na, na, na, na, color=color.new(color.silver,  5), style=line.style_solid , xloc= xloc, extend=ext)
var line _1618 = line.new(na, na, na, na, color=color.new(color.yellow, 25), style=line.style_solid , xloc= xloc, extend=ext)
 
//-----------------------------------------------------------------------------}
//Functions/methods
//-----------------------------------------------------------------------------{
method in_out(ZZ aZZ, int d, int x1, float y1, int x2, float y2, color col, bool b) =>
    aZZ.d.unshift(d), aZZ.x.unshift(x2), aZZ.y.unshift(y2), aZZ.b.unshift(b), aZZ.d.pop(), aZZ.x.pop(), aZZ.y.pop(), aZZ.b.pop()

method timeinrange(string res, string sess) => not na(time(timeframe.period, res, sess))

method setLine(line ln, int x1, float y1, int x2, float y2) => ln.set_xy1(x1, y1), ln.set_xy2(x2, y2)

method clear_aLine(line[] l) =>
    if l.size() > 0
        for i = l.size() -1 to 0
            l.pop().delete()

method clear_aLabLin(label[] l) =>
    if l.size() > 0
        for i = l.size() -1 to 0
            l.pop().delete()

method clear_aLabLin(line[] l) =>
    if l.size() > 0
        for i = l.size() -1 to 0
            l.pop().delete()

method notransp(color css) => color.rgb(color.r(css), color.g(css), color.b(css))

method display(ob id, css, break_css, str)=>
    if showOB
        if id.breaker
            a_bx_ln_lb.unshift(
             bx_ln_lb.new(
               box.new(id.loc, id.top, timenow + (tf_msec * 10), id.btm, na
             , bgcolor = break_css
             , extend  = extend.none
             , xloc    = xloc.bar_time)
             , na
             , na)
             )
        else
            y  = str == 'bl' ? id.btm : id.top
            s  = str == 'bl' ? label.style_label_up : label.style_label_down
            a_bx_ln_lb.unshift(
             bx_ln_lb.new(
               na
             , line.new(id.loc,   y  , id.loc  + (tf_msec * 10),    y
             , xloc    = xloc.bar_time, color=css, width=2)
             , label.new(              id.loc  + (tf_msec * 10),    y
             , text  = str == 'bl' ? '+OB' : '-OB'
             , xloc  = xloc.bar_time
             , style = s    , color = na
             , textcolor=css, size  = size.small))
             )

swings(len)=>
    var os = 0
    var swing top = swing.new(na, na)
    var swing btm = swing.new(na, na)
    
    upper = ta.highest(len)
    lower = ta.lowest(len)

    os := high[len] > upper ? 0 
       :  low [len] < lower ? 1 : os

    if os == 0 and os[1] != 0
        top := swing.new(high[length], bar_index[length])
    
    if os == 1 and os[1] != 1
        btm := swing.new(low[length], bar_index[length])

    [top, btm]
            
set_lab(i, str) =>
    style = str == 'Bl' ? label.style_label_down : label.style_label_up
    txcol = str == 'Bl' ? color.lime : color.red
    label.new(math.round((aZZ.x.get(i) + n) / 2), aZZ.y.get(i), text='BOS'
     , style=style, color=na, textcolor=txcol, size=size.tiny)
set_lin(i, str) =>
    color = str == 'Bl' ? color.lime : color.red
    line.new(aZZ.x.get(i), aZZ.y.get(i), n, aZZ.y.get(i), color=color, style=line.style_dotted)

draw(left, col) =>
    //
    max_bars_back(time, 1000)
    var int dir= na, var int x1= na, var float y1= na, var int x2= na, var float y2= na
    //
    sz       = aZZ.d.size( )
    x2      := bar_index -1
    ph       = ta.pivothigh(hi, left, 1)
    pl       = ta.pivotlow (lo, left, 1)
    if not na(ph)
        dir := aZZ.d.get (0) 
        x1  := aZZ.x.get (0) 
        y1  := aZZ.y.get (0) 
        y2  :=      nz(hi[1])
        //
        if dir <  1  // if previous point was a pl, add, and change direction ( 1)
            aZZ.in_out( 1, x1, y1, x2, y2, col, true)
        else
            if dir ==  1 and ph > y1 
                aZZ.x.set(0, x2), aZZ.y.set(0, y2)
        //
        // liquidity
        if showLq and per and sz > 0
            count = 0
            st_P  = 0.
            st_B  = 0
            minP  = 0.
            maxP  = 10e6
            for i = 0 to math.min(sz, 50) -1
                if aZZ.d.get(i) ==  1 
                    if aZZ.y.get(i) > ph + (atr/a)
                        break
                    else
                        if aZZ.y.get(i) > ph - (atr/a) and aZZ.y.get(i) < ph + (atr/a)
                            count += 1
                            st_B := aZZ.x.get(i)
                            st_P := aZZ.y.get(i)
                            if aZZ.y.get(i) > minP
                                minP := aZZ.y.get(i)
                            if aZZ.y.get(i) < maxP 
                                maxP := aZZ.y.get(i)
            if count > 2
                getB = b_liq_B.get(0)
                liqMid = (minP + maxP) / 2
                liqTop = liqMid + (atr / a)
                liqBottom = liqMid - (atr / a)
                if st_B == getB.bx.get_left()
                    getB.bx.set_top(liqTop)
                    getB.bx.set_rightbottom(n + 10, liqBottom)
                else
                    newLiqBBox = box.new(st_B, liqTop, n + 10, liqBottom)
                    box.set_border_color(newLiqBBox, color.new(cLIQ_B, 0))
                    box.set_bgcolor(newLiqBBox, na)
                    box.set_text(newLiqBBox, 'Buyside liquidity')
                    box.set_text_size(newLiqBBox, size.tiny)
                    box.set_text_halign(newLiqBBox, text.align_left)
                    box.set_text_valign(newLiqBBox, text.align_bottom)
                    box.set_text_color(newLiqBBox, color.new(cLIQ_B, 25))
                    newLiqBLine = line.new(st_B, st_P, n - 1, st_P, color = color.new(cLIQ_B, 0))
                    newLiqB = liq.new(newLiqBBox, false, false, false, newLiqBLine)
                    b_liq_B.unshift(newLiqB)
                if b_liq_B.size() > visLiq
                    getLast = b_liq_B.pop()
                    getLast.bx.delete()
                    getLast.ln.delete()               
    //
    if not na(pl)
        dir := aZZ.d.get (0) 
        x1  := aZZ.x.get (0) 
        y1  := aZZ.y.get (0) 
        y2  :=      nz(lo[1])
        //
        if dir > -1  // if previous point was a ph, add, and change direction (-1)
            aZZ.in_out(-1, x1, y1, x2, y2, col, true)
        else
            if dir == -1 and pl < y1 
                aZZ.x.set(0, x2), aZZ.y.set(0, y2)
        //
        //Liquidity
        if showLq and per and sz > 0
            count = 0
            st_P  = 0.
            st_B  = 0
            minP  = 0.
            maxP  = 10e6
            for i = 0 to math.min(sz, 50) -1
                if aZZ.d.get(i) == -1 
                    if aZZ.y.get(i) < pl - (atr/a)
                        break
                    else
                        if aZZ.y.get(i) > pl - (atr/a) and aZZ.y.get(i) < pl + (atr/a)
                            count += 1
                            st_B := aZZ.x.get(i)
                            st_P := aZZ.y.get(i)
                            if aZZ.y.get(i) > minP
                                minP := aZZ.y.get(i)
                            if aZZ.y.get(i) < maxP 
                                maxP := aZZ.y.get(i)
            if count > 2
                getB = b_liq_S.get(0)
                liqMid = (minP + maxP) / 2
                liqTop = liqMid + (atr / a)
                liqBottom = liqMid - (atr / a)
                if st_B == getB.bx.get_left()
                    getB.bx.set_top(liqTop)
                    getB.bx.set_rightbottom(n + 10, liqBottom)
                else
                    newLiqSBox = box.new(st_B, liqTop, n + 10, liqBottom)
                    box.set_border_color(newLiqSBox, color.new(cLIQ_S, 0))
                    box.set_bgcolor(newLiqSBox, na)
                    box.set_text(newLiqSBox, 'Sellside liquidity')
                    box.set_text_size(newLiqSBox, size.tiny)
                    box.set_text_halign(newLiqSBox, text.align_left)
                    box.set_text_valign(newLiqSBox, text.align_bottom)
                    box.set_text_color(newLiqSBox, color.new(cLIQ_S, 25))
                    newLiqSLine = line.new(st_B, st_P, n - 1, st_P, color = color.new(cLIQ_S, 0))
                    newLiqS = liq.new(newLiqSBox, false, false, false, newLiqSLine)
                    b_liq_S.unshift(newLiqS)
                if b_liq_S.size() > visLiq
                    getLast = b_liq_S.pop()
                    getLast.bx.delete()
                    getLast.ln.delete()            
    //
    //Market Structure Shift 
    if showMS 
        //
        iH = aZZ.d.get(2) ==  1 ? 2 : 1
        iL = aZZ.d.get(2) == -1 ? 2 : 1
        //
        switch
            // MSS Bullish
            close > aZZ.y.get(iH) and aZZ.d.get(iH) ==  1 and MSS.dir <  1 =>
                MSS.dir :=  1 
                if i_mode == 'Present'
                    MSS.l_bosBl.clear_aLabLin(), MSS.l_bosBr.clear_aLabLin()   
                    MSS.lbBosBl.clear_aLabLin(), MSS.lbBosBr.clear_aLabLin()  
                    MSS.l_mssBl.clear_aLabLin(), MSS.l_mssBr.clear_aLabLin() 
                    MSS.lbMssBl.clear_aLabLin(), MSS.lbMssBr.clear_aLabLin() 
                //      
                MSS.l_mssBl.unshift(line.new (
                  aZZ.x.get(iH), aZZ.y.get(iH), n, aZZ.y.get(iH), color=cMSSbl))
                MSS.lbMssBl.unshift(label.new(
                  math.round((aZZ.x.get(iH) + n) / 2), aZZ.y.get(iH), text ='MSS'
                 , style=label.style_label_down, size=size.tiny, color=na, textcolor=cMSSbl))
            // MSS Bearish
            close < aZZ.y.get(iL) and aZZ.d.get(iL) == -1 and MSS.dir > -1 =>
                MSS.dir := -1 
                if i_mode == 'Present'
                    MSS.l_bosBl.clear_aLabLin(), MSS.l_bosBr.clear_aLabLin()   
                    MSS.lbBosBl.clear_aLabLin(), MSS.lbBosBr.clear_aLabLin()  
                    MSS.l_mssBl.clear_aLabLin(), MSS.l_mssBr.clear_aLabLin() 
                    MSS.lbMssBl.clear_aLabLin(), MSS.lbMssBr.clear_aLabLin()
                // 
                MSS.l_mssBr.unshift(line.new (
                  aZZ.x.get(iL), aZZ.y.get(iL), n, aZZ.y.get(iL), color=cMSSbr))
                MSS.lbMssBr.unshift(label.new(
                  math.round((aZZ.x.get(iL) + n) / 2), aZZ.y.get(iL), text ='MSS'
                 , style=label.style_label_up  , size=size.tiny, color=na, textcolor=cMSSbr))
            // BOS Bullish
            MSS.dir ==  1 and close > aZZ.y.get(iH) and iBOS =>
                if MSS.l_bosBl.size() > 0
                    if aZZ.y.get(iH) != MSS.l_bosBl.get(0).get_y2() and
                       aZZ.y.get(iH) != MSS.l_mssBl.get(0).get_y2()
                        MSS.l_bosBl.unshift(set_lin(iH, 'Bl')), MSS.lbBosBl.unshift(set_lab(iH, 'Bl'))
                else  
                    if aZZ.y.get(iH) != MSS.l_mssBl.get(0).get_y2()                     
                        MSS.l_bosBl.unshift(set_lin(iH, 'Bl')), MSS.lbBosBl.unshift(set_lab(iH, 'Bl'))
            // BOS Bearish
            MSS.dir == -1 and close < aZZ.y.get(iL) and iBOS =>
                if MSS.l_bosBr.size() > 0
                    if aZZ.y.get(iL) != MSS.l_bosBr.get(0).get_y2() and
                       aZZ.y.get(iL) != MSS.l_mssBr.get(0).get_y2()
                        MSS.l_bosBr.unshift(set_lin(iL, 'Br')), MSS.lbBosBr.unshift(set_lab(iL, 'Br'))
                else
                    if aZZ.y.get(iL) != MSS.l_mssBr.get(0).get_y2()                     
                        MSS.l_bosBr.unshift(set_lin(iL, 'Br')), MSS.lbBosBr.unshift(set_lab(iL, 'Br'))
        if not iMSS
            MSS.l_mssBl.get(0).set_color(na), MSS.lbMssBl.get(0).set_textcolor(na)
            MSS.l_mssBr.get(0).set_color(na), MSS.lbMssBr.get(0).set_textcolor(na)



//-----------------------------------------------------------------------------}
//Calculations
//-----------------------------------------------------------------------------{
draw(len, color.yellow)             

if MSS.l_bosBl.size() > 200
    MSS.l_bosBl.pop().delete()
    MSS.lbBosBl.pop().delete()

if MSS.l_bosBr.size() > 200
    MSS.l_bosBr.pop().delete()
    MSS.lbBosBr.pop().delete()

//Killzones 
ny          = not na(time(timeframe.period, input.session('0700-0900', '', inline = 'ny', group = 'Killzones'), 'America/New_York')) and showNy
ldn_open    = not na(time(timeframe.period, input.session('0700-1000', '', inline = 'lo', group = 'Killzones'), 'Europe/London'   )) and showLdno // 0200-0500 UTC-5
ldn_close   = not na(time(timeframe.period, input.session('1500-1700', '', inline = 'lc', group = 'Killzones'), 'Europe/London'   )) and showLdnc // 1000-1200 UTC-5
asian       = not na(time(timeframe.period, input.session('1000-1400', '', inline = 'as', group = 'Killzones'), 'Asia/Tokyo'      )) and showAsia // 2000-0000 UTC-5

//Pivotpoints 
ph          = ta.pivothigh(3, 1), lPh = fixnan(ph)
pl          = ta.pivotlow (3, 1), lPl = fixnan(pl)

//Candles 
L_body      = 
 high - mx  < body * perc_Body and 
 mn - low   < body * perc_Body

L_bodyUP    =   body > meanBody  and L_body and close > open
L_bodyDN    =   body > meanBody  and L_body and close < open

bsNOTbodyUP = ta.barssince(not L_bodyUP)
bsNOTbodyDN = ta.barssince(not L_bodyDN)

bsIs_bodyUP = ta.barssince(    L_bodyUP)
bsIs_bodyDN = ta.barssince(    L_bodyDN)

lwst        = math.min(lPh [bsNOTbodyUP[1]], low[bsNOTbodyUP[1]])
hgst        = math.max(high[bsNOTbodyDN[1]], lPl[bsNOTbodyDN[1]])

//Imbalance
imbalanceUP = L_bodyUP[1] and (i_FVG == 'FVG' ? low  > high[2] : low  < high[2])
imbalanceDN = L_bodyDN[1] and (i_FVG == 'FVG' ? high < low [2] : high > low [2])

//Volume Imbalance
vImb_Bl     = open > close[1] and high[1] > low  and close > close[1] and open > open[1] and high[1] < mn
vImb_Br     = open < close[1] and low [1] < high and close < close[1] and open < open[1] and low [1] > mx

if sVimbl
    if vImb_Bl
        Vimbal.unshift(
         _2ln_lb.new(
          line.new (n -1, mx[1], n +3, mx[1], color=cVimbl)
         , line.new (n   , mn   , n +3, mn   , color=cVimbl)
          , label.new(n +3, (mx[1] + mn) / 2, text='VI'
         , color=na , textcolor=cVimbl, style=label.style_label_left)
          )
         )
    if vImb_Br
        Vimbal.unshift(
         _2ln_lb.new(
          line.new (n -1, mn[1], n +3, mn[1], color=cVimbl)
         , line.new (n   , mx   , n +3, mx   , color=cVimbl)
          , label.new(n +3, (mn[1] + mx) / 2, text='VI'
         , color=na , textcolor=cVimbl, style=label.style_label_left)
          )
         )
    if Vimbal.size() > visVim 
        pop = Vimbal.pop()
        pop.l1.delete()
        pop.l2.delete()
        pop.lb.delete()

//Fair Value Gap  
if barstate.isfirst
    for i = 0 to visBxs -1
        bFVG_UP.unshift(FVG.new(na, false))
        bFVG_DN.unshift(FVG.new(na, false))
        if i_BPR
            bBPR_UP.unshift(FVG.new(na, false))
            bBPR_DN.unshift(FVG.new(na, false))

if imbalanceUP and per and shwFVG 
    if imbalanceUP[1]
        bFVG_UP.get(0).box.set_lefttop    (n -2, low    )
        bFVG_UP.get(0).box.set_rightbottom(n +8, high[2])
    else
        bFVG_UP.unshift(FVG.new(
          box.new(
           n -2
         ,    i_FVG == 'FVG' ? low : high[2]
         , n, i_FVG == 'FVG' ? high[2] : low
         , bgcolor     = i_BPR ? na : color.new(cFVGbl, 90)
         , border_color= i_BPR ? na : color.new(cFVGbl, 65)
         , text_color  = i_BPR ? na : color.new(cFVGbl, 65)
         , text_size=size.small
         , text=i_FVG
         )
         , true)
         )
        bFVG_UP.pop().box.delete()

if imbalanceDN and per and shwFVG 
    if imbalanceDN[1]
        bFVG_DN.get(0).box.set_lefttop    (n -2, low[2])
        bFVG_DN.get(0).box.set_rightbottom(n +8, high  )
    else
        bFVG_DN.unshift(FVG.new(
         box.new(
           n -2
         ,    i_FVG == 'FVG' ? low[2] : high
         , n, i_FVG == 'FVG' ? high   : low[2]
         , bgcolor     = i_BPR ? na : color.new(cFVGbr, 90)
         , border_color= i_BPR ? na : color.new(cFVGbr, 65)
         , text_color  = i_BPR ? na : color.new(cFVGbr, 65)
         , text_size=size.small
         , text=i_FVG
         )
         , true)
         )
        bFVG_DN.pop().box.delete()

//Balance Price Range (overlap of 2 latest FVG bull/bear)
if i_BPR and bFVG_UP.size() > 0 and bFVG_DN.size() > 0
    bxUP    = bFVG_UP.get(0)
    bxDN    = bFVG_DN.get(0)
    bxUPbtm = bxUP.box.get_bottom()
    bxDNbtm = bxDN.box.get_bottom()
    bxUPtop = bxUP.box.get_top()
    bxDNtop = bxDN.box.get_top()
    left    = math.min(bxUP.box.get_left (), bxDN.box.get_left ())
    right   = math.max(bxUP.box.get_right(), bxDN.box.get_right())
    //
    if bxUPbtm < bxDNtop and 
       bxDNbtm < bxUPbtm
        if left == bBPR_UP.get(0).box.get_left() 
            if  bBPR_UP.get(0).active
                bBPR_UP.get(0).box.set_right(right)
        else
            bBPR_UP.unshift(FVG.new(
             box.new(
              left, bxDNtop, right, bxUPbtm
             , bgcolor     = i_BPR ? color.new(cFVGbl, 90) : na
             , border_color= i_BPR ? color.new(cFVGbl, 65) : na
             , text_color  = i_BPR ? color.new(cFVGbl, 65) : na
              , text_size=size.small
              , text= 'BPR'
              ) 
              , true
              , close > bxUPbtm ? 1 : close < bxDNtop ? -1 : 0
              )
             )
            bBPR_UP.pop().box.delete()
    //
    if bxDNbtm < bxUPtop and 
       bxUPbtm < bxDNbtm 
        if left == bBPR_DN.get(0).box.get_left() 
            if  bBPR_DN.get(0).active
                bBPR_DN.get(0).box.set_right(right)
        else
            bBPR_DN.unshift(FVG.new(
             box.new(
              left, bxUPtop, right, bxDNbtm
             , bgcolor     = i_BPR ? color.new(cFVGbr, 90) : na
             , border_color= i_BPR ? color.new(cFVGbr, 65) : na
             , text_color  = i_BPR ? color.new(cFVGbr, 65) : na
              , text_size=size.small
              , text= 'BPR'
              ) 
              , true
              , close > bxDNbtm ? 1 : close < bxUPtop ? -1 : 0
              )
             )
            bBPR_DN.pop().box.delete()

//FVG's breaks
for i = 0 to math.min(bxBack, bFVG_UP.size() -1)
    getUPi = bFVG_UP.get(i)
    if getUPi.active
        getUPi.box.set_right(bar_index +8)
        if low  < getUPi.box.get_top() and not i_BPR
            getUPi.box.set_border_style(line.style_dashed)
        if low  < getUPi.box.get_bottom()
            if not i_BPR
                getUPi.box.set_bgcolor(color.new(cFVGblBR, 95))
                getUPi.box.set_border_style(line.style_dotted)
            getUPi.box.set_right(bar_index)
            getUPi.active := false

for i = 0 to math.min(bxBack, bFVG_DN.size() -1)
    getDNi = bFVG_DN.get(i)
    if getDNi.active
        getDNi.box.set_right(bar_index +8)
        if high > getDNi.box.get_bottom() and not i_BPR
            getDNi.box.set_border_style(line.style_dashed)
        if high > getDNi.box.get_top()
            if not i_BPR
                getDNi.box.set_bgcolor(color.new(cFVGbrBR, 95))
                getDNi.box.set_border_style(line.style_dotted)
            getDNi.box.set_right(bar_index)
            getDNi.active := false

if i_BPR
    for i = 0 to math.min(bxBack, bBPR_UP.size() -1)
        getUPi = bBPR_UP.get(i)
        if getUPi.active
            getUPi.box.set_right(bar_index +8)
            switch getUPi.pos 
                -1 =>
                    if high > getUPi.box.get_bottom()
                        getUPi.box.set_border_style(line.style_dashed)
                    if high > getUPi.box.get_top   ()
                        getUPi.box.set_bgcolor(color.new(cFVGblBR, 95))
                        getUPi.box.set_border_style(line.style_dotted)
                        getUPi.box.set_right(bar_index)
                        getUPi.active := false
                1 =>
                    if low  < getUPi.box.get_top   ()
                        getUPi.box.set_border_style(line.style_dashed)
                    if low  < getUPi.box.get_bottom()
                        getUPi.box.set_bgcolor(color.new(cFVGblBR, 95))
                        getUPi.box.set_border_style(line.style_dotted)
                        getUPi.box.set_right(bar_index)
                        getUPi.active := false
    
    for i = 0 to math.min(bxBack, bBPR_DN.size() -1)
        getDNi = bBPR_DN.get(i)
        if getDNi.active
            getDNi.box.set_right(bar_index +8)
            switch getDNi.pos 
                -1 =>
                    if high > getDNi.box.get_bottom()
                        getDNi.box.set_border_style(line.style_dashed)
                    if high > getDNi.box.get_top   ()
                        getDNi.box.set_bgcolor(color.new(cFVGbrBR, 95))
                        getDNi.box.set_border_style(line.style_dotted)
                        getDNi.box.set_right(bar_index)
                        getDNi.active := false
                1 =>
                    if low  < getDNi.box.get_top   ()
                        getDNi.box.set_border_style(line.style_dashed)
                    if low  < getDNi.box.get_bottom()
                        getDNi.box.set_bgcolor(color.new(cFVGbrBR, 95))
                        getDNi.box.set_border_style(line.style_dotted)
                        getDNi.box.set_right(bar_index)
                        getDNi.active := false

//NWOG/NDOG 
if barstate.isfirst 
    for i = 0 to maxNWOG -1
        bl_NWOG.unshift(bx_ln.new(na, na))
    for i = 0 to maxNDOG -1
        bl_NDOG.unshift(bx_ln.new(na, na))

if dayofweek == dayofweek.friday
    friCp := close, friCi := n

if ta.change(dayofweek) != 0
    if  dayofweek == dayofweek.monday and iNWOG
        monOp := open , monOi := n
        bl_NWOG.unshift(bx_ln.new(   
         box.new(
           friCi        ,   math.max (friCp  , monOp  )
         , monOi        ,   math.min (friCp  , monOp  )
         , bgcolor      =   color    ( na             )
         , border_color =             cNWOG2
         , extend       =             extend.right    )
         ,
         line.new(
           monOi        ,   (friCp + monOp) / 2
         , monOi +1     ,   (friCp + monOp) / 2
         , color        =             cNWOG1
         , style        =             line.style_dotted
         , extend       =             extend.right    )         
         ))
        bl = bl_NWOG.pop(), bl.b.delete(), bl.l.delete()
    if iNDOG
        cuDOp := open    , cuDOi := n
        prDCp := close[1], prDCi := n -1
        //
        bl_NDOG.unshift(bx_ln.new(   
         box.new(
           prDCi        ,   math.max (prDCp  , cuDOp  )
         , cuDOi        ,   math.min (prDCp  , cuDOp  )
         , bgcolor      =   color    ( na             )
         , border_color =             cNDOG2
         , extend       =             extend.right    )
         ,
         line.new(
           cuDOi        ,   (prDCp + cuDOp) / 2
         , cuDOi +1     ,   (prDCp + cuDOp) / 2
         , color        =             cNDOG1
         , style        =             line.style_dotted
         , extend       =             extend.right    )     
         ))
        bl = bl_NDOG.pop(), bl.b.delete(), bl.l.delete()

//Liquidity 
for i = 0 to b_liq_B.size() -1
    x = b_liq_B.get(i)
    if not x.broken
        x.bx.set_right(n +3)
        x.ln.set_x2   (n +3)
        if not x.brokenTop
            if close > x.bx.get_top   ()
                x.brokenTop := true
        if not x.brokenBtm
            if close > x.bx.get_bottom()
                x.brokenBtm := true             
        if x.brokenBtm 
            x.bx.set_bgcolor(color.new(cLIQ_B, 90))
            x.ln.delete()
            if x.brokenTop 
                x.broken := true
                x.bx.set_right(n)

for i = 0 to b_liq_S.size() -1
    x = b_liq_S.get(i)
    if not x.broken
        x.bx.set_right(n +3)
        x.ln.set_x2   (n +3)
        if not x.brokenTop
            if close < x.bx.get_top   ()
                x.brokenTop := true
        if not x.brokenBtm
            if close < x.bx.get_bottom()
                x.brokenBtm := true             
        if x.brokenTop 
            x.bx.set_bgcolor(color.new(cLIQ_S, 90))
            x.ln.delete()
            if x.brokenBtm
                x.broken := true
                x.bx.set_right(n)

//Order Blocks   
[top, btm] = swings(length)

if showOB and per
    if close > top.y and not top.crossed 
        top.crossed := true
        
        minima = max[1]
        maxima = min[1]
        loc = time[1]
        
        for i = 1 to (n - top.x)-1
            minima := math.min(min[i], minima)
            maxima := minima == min[i] ? max[i] : maxima
            loc := minima == min[i] ? time[i] : loc
        bullish_ob.unshift(ob.new(maxima, minima, loc))
    
    if bullish_ob.size() > 0 
        for i = bullish_ob.size()-1 to 0
            element = bullish_ob.get(i)
            
            if not element.breaker 
                if math.min(close, open) < element.btm
                    element.breaker := true
                    element.break_loc := time
            else
                if close > element.top
                    bullish_ob.remove(i)
                else if i < showBull and top.y < element.top and top.y > element.btm 
                    blBrkConf := 1

    //Set label
    if blBrkConf > blBrkConf[1] and showLabels
        label.new(top.x, top.y, '▼', color = na
          , textcolor = bearCss.notransp()
          , style = label.style_label_down
          , size = size.tiny)

if showOB and per
    if close < btm.y and not btm.crossed 
        btm.crossed := true

        minima = min[1]
        maxima = max[1]
        loc = time[1]

        for i = 1 to (n - btm.x)-1
            maxima := math.max(max[i], maxima)
            minima := maxima == max[i] ? min[i] : minima
            loc := maxima == max[i] ? time[i] : loc
        bearish_ob.unshift(ob.new(maxima, minima, loc))

    if bearish_ob.size() > 0 
        for i = bearish_ob.size()-1 to 0
            element = bearish_ob.get(i)

            if not element.breaker 
                if math.max(close, open) > element.top
                    element.breaker := true
                    element.break_loc := time
            else
                if close < element.btm
                    bearish_ob.remove(i)
                else if i < showBear and btm.y > element.btm and btm.y < element.top 
                    brBrkConf := 1

    //Set label
    if brBrkConf > brBrkConf[1] and showLabels 
        label.new(btm.x, btm.y, '▲', color = na
          , textcolor = bullCss.notransp()
          , style = label.style_label_up
          , size = size.tiny)

//-----------------------------------------------------------------------------}
//Set Order Blocks
//-----------------------------------------------------------------------------{
if barstate.islast and showOB 
    if a_bx_ln_lb.size() > 0
        for i = a_bx_ln_lb.size() -1 to 0 
            item = a_bx_ln_lb.remove(i)
            item.bx.delete()
            item.ln.delete()
            item.lb.delete()
    //Bullish
    if showBull > 0
        blSz = bullish_ob.size()
        if blSz > 0
            for i = 0 to math.min(showBull, bullish_ob.size()) -1
                get_ob = bullish_ob.get(i)
                get_ob.display(bullCss, bullBrkCss, 'bl')
    //Bearish
    if showBear > 0
        brSz = bearish_ob.size()
        if brSz > 0
            for i = 0 to math.min(showBear, bearish_ob.size()) -1
                get_ob = bearish_ob.get(i)
                get_ob.display(bearCss, bearBrkCss, 'br')

//-----------------------------------------------------------------------------}
//Fibonacci
//-----------------------------------------------------------------------------{
if barstate.islast
    x1 = 0, y1 = 0., x2 = 0, y2 = 0., box up = na, box dn = na
    switch iFib
        'FVG'   =>
            if bFVG_UP.size() > 0 and bFVG_DN.size() > 0
                up  := bFVG_UP.get(0).box
                dn  := bFVG_DN.get(0).box
                dnFirst = up.get_left() > dn.get_left()
                dnBottm = up.get_top () > dn.get_top ()
                x1  := dnFirst ? dn.get_left  () : up.get_left  ()
                x2  := dnFirst ? up.get_right () : dn.get_right ()
                y1  := dnFirst ? 
                 dnBottm       ? dn.get_bottom() : dn.get_top   () :
                 dnBottm       ? up.get_top   () : up.get_bottom()
                y2  := dnFirst ? 
                 dnBottm       ? up.get_top   () : up.get_bottom() :
                 dnBottm       ? dn.get_bottom() : dn.get_top   ()
        'BPR'   =>
            if bBPR_UP.size() > 0 and bBPR_DN.size() > 0
                up  := bBPR_UP.get(0).box
                dn  := bBPR_DN.get(0).box
                dnFirst = up.get_left() > dn.get_left()
                dnBottm = up.get_top () > dn.get_top ()
                x1  := dnFirst ? dn.get_left  () : up.get_left  ()
                x2  := dnFirst ? up.get_right () : dn.get_right ()
                y1  := dnFirst ? 
                 dnBottm       ? dn.get_bottom() : dn.get_top   () :
                 dnBottm       ? up.get_top   () : up.get_bottom()
                y2  := dnFirst ? 
                 dnBottm       ? up.get_top   () : up.get_bottom() :
                 dnBottm       ? dn.get_bottom() : dn.get_top   ()
        'OB'    =>
            oSz = a_bx_ln_lb.size()
            if oSz > 1
                xA = nz(
                   a_bx_ln_lb.get(oSz -1).ln.get_x1    () 
                 , a_bx_ln_lb.get(oSz -1).bx.get_left  ()
                 )
                xB = nz(
                   a_bx_ln_lb.get(oSz -2).ln.get_x1    () 
                 , a_bx_ln_lb.get(oSz -2).bx.get_left  ()
                 ) 
                AFirst = xB > xA
                //
                yAT = nz(
                   a_bx_ln_lb.get(oSz -1).ln.get_y1    () 
                 , a_bx_ln_lb.get(oSz -1).bx.get_top   ()
                 )
                yAB = nz(
                   a_bx_ln_lb.get(oSz -1).ln.get_y1    () 
                 , a_bx_ln_lb.get(oSz -1).bx.get_bottom()
                 )          
                yBT = nz(
                   a_bx_ln_lb.get(oSz -2).ln.get_y1    () 
                 , a_bx_ln_lb.get(oSz -2).bx.get_top   ()
                 )
                yBB = nz(
                   a_bx_ln_lb.get(oSz -2).ln.get_y1    () 
                 , a_bx_ln_lb.get(oSz -2).bx.get_bottom()
                 ) 
                ABottom = yAB < yBB
                //
                x1  := AFirst ? xA : xB
                x2  := AFirst ? xB : xA
                y1  := AFirst ? 
                 ABottom ? yAB : yAT :
                 ABottom ? yBT : yBB
                y2  := AFirst ? 
                 ABottom ? yBT : yBB :
                 ABottom ? yAB : yAT
        'Liq'   =>
            if b_liq_B.size() > 0 and b_liq_S.size() > 0
                xA = nz(
                   b_liq_B.get(0).ln.get_x1    () 
                 , b_liq_B.get(0).bx.get_left  ()
                 )
                xB = nz(
                   b_liq_S.get(0).ln.get_x1    () 
                 , b_liq_S.get(0).bx.get_left  ()
                 ) 
                AFirst = xB > xA
                //
                yAT = nz(
                   b_liq_B.get(0).ln.get_y1    () 
                 , b_liq_B.get(0).bx.get_top   ()
                 )
                yAB = nz(
                   b_liq_B.get(0).ln.get_y1    () 
                 , b_liq_B.get(0).bx.get_bottom()
                 )          
                yBT = nz(
                   b_liq_S.get(0).ln.get_y1    () 
                 , b_liq_S.get(0).bx.get_top   ()
                 )
                yBB = nz(
                   b_liq_S.get(0).ln.get_y1    () 
                 , b_liq_S.get(0).bx.get_bottom()
                 ) 
                ABottom = yAB < yBB
                //
                x1  := AFirst ? xA : xB
                x2  := AFirst ? xB : xA
                y1  := AFirst ? 
                 ABottom ? yAB : yAT :
                 ABottom ? yBT : yBB
                y2  := AFirst ? 
                 ABottom ? yBT : yBB :
                 ABottom ? yAB : yAT
        'VI'    =>
            if Vimbal.size() > 1
                AxA = Vimbal.get(1).l2.get_x1(), AxB = Vimbal.get(1).l1.get_x1()
                BxA = Vimbal.get(0).l2.get_x1(), BxB = Vimbal.get(0).l1.get_x1()
                AyA = Vimbal.get(1).l2.get_y1(), AyB = Vimbal.get(1).l1.get_y1()
                ByA = Vimbal.get(0).l2.get_y1(), ByB = Vimbal.get(0).l1.get_y1()
                ABt = math.min(ByA, ByB) > math.min(AyA, AyB) 
                x1 := math.max(AxA, AxB) 
                x2 := math.max(BxA, BxB) 
                y1 := ABt ? math.min(AyA, AyB) : math.max(AyA, AyB) 
                y2 := ABt ? math.max(ByA, ByB) : math.min(ByA, ByB)  
        'NWOG'  =>
            if bl_NWOG.size() > 1
                up  := bl_NWOG.get(0).b
                dn  := bl_NWOG.get(1).b
                dnFirst = up.get_left() > dn.get_left()
                dnBottm = up.get_top () > dn.get_top ()
                x1  := dnFirst ? dn.get_left () : up.get_left ()
                x2  := dnFirst ? up.get_right() : dn.get_right()
                y1  := dnFirst ? 
                 dnBottm ? dn.get_bottom() : dn.get_top   () :
                 dnBottm ? up.get_top   () : up.get_bottom()
                y2  := dnFirst ? 
                 dnBottm ? up.get_top   () : up.get_bottom() :
                 dnBottm ? dn.get_bottom() : dn.get_top   ()
    //
    if iFib != 'NONE'
        rt = math.max(x1, x2)
        lt = math.min(x1, x2)
        tp = math.max(y1, y2)
        bt = math.min(y1, y2)
        _0 = rt == x1 ? y1 : y2
        _1 = rt == x1 ? y2 : y1
        //
        df = _1 - _0
        m0236 = df * 0.236 
        m0382 = df * 0.382 
        m0500 = df * 0.500 
        m0618 = df * 0.618 
        m0786 = df * 0.786 
        m1618 = df * 1.618 
        //
        _diag.setLine(x1, y1        , x2       , y2        )
        _vert.setLine(rt, _0        , rt       , _0 + m1618)
        _zero.setLine(rt, _0        , rt + plus, _0        )
        _0236.setLine(rt, _0 + m0236, rt + plus, _0 + m0236)
        _0382.setLine(rt, _0 + m0382, rt + plus, _0 + m0382)
        _0500.setLine(rt, _0 + m0500, rt + plus, _0 + m0500)
        _0618.setLine(rt, _0 + m0618, rt + plus, _0 + m0618)
        _0786.setLine(rt, _0 + m0786, rt + plus, _0 + m0786)
        _one_.setLine(rt, _1        , rt + plus, _1        )
        _1618.setLine(rt, _0 + m1618, rt + plus, _0 + m1618)

//-----------------------------------------------------------------------------}
//Displacement
//-----------------------------------------------------------------------------{
plotshape(sDispl ? per       ? 
     L_bodyUP    ? low  : na : na : na
     , title     = 'Displacement UP'
     , style     = shape.labelup  
     , color     = color.lime
     , location  = location.belowbar)
plotshape(sDispl ? per       ?
     L_bodyDN    ? high : na : na : na
     , title     = 'Displacement DN'
     , style     = shape.labeldown
     , color     = color.red 
     , location  = location.abovebar)

//-----------------------------------------------------------------------------}
//background - Killzones
//-----------------------------------------------------------------------------{
bgcolor  (per    ? ny        ? nyCss   : na : na, editable = false)
bgcolor  (per    ? ldn_open  ? ldnoCss : na : na, editable = false)
bgcolor  (per    ? ldn_close ? ldncCss : na : na, editable = false)
bgcolor  (per    ? asian     ? asiaCss : na : na, editable = false)

//-----------------------------------------------------------------------------}

// =================================================================================================
// Smart Money Concepts [LuxAlgo]
// =================================================================================================
// indicator('Smart Money Concepts [LuxAlgo]', ...) // merged into bundle
//---------------------------------------------------------------------------------------------------------------------}
//CONSTANTS & STRINGS & INPUTS
//---------------------------------------------------------------------------------------------------------------------{
BULLISH_LEG                     = 1
BEARISH_LEG                     = 0

BULLISH                         = +1
BEARISH                         = -1

GREEN                           = #089981
RED                             = #F23645
BLUE                            = #2157f3
GRAY                            = #878b94
MONO_BULLISH                    = #b2b5be
MONO_BEARISH                    = #5d606b

HISTORICAL                      = 'Historical'
PRESENT                         = 'Present'

COLORED                         = 'Colored'
MONOCHROME                      = 'Monochrome'

ALL                             = 'All'
BOS                             = 'BOS'
CHOCH                           = 'CHoCH'

TINY                            = size.tiny
SMALL                           = size.small
NORMAL                          = size.normal

ATR                             = 'Atr'
RANGE                           = 'Cumulative Mean Range'

CLOSE                           = 'Close'
HIGHLOW                         = 'High/Low'

SOLID                           = '⎯⎯⎯'
DASHED                          = '----'
DOTTED                          = '····'

SMART_GROUP                     = 'Smart Money Concepts'
INTERNAL_GROUP                  = 'Real Time Internal Structure'
SWING_GROUP                     = 'Real Time Swing Structure'
BLOCKS_GROUP                    = 'Order Blocks'
EQUAL_GROUP                     = 'EQH/EQL'
GAPS_GROUP                      = 'Fair Value Gaps'
LEVELS_GROUP                    = 'Highs & Lows MTF'
ZONES_GROUP                     = 'Premium & Discount Zones'

modeTooltip                     = 'Allows to display historical Structure or only the recent ones'
styleTooltip                    = 'Indicator color theme'
showTrendTooltip                = 'Display additional candles with a color reflecting the current trend detected by structure'
showInternalsTooltip            = 'Display internal market structure'
internalFilterConfluenceTooltip = 'Filter non significant internal structure breakouts'
showStructureTooltip            = 'Display swing market Structure'
showSwingsTooltip               = 'Display swing point as labels on the chart'
showHighLowSwingsTooltip        = 'Highlight most recent strong and weak high/low points on the chart'
showInternalOrderBlocksTooltip  = 'Display internal order blocks on the chart\n\nNumber of internal order blocks to display on the chart'
showSwingOrderBlocksTooltip     = 'Display swing order blocks on the chart\n\nNumber of internal swing blocks to display on the chart'
orderBlockFilterTooltip         = 'Method used to filter out volatile order blocks \n\nIt is recommended to use the cumulative mean range method when a low amount of data is available'
orderBlockMitigationTooltip     = 'Select what values to use for order block mitigation'
showEqualHighsLowsTooltip       = 'Display equal highs and equal lows on the chart'
equalHighsLowsLengthTooltip     = 'Number of bars used to confirm equal highs and equal lows'
equalHighsLowsThresholdTooltip  = 'Sensitivity threshold in a range (0, 1) used for the detection of equal highs & lows\n\nLower values will return fewer but more pertinent results'
showFairValueGapsTooltip        = 'Display fair values gaps on the chart'
fairValueGapsThresholdTooltip   = 'Filter out non significant fair value gaps'
fairValueGapsTimeframeTooltip   = 'Fair value gaps timeframe'
fairValueGapsExtendTooltip      = 'Determine how many bars to extend the Fair Value Gap boxes on chart'
showPremiumDiscountZonesTooltip = 'Display premium, discount, and equilibrium zones on chart'

modeInput                       = input.string( HISTORICAL, 'Mode',                     group = SMART_GROUP,    tooltip = modeTooltip, options = [HISTORICAL, PRESENT])
styleInput                      = input.string( COLORED,    'Style',                    group = SMART_GROUP,    tooltip = styleTooltip,options = [COLORED, MONOCHROME])
showTrendInput                  = input.bool(   false,      'Color Candles',            group = SMART_GROUP,    tooltip = showTrendTooltip)

showInternalsInput              = input.bool(   true,       'Show Internal Structure',  group = INTERNAL_GROUP, tooltip = showInternalsTooltip)
showInternalBullInput           = input.string( ALL,        'Bullish Structure',        group = INTERNAL_GROUP, inline = 'ibull', options = [ALL,BOS,CHOCH])
internalBullColorInput          = input.color(  GREEN,      '',                         group = INTERNAL_GROUP, inline = 'ibull')
showInternalBearInput           = input.string( ALL,        'Bearish Structure' ,       group = INTERNAL_GROUP, inline = 'ibear', options = [ALL,BOS,CHOCH])
internalBearColorInput          = input.color(  RED,        '',                         group = INTERNAL_GROUP, inline = 'ibear')
internalFilterConfluenceInput   = input.bool(   false,      'Confluence Filter',        group = INTERNAL_GROUP, tooltip = internalFilterConfluenceTooltip)
internalStructureSize           = input.string( TINY,       'Internal Label Size',      group = INTERNAL_GROUP, options = [TINY,SMALL,NORMAL])

showStructureInput              = input.bool(   true,       'Show Swing Structure',     group = SWING_GROUP,    tooltip = showStructureTooltip)
showSwingBullInput              = input.string( ALL,        'Bullish Structure',        group = SWING_GROUP,    inline = 'bull',    options = [ALL,BOS,CHOCH])
swingBullColorInput             = input.color(  GREEN,      '',                         group = SWING_GROUP,    inline = 'bull')
showSwingBearInput              = input.string( ALL,        'Bearish Structure',        group = SWING_GROUP,    inline = 'bear',    options = [ALL,BOS,CHOCH])
swingBearColorInput             = input.color(  RED,        '',                         group = SWING_GROUP,    inline = 'bear')
swingStructureSize              = input.string( SMALL,      'Swing Label Size',         group = SWING_GROUP,    options = [TINY,SMALL,NORMAL])
showSwingsInput                 = input.bool(   false,      'Show Swings Points',       group = SWING_GROUP,    tooltip = showSwingsTooltip,inline = 'swings')
swingsLengthInput               = input.int(    50,         '',                         group = SWING_GROUP,    minval = 10,                inline = 'swings')
showHighLowSwingsInput          = input.bool(   true,       'Show Strong/Weak High/Low',group = SWING_GROUP,    tooltip = showHighLowSwingsTooltip)

showInternalOrderBlocksInput    = input.bool(   true,       'Internal Order Blocks' ,   group = BLOCKS_GROUP,   tooltip = showInternalOrderBlocksTooltip,   inline = 'iob')
internalOrderBlocksSizeInput    = input.int(    5,          '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 20,                    inline = 'iob')
showSwingOrderBlocksInput       = input.bool(   false,      'Swing Order Blocks',       group = BLOCKS_GROUP,   tooltip = showSwingOrderBlocksTooltip,      inline = 'ob')
swingOrderBlocksSizeInput       = input.int(    5,          '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 20,                    inline = 'ob') 
orderBlockFilterInput           = input.string( 'Atr',      'Order Block Filter',       group = BLOCKS_GROUP,   tooltip = orderBlockFilterTooltip,          options = [ATR, RANGE])
orderBlockMitigationInput       = input.string( HIGHLOW,    'Order Block Mitigation',   group = BLOCKS_GROUP,   tooltip = orderBlockMitigationTooltip,      options = [CLOSE,HIGHLOW])
internalBullishOrderBlockColor  = input.color(color.new(#3179f5, 80), 'Internal Bullish OB',    group = BLOCKS_GROUP)
internalBearishOrderBlockColor  = input.color(color.new(#f77c80, 80), 'Internal Bearish OB',    group = BLOCKS_GROUP)
swingBullishOrderBlockColor     = input.color(color.new(#1848cc, 80), 'Bullish OB',             group = BLOCKS_GROUP)
swingBearishOrderBlockColor     = input.color(color.new(#b22833, 80), 'Bearish OB',             group = BLOCKS_GROUP)

showEqualHighsLowsInput         = input.bool(   true,       'Equal High/Low',           group = EQUAL_GROUP,    tooltip = showEqualHighsLowsTooltip)
equalHighsLowsLengthInput       = input.int(    3,          'Bars Confirmation',        group = EQUAL_GROUP,    tooltip = equalHighsLowsLengthTooltip,      minval = 1)
equalHighsLowsThresholdInput    = input.float(  0.1,        'Threshold',                group = EQUAL_GROUP,    tooltip = equalHighsLowsThresholdTooltip,   minval = 0, maxval = 0.5, step = 0.1)
equalHighsLowsSizeInput         = input.string( TINY,       'Label Size',               group = EQUAL_GROUP,    options = [TINY,SMALL,NORMAL])

showFairValueGapsInput          = input.bool(   false,      'Fair Value Gaps',          group = GAPS_GROUP,     tooltip = showFairValueGapsTooltip)
fairValueGapsThresholdInput     = input.bool(   true,       'Auto Threshold',           group = GAPS_GROUP,     tooltip = fairValueGapsThresholdTooltip)
fairValueGapsTimeframeInput     = input.timeframe('',       'Timeframe',                group = GAPS_GROUP,     tooltip = fairValueGapsTimeframeTooltip)
fairValueGapsBullColorInput     = input.color(color.new(#00ff68, 70), 'Bullish FVG' , group = GAPS_GROUP)
fairValueGapsBearColorInput     = input.color(color.new(#ff0008, 70), 'Bearish FVG' , group = GAPS_GROUP)
fairValueGapsExtendInput        = input.int(    1,          'Extend FVG',               group = GAPS_GROUP,     tooltip = fairValueGapsExtendTooltip,       minval = 0)

showDailyLevelsInput            = input.bool(   false,      'Daily',    group = LEVELS_GROUP,   inline = 'daily')
dailyLevelsStyleInput           = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'daily',   options = [SOLID,DASHED,DOTTED])
dailyLevelsColorInput           = input.color(  BLUE,       '',         group = LEVELS_GROUP,   inline = 'daily')
showWeeklyLevelsInput           = input.bool(   false,      'Weekly',   group = LEVELS_GROUP,   inline = 'weekly')
weeklyLevelsStyleInput          = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'weekly',  options = [SOLID,DASHED,DOTTED])
weeklyLevelsColorInput          = input.color(  BLUE,       '',         group = LEVELS_GROUP,   inline = 'weekly')
showMonthlyLevelsInput          = input.bool(   false,      'Monthly',   group = LEVELS_GROUP,   inline = 'monthly')
monthlyLevelsStyleInput         = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'monthly', options = [SOLID,DASHED,DOTTED])
monthlyLevelsColorInput         = input.color(  BLUE,       '',         group = LEVELS_GROUP,   inline = 'monthly')

showPremiumDiscountZonesInput   = input.bool(   false,      'Premium/Discount Zones',   group = ZONES_GROUP , tooltip = showPremiumDiscountZonesTooltip)
premiumZoneColorInput           = input.color(  RED,        'Premium Zone',             group = ZONES_GROUP)
equilibriumZoneColorInput       = input.color(  GRAY,       'Equilibrium Zone',         group = ZONES_GROUP)
discountZoneColorInput          = input.color(  GREEN,      'Discount Zone',            group = ZONES_GROUP)

//---------------------------------------------------------------------------------------------------------------------}


//---------------------------------------------------------------------------------------------------------------------}
//DATA STRUCTURES & VARIABLES
//---------------------------------------------------------------------------------------------------------------------{
// @type                            UDT representing alerts as bool fields
// @field internalBullishBOS        internal structure custom alert
// @field internalBearishBOS        internal structure custom alert
// @field internalBullishCHoCH      internal structure custom alert
// @field internalBearishCHoCH      internal structure custom alert
// @field swingBullishBOS           swing structure custom alert
// @field swingBearishBOS           swing structure custom alert
// @field swingBullishCHoCH         swing structure custom alert
// @field swingBearishCHoCH         swing structure custom alert
// @field internalBullishOrderBlock internal order block custom alert
// @field internalBearishOrderBlock internal order block custom alert
// @field swingBullishOrderBlock    swing order block custom alert
// @field swingBearishOrderBlock    swing order block custom alert
// @field equalHighs                equal high low custom alert
// @field equalLows                 equal high low custom alert
// @field bullishFairValueGap       fair value gap custom alert
// @field bearishFairValueGap       fair value gap custom alert
type alerts
    bool internalBullishBOS         = false
    bool internalBearishBOS         = false
    bool internalBullishCHoCH       = false
    bool internalBearishCHoCH       = false
    bool swingBullishBOS            = false
    bool swingBearishBOS            = false
    bool swingBullishCHoCH          = false
    bool swingBearishCHoCH          = false
    bool internalBullishOrderBlock  = false
    bool internalBearishOrderBlock  = false
    bool swingBullishOrderBlock     = false
    bool swingBearishOrderBlock     = false
    bool equalHighs                 = false
    bool equalLows                  = false
    bool bullishFairValueGap        = false
    bool bearishFairValueGap        = false

// @type                            UDT representing last swing extremes (top & bottom)
// @field top                       last top swing price
// @field bottom                    last bottom swing price
// @field barTime                   last swing bar time
// @field barIndex                  last swing bar index
// @field lastTopTime               last top swing time
// @field lastBottomTime            last bottom swing time
type trailingExtremes
    float top
    float bottom
    int barTime
    int barIndex
    int lastTopTime
    int lastBottomTime

// @type                            UDT representing Fair Value Gaps
// @field top                       top price
// @field bottom                    bottom price
// @field bias                      bias (BULLISH or BEARISH)
// @field topBox                    top box
// @field bottomBox                 bottom box
type fairValueGap
    float top
    float bottom
    int bias
    box topBox
    box bottomBox

// @type                            UDT representing trend bias
// @field bias                      BULLISH or BEARISH
type trend
    int bias    

// @type                            UDT representing Equal Highs Lows display
// @field l_ine                     displayed line
// @field l_abel                    displayed label
type equalDisplay
    line l_ine      = na
    label l_abel    = na

// @type                            UDT representing a pivot point (swing point) 
// @field currentLevel              current price level
// @field lastLevel                 last price level
// @field crossed                   true if price level is crossed
// @field barTime                   bar time
// @field barIndex                  bar index    
type pivot
    float currentLevel
    float lastLevel
    bool crossed
    int barTime     = time
    int barIndex    = bar_index

// @type                            UDT representing an order block
// @field barHigh                   bar high
// @field barLow                    bar low
// @field barTime                   bar time
// @field bias                      BULLISH or BEARISH
type orderBlock
    float barHigh
    float barLow
    int barTime    
    int bias

// @variable                        current swing pivot high    
var pivot swingHigh                 = pivot.new(na,na,false)
// @variable                        current swing pivot low
var pivot swingLow                  = pivot.new(na,na,false)
// @variable                        current internal pivot high
var pivot internalHigh              = pivot.new(na,na,false)
// @variable                        current internal pivot low
var pivot internalLow               = pivot.new(na,na,false)
// @variable                        current equal high pivot
var pivot equalHigh                 = pivot.new(na,na,false)
// @variable                        current equal low pivot
var pivot equalLow                  = pivot.new(na,na,false)
// @variable                        swing trend bias
var trend swingTrend                = trend.new(0)
// @variable                        internal trend bias
var trend internalTrend             = trend.new(0)
// @variable                        equal high display
var equalDisplay equalHighDisplay   = equalDisplay.new()
// @variable                        equal low display
var equalDisplay equalLowDisplay    = equalDisplay.new()
// @variable                        storage for fairValueGap UDTs
var array<fairValueGap> fairValueGaps = array.new<fairValueGap>()
// @variable                        storage for parsed highs
var array<float> parsedHighs        = array.new<float>()
// @variable                        storage for parsed lows
var array<float> parsedLows         = array.new<float>()
// @variable                        storage for raw highs
var array<float> highs              = array.new<float>()
// @variable                        storage for raw lows
var array<float> lows               = array.new<float>()
// @variable                        storage for bar time values
var array<int> times                = array.new<int>()
// @variable                        last trailing swing high and low
var trailingExtremes trailing       = trailingExtremes.new()
// @variable                                storage for orderBlock UDTs (swing order blocks)
var array<orderBlock> swingOrderBlocks      = array.new<orderBlock>()
// @variable                                storage for orderBlock UDTs (internal order blocks)
var array<orderBlock> internalOrderBlocks   = array.new<orderBlock>()
// @variable                                storage for swing order blocks boxes
var array<box> swingOrderBlocksBoxes        = array.new<box>()
// @variable                                storage for internal order blocks boxes
var array<box> internalOrderBlocksBoxes     = array.new<box>()
// @variable                        color for swing bullish structures
var swingBullishColor               = styleInput == MONOCHROME ? MONO_BULLISH : swingBullColorInput
// @variable                        color for swing bearish structures
var swingBearishColor               = styleInput == MONOCHROME ? MONO_BEARISH : swingBearColorInput
// @variable                        color for bullish fair value gaps
var fairValueGapBullishColor        = styleInput == MONOCHROME ? color.new(MONO_BULLISH,70) : fairValueGapsBullColorInput
// @variable                        color for bearish fair value gaps
var fairValueGapBearishColor        = styleInput == MONOCHROME ? color.new(MONO_BEARISH,70) : fairValueGapsBearColorInput
// @variable                        color for premium zone
var premiumZoneColor                = styleInput == MONOCHROME ? MONO_BEARISH : premiumZoneColorInput
// @variable                        color for discount zone
var discountZoneColor               = styleInput == MONOCHROME ? MONO_BULLISH : discountZoneColorInput 
// @variable                        bar index on current script iteration
varip int currentBarIndex           = bar_index
// @variable                        bar index on last script iteration
varip int lastBarIndex              = bar_index
// @variable                        alerts in current bar
alerts currentAlerts                = alerts.new()
// @variable                        time at start of chart
var initialTime                     = time

// we create the needed boxes for displaying order blocks at the first execution
if barstate.isfirst
    if showSwingOrderBlocksInput
        for index = 1 to swingOrderBlocksSizeInput
            swingOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time,extend = extend.right))
    if showInternalOrderBlocksInput
        for index = 1 to internalOrderBlocksSizeInput
            internalOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time,extend = extend.right))

// @variable                        source to use in bearish order blocks mitigation
bearishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : high
// @variable                        source to use in bullish order blocks mitigation
bullishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : low
// @variable                        default volatility measure
atrMeasure                          = ta.atr(200)
// @variable                        parsed volatility measure by user settings
volatilityMeasure                   = orderBlockFilterInput == ATR ? atrMeasure : ta.cum(ta.tr)/bar_index
// @variable                        true if current bar is a high volatility bar
highVolatilityBar                   = (high - low) >= (2 * volatilityMeasure)
// @variable                        parsed high
parsedHigh                          = highVolatilityBar ? low : high
// @variable                        parsed low
parsedLow                           = highVolatilityBar ? high : low

// we store current values into the arrays at each bar
parsedHighs.push(parsedHigh)
parsedLows.push(parsedLow)
highs.push(high)
lows.push(low)
times.push(time)

//---------------------------------------------------------------------------------------------------------------------}
//USER-DEFINED FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------{
// @function            Get the value of the current leg, it can be 0 (bearish) or 1 (bullish)
// @returns             int
leg(int size) =>
    var leg     = 0    
    newLegHigh  = high[size] > ta.highest( size)
    newLegLow   = low[size]  < ta.lowest(  size)
    
    if newLegHigh
        leg := BEARISH_LEG
    else if newLegLow
        leg := BULLISH_LEG
    leg

// @function            Identify whether the current value is the start of a new leg (swing)
// @param leg           (int) Current leg value
// @returns             bool
startOfNewLeg(int leg)      => ta.change(leg) != 0

// @function            Identify whether the current level is the start of a new bearish leg (swing)
// @param leg           (int) Current leg value
// @returns             bool
startOfBearishLeg(int leg)  => ta.change(leg) == -1

// @function            Identify whether the current level is the start of a new bullish leg (swing)
// @param leg           (int) Current leg value
// @returns             bool
startOfBullishLeg(int leg)  => ta.change(leg) == +1

// @function            create a new label
// @param labelTime     bar time coordinate
// @param labelPrice    price coordinate
// @param tag           text to display
// @param labelColor    text color
// @param labelStyle    label style
// @returns             label ID
drawLabel(int labelTime, float labelPrice, string tag, color labelColor, string labelStyle) =>    
    var label l_abel = na

    if modeInput == PRESENT
        l_abel.delete()

    l_abel := label.new(chart.point.new(labelTime,na,labelPrice),tag,xloc.bar_time,color=na,textcolor=labelColor,style = labelStyle,size = size.small)

// @function            create a new line and label representing an EQH or EQL
// @param p_ivot        starting pivot
// @param level         price level of current pivot
// @param size          how many bars ago was the current pivot detected
// @param equalHigh     true for EQH, false for EQL
// @returns             label ID
drawEqualHighLow(pivot p_ivot, float level, int size, bool equalHigh) =>
    equalDisplay e_qualDisplay = equalHigh ? equalHighDisplay : equalLowDisplay
    
    string tag          = 'EQL'
    color equalColor    = swingBullishColor
    string labelStyle   = label.style_label_up

    if equalHigh
        tag         := 'EQH'
        equalColor  := swingBearishColor
        labelStyle  := label.style_label_down

    if modeInput == PRESENT
        line.delete(    e_qualDisplay.l_ine)
        label.delete(   e_qualDisplay.l_abel)
        
    e_qualDisplay.l_ine     := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time[size],na,level), xloc = xloc.bar_time, color = equalColor, style = line.style_dotted)
    labelPosition           = math.round(0.5*(p_ivot.barIndex + bar_index - size))
    e_qualDisplay.l_abel    := label.new(chart.point.new(na,labelPosition,level), tag, xloc.bar_index, color = na, textcolor = equalColor, style = labelStyle, size = equalHighsLowsSizeInput)

// @function            store current structure and trailing swing points, and also display swing points and equal highs/lows
// @param size          (int) structure size
// @param equalHighLow  (bool) true for displaying current highs/lows
// @param internal      (bool) true for getting internal structures
// @returns             label ID
getCurrentStructure(int size,bool equalHighLow = false, bool internal = false) =>        
    currentLeg              = leg(size)
    newPivot                = startOfNewLeg(currentLeg)
    pivotLow                = startOfBullishLeg(currentLeg)
    pivotHigh               = startOfBearishLeg(currentLeg)

    if newPivot
        if pivotLow
            pivot p_ivot    = equalHighLow ? equalLow : internal ? internalLow : swingLow    

            if equalHighLow and math.abs(p_ivot.currentLevel - low[size]) < equalHighsLowsThresholdInput * atrMeasure                
                drawEqualHighLow(p_ivot, low[size], size, false)
                currentAlerts.equalLows := true

            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := low[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]

            if not equalHighLow and not internal
                trailing.bottom         := p_ivot.currentLevel
                trailing.barTime        := p_ivot.barTime
                trailing.barIndex       := p_ivot.barIndex
                trailing.lastBottomTime := p_ivot.barTime

            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel < p_ivot.lastLevel ? 'LL' : 'HL', swingBullishColor, label.style_label_up)            
        else
            pivot p_ivot = equalHighLow ? equalHigh : internal ? internalHigh : swingHigh

            if equalHighLow and math.abs(p_ivot.currentLevel - high[size]) < equalHighsLowsThresholdInput * atrMeasure
                drawEqualHighLow(p_ivot,high[size],size,true)
                currentAlerts.equalHighs := true               

            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := high[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]

            if not equalHighLow and not internal
                trailing.top            := p_ivot.currentLevel
                trailing.barTime        := p_ivot.barTime
                trailing.barIndex       := p_ivot.barIndex
                trailing.lastTopTime    := p_ivot.barTime

            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel > p_ivot.lastLevel ? 'HH' : 'LH', swingBearishColor, label.style_label_down)
                
// @function                draw line and label representing a structure
// @param p_ivot            base pivot point
// @param tag               test to display
// @param structureColor    base color
// @param lineStyle         line style
// @param labelStyle        label style
// @param labelSize         text size
// @returns                 label ID
drawStructure(pivot p_ivot, string tag, color structureColor, string lineStyle, string labelStyle, string labelSize) =>    
    var line l_ine      = line.new(na,na,na,na,xloc = xloc.bar_time)
    var label l_abel    = label.new(na,na)

    if modeInput == PRESENT
        l_ine.delete()
        l_abel.delete()

    l_ine   := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time,na,p_ivot.currentLevel), xloc.bar_time, color=structureColor, style=lineStyle)
    l_abel  := label.new(chart.point.new(na,math.round(0.5*(p_ivot.barIndex+bar_index)),p_ivot.currentLevel), tag, xloc.bar_index, color=na, textcolor=structureColor, style=labelStyle, size = labelSize)

// @function            delete order blocks
// @param internal      true for internal order blocks
// @returns             orderBlock ID
deleteOrderBlocks(bool internal = false) =>
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks

    for [index,eachOrderBlock] in orderBlocks
        bool crossedOderBlock = false
        
        if bearishOrderBlockMitigationSource > eachOrderBlock.barHigh and eachOrderBlock.bias == BEARISH
            crossedOderBlock := true
            if internal
                currentAlerts.internalBearishOrderBlock := true
            else
                currentAlerts.swingBearishOrderBlock    := true
        else if bullishOrderBlockMitigationSource < eachOrderBlock.barLow and eachOrderBlock.bias == BULLISH
            crossedOderBlock := true
            if internal
                currentAlerts.internalBullishOrderBlock := true
            else
                currentAlerts.swingBullishOrderBlock    := true
        if crossedOderBlock                    
            orderBlocks.remove(index)            

// @function            fetch and store order blocks
// @param p_ivot        base pivot point
// @param internal      true for internal order blocks
// @param bias          BULLISH or BEARISH
// @returns             void
storeOrdeBlock(pivot p_ivot,bool internal = false,int bias) =>
    if (not internal and showSwingOrderBlocksInput) or (internal and showInternalOrderBlocksInput)

        array<float> a_rray = na
        int parsedIndex = na

        if bias == BEARISH
            a_rray      := parsedHighs.slice(p_ivot.barIndex,bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.max())  
        else
            a_rray      := parsedLows.slice(p_ivot.barIndex,bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.min())                        

        orderBlock o_rderBlock          = orderBlock.new(parsedHighs.get(parsedIndex), parsedLows.get(parsedIndex), times.get(parsedIndex),bias)
        array<orderBlock> orderBlocks   = internal ? internalOrderBlocks : swingOrderBlocks
        
        if orderBlocks.size() >= 100
            orderBlocks.pop()
        orderBlocks.unshift(o_rderBlock)

// @function            draw order blocks as boxes
// @param internal      true for internal order blocks
// @returns             void
drawOrderBlocks(bool internal = false) =>        
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks
    orderBlocksSize = orderBlocks.size()

    if orderBlocksSize > 0        
        maxOrderBlocks                      = internal ? internalOrderBlocksSizeInput : swingOrderBlocksSizeInput
        array<orderBlock> parsedOrdeBlocks  = orderBlocks.slice(0, math.min(maxOrderBlocks,orderBlocksSize))
        array<box> b_oxes                   = internal ? internalOrderBlocksBoxes : swingOrderBlocksBoxes        

        for [index,eachOrderBlock] in parsedOrdeBlocks
            orderBlockColor = styleInput == MONOCHROME ? (eachOrderBlock.bias == BEARISH ? color.new(MONO_BEARISH,80) : color.new(MONO_BULLISH,80)) : internal ? (eachOrderBlock.bias == BEARISH ? internalBearishOrderBlockColor : internalBullishOrderBlockColor) : (eachOrderBlock.bias == BEARISH ? swingBearishOrderBlockColor : swingBullishOrderBlockColor)

            box b_ox        = b_oxes.get(index)
            b_ox.set_top_left_point(    chart.point.new(eachOrderBlock.barTime,na,eachOrderBlock.barHigh))
            b_ox.set_bottom_right_point(chart.point.new(last_bar_time,na,eachOrderBlock.barLow))        
            b_ox.set_border_color(      internal ? na : orderBlockColor)
            b_ox.set_bgcolor(           orderBlockColor)

// @function            detect and draw structures, also detect and store order blocks
// @param internal      true for internal structures or order blocks
// @returns             void
displayStructure(bool internal = false) =>
    var bullishBar = true
    var bearishBar = true

    if internalFilterConfluenceInput
        bullishBar := high - math.max(close, open) > math.min(close, open - low)
        bearishBar := high - math.max(close, open) < math.min(close, open - low)
    
    pivot p_ivot    = internal ? internalHigh : swingHigh
    trend t_rend    = internal ? internalTrend : swingTrend

    lineStyle       = internal ? line.style_dashed : line.style_solid
    labelSize       = internal ? internalStructureSize : swingStructureSize

    extraCondition  = internal ? internalHigh.currentLevel != swingHigh.currentLevel and bullishBar : true
    bullishColor    = styleInput == MONOCHROME ? MONO_BULLISH : internal ? internalBullColorInput : swingBullColorInput

    if ta.crossover(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == BEARISH ? CHOCH : BOS

        if internal
            currentAlerts.internalBullishCHoCH  := tag == CHOCH
            currentAlerts.internalBullishBOS    := tag == BOS
        else
            currentAlerts.swingBullishCHoCH     := tag == CHOCH
            currentAlerts.swingBullishBOS       := tag == BOS

        p_ivot.crossed  := true
        t_rend.bias     := BULLISH

        displayCondition = internal ? showInternalsInput and (showInternalBullInput == ALL or (showInternalBullInput == BOS and tag != CHOCH) or (showInternalBullInput == CHOCH and tag == CHOCH)) : showStructureInput and (showSwingBullInput == ALL or (showSwingBullInput == BOS and tag != CHOCH) or (showSwingBullInput == CHOCH and tag == CHOCH))

        if displayCondition                        
            drawStructure(p_ivot,tag,bullishColor,lineStyle,label.style_label_down,labelSize)

        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot,internal,BULLISH)

    p_ivot          := internal ? internalLow : swingLow    
    extraCondition  := internal ? internalLow.currentLevel != swingLow.currentLevel and bearishBar : true
    bearishColor    = styleInput == MONOCHROME ? MONO_BEARISH : internal ? internalBearColorInput : swingBearColorInput

    if ta.crossunder(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == BULLISH ? CHOCH : BOS

        if internal
            currentAlerts.internalBearishCHoCH  := tag == CHOCH
            currentAlerts.internalBearishBOS    := tag == BOS
        else
            currentAlerts.swingBearishCHoCH     := tag == CHOCH
            currentAlerts.swingBearishBOS       := tag == BOS

        p_ivot.crossed := true
        t_rend.bias := BEARISH

        displayCondition = internal ? showInternalsInput and (showInternalBearInput == ALL or (showInternalBearInput == BOS and tag != CHOCH) or (showInternalBearInput == CHOCH and tag == CHOCH)) : showStructureInput and (showSwingBearInput == ALL or (showSwingBearInput == BOS and tag != CHOCH) or (showSwingBearInput == CHOCH and tag == CHOCH))
        
        if displayCondition                        
            drawStructure(p_ivot,tag,bearishColor,lineStyle,label.style_label_up,labelSize)

        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot,internal,BEARISH)

// @function            draw one fair value gap box (each fair value gap has two boxes)
// @param leftTime      left time coordinate
// @param rightTime     right time coordinate
// @param topPrice      top price level
// @param bottomPrice   bottom price level
// @param boxColor      box color
// @returns             box ID
fairValueGapBox(leftTime,rightTime,topPrice,bottomPrice,boxColor) => box.new(chart.point.new(leftTime,na,topPrice),chart.point.new(rightTime + fairValueGapsExtendInput * (time-time[1]),na,bottomPrice), xloc=xloc.bar_time, border_color = boxColor, bgcolor = boxColor)

// @function            delete fair value gaps
// @returns             fairValueGap ID
deleteFairValueGaps() =>
    for [index,eachFairValueGap] in fairValueGaps
        if (low < eachFairValueGap.bottom and eachFairValueGap.bias == BULLISH) or (high > eachFairValueGap.top and eachFairValueGap.bias == BEARISH)
            eachFairValueGap.topBox.delete()
            eachFairValueGap.bottomBox.delete()
            fairValueGaps.remove(index)
    
// @function            draw fair value gaps
// @returns             fairValueGap ID
drawFairValueGaps() => 
    [lastClose, lastOpen, lastTime, currentHigh, currentLow, currentTime, last2High, last2Low] = request.security(syminfo.tickerid, fairValueGapsTimeframeInput, [close[1], open[1], time[1], high[0], low[0], time[0], high[2], low[2]],lookahead = barmerge.lookahead_on)

    barDeltaPercent     = (lastClose - lastOpen) / (lastOpen * 100)
    newTimeframe        = timeframe.change(fairValueGapsTimeframeInput)
    threshold           = fairValueGapsThresholdInput ? ta.cum(math.abs(newTimeframe ? barDeltaPercent : 0)) / bar_index * 2 : 0

    bullishFairValueGap = currentLow > last2High and lastClose > last2High and barDeltaPercent > threshold and newTimeframe
    bearishFairValueGap = currentHigh < last2Low and lastClose < last2Low and -barDeltaPercent > threshold and newTimeframe

    if bullishFairValueGap
        currentAlerts.bullishFairValueGap := true
        midPoint = (currentLow + last2High) / 2
        fairValueGaps.unshift(fairValueGap.new(currentLow,last2High,BULLISH,fairValueGapBox(lastTime,currentTime,currentLow,midPoint,fairValueGapBullishColor),fairValueGapBox(lastTime,currentTime,midPoint,last2High,fairValueGapBullishColor)))
    if bearishFairValueGap
        currentAlerts.bearishFairValueGap := true
        midPoint = (currentHigh + last2Low) / 2
        fairValueGaps.unshift(fairValueGap.new(currentHigh,last2Low,BEARISH,fairValueGapBox(lastTime,currentTime,currentHigh,midPoint,fairValueGapBearishColor),fairValueGapBox(lastTime,currentTime,midPoint,last2Low,fairValueGapBearishColor)))

// @function            get line style from string
// @param style         line style
// @returns             string
getStyle(string style) =>
    switch style
        SOLID => line.style_solid
        DASHED => line.style_dashed
        DOTTED => line.style_dotted

// @function            draw MultiTimeFrame levels
// @param timeframe     base timeframe
// @param sameTimeframe true if chart timeframe is same as base timeframe
// @param style         line style
// @param levelColor    line and text color
// @returns             void
drawLevels(string timeframe, bool sameTimeframe, string style, color levelColor) =>
    [topLevel, bottomLevel, leftTime, rightTime] = request.security(syminfo.tickerid, timeframe, [high[1], low[1], time[1], time],lookahead = barmerge.lookahead_on)

    float parsedTop         = sameTimeframe ? high : topLevel
    float parsedBottom      = sameTimeframe ? low : bottomLevel    

    int parsedLeftTime      = sameTimeframe ? time : leftTime
    int parsedRightTime     = sameTimeframe ? time : rightTime

    int parsedTopTime       = time
    int parsedBottomTime    = time

    if not sameTimeframe
        int leftIndex               = times.binary_search_rightmost(parsedLeftTime)
        int rightIndex              = times.binary_search_rightmost(parsedRightTime)

        array<int> timeArray        = times.slice(leftIndex,rightIndex)
        array<float> topArray       = highs.slice(leftIndex,rightIndex)
        array<float> bottomArray    = lows.slice(leftIndex,rightIndex)

        parsedTopTime               := timeArray.size() > 0 ? timeArray.get(topArray.indexof(topArray.max())) : initialTime
        parsedBottomTime            := timeArray.size() > 0 ? timeArray.get(bottomArray.indexof(bottomArray.min())) : initialTime

    var line topLine        = line.new(na, na, na, na, xloc = xloc.bar_time, color = levelColor, style = getStyle(style))
    var line bottomLine     = line.new(na, na, na, na, xloc = xloc.bar_time, color = levelColor, style = getStyle(style))
    var label topLabel      = label.new(na, na, xloc = xloc.bar_time, text = str.format('P{0}H',timeframe), color=na, textcolor = levelColor, size = size.small, style = label.style_label_left)
    var label bottomLabel   = label.new(na, na, xloc = xloc.bar_time, text = str.format('P{0}L',timeframe), color=na, textcolor = levelColor, size = size.small, style = label.style_label_left)

    topLine.set_first_point(    chart.point.new(parsedTopTime,na,parsedTop))
    topLine.set_second_point(   chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedTop))   
    topLabel.set_point(         chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedTop))

    bottomLine.set_first_point( chart.point.new(parsedBottomTime,na,parsedBottom))    
    bottomLine.set_second_point(chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedBottom))
    bottomLabel.set_point(      chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedBottom))

// @function            true if chart timeframe is higher than provided timeframe
// @param timeframe     timeframe to check
// @returns             bool
higherTimeframe(string timeframe) => timeframe.in_seconds() > timeframe.in_seconds(timeframe)

// @function            update trailing swing points
// @returns             int
updateTrailingExtremes() =>
    trailing.top            := math.max(high,trailing.top)
    trailing.lastTopTime    := trailing.top == high ? time : trailing.lastTopTime
    trailing.bottom         := math.min(low,trailing.bottom)
    trailing.lastBottomTime := trailing.bottom == low ? time : trailing.lastBottomTime

// @function            draw trailing swing points
// @returns             void
drawHighLowSwings() =>
    var line topLine        = line.new(na, na, na, na, color = swingBearishColor, xloc = xloc.bar_time)
    var line bottomLine     = line.new(na, na, na, na, color = swingBullishColor, xloc = xloc.bar_time)
    var label topLabel      = label.new(na, na, color=na, textcolor = swingBearishColor, xloc = xloc.bar_time, style = label.style_label_down, size = size.tiny)
    var label bottomLabel   = label.new(na, na, color=na, textcolor = swingBullishColor, xloc = xloc.bar_time, style = label.style_label_up, size = size.tiny)

    rightTimeBar            = last_bar_time + 20 * (time - time[1])

    topLine.set_first_point(    chart.point.new(trailing.lastTopTime, na, trailing.top))
    topLine.set_second_point(   chart.point.new(rightTimeBar, na, trailing.top))
    topLabel.set_point(         chart.point.new(rightTimeBar, na, trailing.top))
    topLabel.set_text(          swingTrend.bias == BEARISH ? 'Strong High' : 'Weak High')

    bottomLine.set_first_point( chart.point.new(trailing.lastBottomTime, na, trailing.bottom))
    bottomLine.set_second_point(chart.point.new(rightTimeBar, na, trailing.bottom))
    bottomLabel.set_point(      chart.point.new(rightTimeBar, na, trailing.bottom))
    bottomLabel.set_text(       swingTrend.bias == BULLISH ? 'Strong Low' : 'Weak Low')

// @function            draw a zone with a label and a box
// @param labelLevel    price level for label
// @param labelIndex    bar index for label
// @param top           top price level for box
// @param bottom        bottom price level for box
// @param tag           text to display
// @param zoneColor     base color
// @param style         label style
// @returns             void
drawZone(float labelLevel, int labelIndex, float top, float bottom, string tag, color zoneColor, string style) =>
    var label l_abel    = label.new(na,na,text = tag, color=na,textcolor = zoneColor, style = style, size = size.small)
    var box b_ox        = box.new(na,na,na,na,bgcolor = color.new(zoneColor,80),border_color = na, xloc = xloc.bar_time)

    b_ox.set_top_left_point(    chart.point.new(trailing.barTime,na,top))
    b_ox.set_bottom_right_point(chart.point.new(last_bar_time,na,bottom))

    l_abel.set_point(           chart.point.new(na,labelIndex,labelLevel))

// @function            draw premium/discount zones
// @returns             void
drawPremiumDiscountZones() =>
    drawZone(trailing.top, math.round(0.5*(trailing.barIndex + last_bar_index)), trailing.top, 0.95*trailing.top + 0.05*trailing.bottom, 'Premium', premiumZoneColor, label.style_label_down)

    equilibriumLevel = (trailing.top + trailing.bottom) / 2
    drawZone(equilibriumLevel, last_bar_index, 0.525*trailing.top + 0.475*trailing.bottom, 0.525*trailing.bottom + 0.475*trailing.top, 'Equilibrium', equilibriumZoneColorInput, label.style_label_left)

    drawZone(trailing.bottom, math.round(0.5*(trailing.barIndex + last_bar_index)), 0.95*trailing.bottom + 0.05*trailing.top, trailing.bottom, 'Discount', discountZoneColor, label.style_label_up)

//---------------------------------------------------------------------------------------------------------------------}
//MUTABLE VARIABLES & EXECUTION
//---------------------------------------------------------------------------------------------------------------------{
parsedOpen  = showTrendInput ? open : na
candleColor = internalTrend.bias == BULLISH ? swingBullishColor : swingBearishColor
plotcandle(parsedOpen,high,low,close,color = candleColor, wickcolor = candleColor, bordercolor = candleColor)

if showHighLowSwingsInput or showPremiumDiscountZonesInput
    updateTrailingExtremes()

    if showHighLowSwingsInput
        drawHighLowSwings()

    if showPremiumDiscountZonesInput
        drawPremiumDiscountZones()

if showFairValueGapsInput
    deleteFairValueGaps()

getCurrentStructure(swingsLengthInput,false)
getCurrentStructure(5,false,true)

if showEqualHighsLowsInput
    getCurrentStructure(equalHighsLowsLengthInput,true)

if showInternalsInput or showInternalOrderBlocksInput or showTrendInput
    displayStructure(true)

if showStructureInput or showSwingOrderBlocksInput or showHighLowSwingsInput
    displayStructure()

if showInternalOrderBlocksInput
    deleteOrderBlocks(true)

if showSwingOrderBlocksInput
    deleteOrderBlocks()

if showFairValueGapsInput
    drawFairValueGaps()

if barstate.islastconfirmedhistory or barstate.islast
    if showInternalOrderBlocksInput        
        drawOrderBlocks(true)
        
    if showSwingOrderBlocksInput        
        drawOrderBlocks()

lastBarIndex    := currentBarIndex
currentBarIndex := bar_index
newBar          = currentBarIndex != lastBarIndex

if barstate.islastconfirmedhistory or (barstate.isrealtime and newBar)
    if showDailyLevelsInput and not higherTimeframe('D')
        drawLevels('D',timeframe.isdaily,dailyLevelsStyleInput,dailyLevelsColorInput)

    if showWeeklyLevelsInput and not higherTimeframe('W')
        drawLevels('W',timeframe.isweekly,weeklyLevelsStyleInput,weeklyLevelsColorInput)

    if showMonthlyLevelsInput and not higherTimeframe('M')
        drawLevels('M',timeframe.ismonthly,monthlyLevelsStyleInput,monthlyLevelsColorInput)

//---------------------------------------------------------------------------------------------------------------------}
//ALERTS
//---------------------------------------------------------------------------------------------------------------------{
alertcondition(currentAlerts.internalBullishBOS,        'Internal Bullish BOS',         'Internal Bullish BOS formed')
alertcondition(currentAlerts.internalBullishCHoCH,      'Internal Bullish CHoCH',       'Internal Bullish CHoCH formed')
alertcondition(currentAlerts.internalBearishBOS,        'Internal Bearish BOS',         'Internal Bearish BOS formed')
alertcondition(currentAlerts.internalBearishCHoCH,      'Internal Bearish CHoCH',       'Internal Bearish CHoCH formed')
alertcondition(currentAlerts.swingBullishBOS,           'Bullish BOS',                  'Internal Bullish BOS formed')
alertcondition(currentAlerts.swingBullishCHoCH,         'Bullish CHoCH',                'Internal Bullish CHoCH formed')
alertcondition(currentAlerts.swingBearishBOS,           'Bearish BOS',                  'Bearish BOS formed')
alertcondition(currentAlerts.swingBearishCHoCH,         'Bearish CHoCH',                'Bearish CHoCH formed')
alertcondition(currentAlerts.internalBullishOrderBlock, 'Bullish Internal OB Breakout', 'Price broke bullish internal OB')
alertcondition(currentAlerts.internalBearishOrderBlock, 'Bearish Internal OB Breakout', 'Price broke bearish internal OB')
alertcondition(currentAlerts.swingBullishOrderBlock,    'Bullish Swing OB Breakout',    'Price broke bullish swing OB')
alertcondition(currentAlerts.swingBearishOrderBlock,    'Bearish Swing OB Breakout',    'Price broke bearish swing OB')
alertcondition(currentAlerts.equalHighs,                'Equal Highs',                  'Equal highs detected')
alertcondition(currentAlerts.equalLows,                 'Equal Lows',                   'Equal lows detected')
alertcondition(currentAlerts.bullishFairValueGap,       'Bullish FVG',                  'Bullish FVG formed')
alertcondition(currentAlerts.bearishFairValueGap,       'Bearish FVG',                  'Bearish FVG formed')
//---------------------------------------------------------------------------------------------------------------------}
// =================================================================================================
// VWAP MTF
// =================================================================================================

TimeFrame = input.timeframe('W', 'VWAP Timeframe')
start = request.security(syminfo.tickerid, TimeFrame, time)
//------------------------------------------------
newSession = ta.change(start) != 0
//------------------------------------------------
var float vwapsum = na
var float volumesum = na
var float v2sum = na
var float prevwap = na
vwapsum := newSession ? hl2 * volume : nz(vwapsum[1]) + hl2 * volume
volumesum := newSession ? volume : nz(volumesum[1]) + volume
v2sum := newSession ? volume * hl2 * hl2 : nz(v2sum[1]) + volume * hl2 * hl2
myvwap = volumesum != 0 ? vwapsum / volumesum : na
dev = volumesum != 0 ? math.sqrt(math.max(v2sum / volumesum - nz(myvwap) * nz(myvwap), 0)) : na
Coloring = not na(myvwap) and close > myvwap ? color.green : color.red
av = myvwap
showBcol = input.bool(false, title="Show barcolors")
showPrevVWAP = input.bool(false, title="Show previous VWAP close")
prevwap := newSession ? myvwap[1] : prevwap[1]
prevwapColor = not na(prevwap) and close > prevwap ? color.green : color.red
plot(showPrevVWAP and not na(prevwap) ? prevwap : na, style=plot.style_circles, color=prevwapColor)
A = plot(av, style=plot.style_circles, color=Coloring)
barcolor(showBcol ? Coloring : na)