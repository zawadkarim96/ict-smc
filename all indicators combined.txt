//@version=6
indicator('ICT SMC All Indicators', 'ICTSMC-All', overlay=true, max_labels_count=500, max_lines_count=500, max_boxes_count=500, max_bars_back=5000)

string group_ema22 = "EMA 22 Settings"
show_ema22 = input.bool(true, 'Show EMA 22', group=group_ema22)
ema22_color = input.color(color.blue, 'Color', group=group_ema22)
ema22_transparency = input.int(0, 'Transparency', minval=0, maxval=100, group=group_ema22)
ema22_value = ta.ema(close, 22)
plot(show_ema22 ? ema22_value : na, 'EMA 22', color.new(ema22_color, ema22_transparency))

clampInt(int value, int minValue, int maxValue) => value < minValue ? minValue : value > maxValue ? maxValue : value
clampFloat(float value, float minValue, float maxValue) => math.max(minValue, math.min(maxValue, value))
nonNegativeInt(int value) => value < 0 ? 0 : value
ensureMinInt(int value, int minValue) => value < minValue ? minValue : value

string groupUtCombo = "UT Bot + Linear Regression"
bool enableUtComboInput = input.bool(false, 'Enable UT Bot + Linear Regression', group=groupUtCombo)

string groupUtBot = "UT Bot"
float utBuySensitivityInput = input.float(2.0, 'Buy Sensitivity (Multiplier)', minval=0.0, group=groupUtBot)
int utBuyAtrPeriodInput = input.int(1, 'Buy ATR Period (0 = disable)', minval=0, group=groupUtBot)
float utSellSensitivityInput = input.float(2.0, 'Sell Sensitivity (Multiplier)', minval=0.0, group=groupUtBot)
int utSellAtrPeriodInput = input.int(1, 'Sell ATR Period (0 = disable)', minval=0, group=groupUtBot)
bool utShowTrailBuyInput = input.bool(false, 'Show Buy Trailing Line', group=groupUtBot)
bool utShowTrailSellInput = input.bool(false, 'Show Sell Trailing Line', group=groupUtBot)

string groupUtLinReg = "LinReg"
int utSignalLengthInput = input.int(7, 'Signal Smoothing', minval=1, maxval=200, group=groupUtLinReg)
bool utSignalSmaInput = input.bool(true, 'Simple MA (Signal Line)', group=groupUtLinReg)
bool utUseLinRegInput = input.bool(true, 'Use LinReg', group=groupUtLinReg)
int utLinRegLengthInput = input.int(11, 'Linear Regression Length', minval=1, maxval=200, group=groupUtLinReg)

string groupUtZones = "Longevity Zones"
bool utShowZonesInput = input.bool(true, 'Show Longevity Zones', group=groupUtZones)
int utLongevityLengthInput = input.int(5, 'Longevity Length', group=groupUtZones)
color utLongevityUpperColorInput = input.color(color.new(color.red, 75), 'Upper Zone Color', group=groupUtZones)
color utLongevityLowerColorInput = input.color(color.new(color.green, 75), 'Lower Zone Color', group=groupUtZones)
string utLongevityLabelPositionInput = input.string('LastBar', 'Labels Position', options=['Root', 'LastBar'], group=groupUtZones)
bool utLongevityLabelsAtRoot = utLongevityLabelPositionInput == 'LastBar'
int utLongevityLabelOffsetInput = input.int(10, 'Label Offset (bars)', group=groupUtZones, minval=10, maxval=500)

string groupUtAddOns = 'Add-ons (Panel & S/R)'
bool utSrLinesInput = input.bool(false, 'Support & Resistance Lines', group=groupUtAddOns)
int utVolMaLenInput = input.int(20, 'Volume MA Length', group=groupUtAddOns, minval=1)

string groupUtSupport = 'Support & Resistance'
bool utShowSrInput = input.bool(true, 'Show Support & Resistance Lines', group=groupUtSupport)

string groupUtOsc = 'Oscillator Settings'
int utMacdFastLengthInput = input.int(12, 'MACD Fast Length', group=groupUtOsc)
int utMacdSlowLengthInput = input.int(26, 'MACD Slow Length', group=groupUtOsc)
int utMacdSignalLengthInput = input.int(9, 'MACD Signal Length', group=groupUtOsc)
int utStochLengthInput = input.int(14, 'Stochastic Length', group=groupUtOsc)
int utStochKInput = input.int(3, 'Stoch K Smoothing', group=groupUtOsc)
int utStochDInput = input.int(3, 'Stoch D Smoothing', group=groupUtOsc)

string groupNtz = "No Trade Zone"
bool enableNtzInput = input.bool(true, 'Enable No Trade Zone', group=groupNtz)
bool showNtzBackgroundInput = input.bool(true, 'Show Zone Background', group=groupNtz)
bool showNtzLabelInput = input.bool(true, 'Show Zone Label', group=groupNtz)
bool enableNtzAlertInput = input.bool(true, 'Enable NTZ Alert', group=groupNtz)

var label ntzLabel = na
var int ntzPrevMssDir = 0

bool utModuleActive = enableUtComboInput

bool utBuyEnabled = utModuleActive and utBuyAtrPeriodInput > 0 and utBuySensitivityInput > 0
float utSrcBuy = close
float utEmaBuy = ta.ema(utSrcBuy, 1)
float utAtrBuy = utBuyEnabled ? ta.atr(utBuyAtrPeriodInput) : na
float utBuyStopDistance = utBuyEnabled ? utBuySensitivityInput * utAtrBuy : na
var float utTrailBuy = na
if utModuleActive and utBuyEnabled
    if na(utTrailBuy[1])
        utTrailBuy := utSrcBuy - utBuyStopDistance
    else
        if utSrcBuy > utTrailBuy[1] and utSrcBuy[1] > utTrailBuy[1]
            utTrailBuy := math.max(utTrailBuy[1], utSrcBuy - utBuyStopDistance)
        else if utSrcBuy < utTrailBuy[1] and utSrcBuy[1] < utTrailBuy[1]
            utTrailBuy := math.min(utTrailBuy[1], utSrcBuy + utBuyStopDistance)
        else
            utTrailBuy := utSrcBuy > utTrailBuy[1] ? utSrcBuy - utBuyStopDistance : utSrcBuy + utBuyStopDistance
else
    utTrailBuy := na

bool utSellEnabled = utModuleActive and utSellAtrPeriodInput > 0 and utSellSensitivityInput > 0
float utSrcSell = close
float utEmaSell = ta.ema(utSrcSell, 1)
float utAtrSell = utSellEnabled ? ta.atr(utSellAtrPeriodInput) : na
float utSellStopDistance = utSellEnabled ? utSellSensitivityInput * utAtrSell : na
var float utTrailSell = na
if utModuleActive and utSellEnabled
    if na(utTrailSell[1])
        utTrailSell := utSrcSell + utSellStopDistance
    else
        if utSrcSell > utTrailSell[1] and utSrcSell[1] > utTrailSell[1]
            utTrailSell := math.max(utTrailSell[1], utSrcSell - utSellStopDistance)
        else if utSrcSell < utTrailSell[1] and utSrcSell[1] < utTrailSell[1]
            utTrailSell := math.min(utTrailSell[1], utSrcSell + utSellStopDistance)
        else
            utTrailSell := utSrcSell > utTrailSell[1] ? utSrcSell - utSellStopDistance : utSrcSell + utSellStopDistance
else
    utTrailSell := na

bool utBuyCrossDetected = ta.crossover(utEmaBuy, utTrailBuy)
bool utSellCrossDetected = ta.crossover(utTrailSell, utEmaSell)
bool utAboveBuyCross = utModuleActive and utBuyEnabled and utBuyCrossDetected
bool utBelowSellCross = utModuleActive and utSellEnabled and utSellCrossDetected

bool utBuySignalRaw = utModuleActive and utBuyEnabled and (utSrcBuy > utTrailBuy) and utAboveBuyCross
bool utSellSignalRaw = utModuleActive and utSellEnabled and (utSrcSell < utTrailSell) and utBelowSellCross

var int utPosState = 0
bool utBuySignalConfirmed = false
bool utSellSignalConfirmed = false
if not utModuleActive
    utPosState := 0
else
    bool utBuyCandidate = utBuySignalRaw and barstate.isconfirmed and utPosState <= 0
    bool utSellCandidate = utSellSignalRaw and barstate.isconfirmed and utPosState >= 0
    if utBuyCandidate
        utPosState := 1
    else if utSellCandidate
        utPosState := -1
    utBuySignalConfirmed := utBuyCandidate
    utSellSignalConfirmed := utSellCandidate

bool utBuySignalVisible = utModuleActive and utBuySignalRaw
bool utSellSignalVisible = utModuleActive and utSellSignalRaw
color utBarColorSeries = utBuySignalVisible ? color.new(color.green, 75) : utSellSignalVisible ? color.new(color.red, 75) : na

bool utLinRegActive = utModuleActive and utUseLinRegInput
float utLinRegOpenSeries = utLinRegActive ? ta.linreg(open, utLinRegLengthInput, 0) : open
float utLinRegHighSeries = utLinRegActive ? ta.linreg(high, utLinRegLengthInput, 0) : high
float utLinRegLowSeries = utLinRegActive ? ta.linreg(low, utLinRegLengthInput, 0) : low
float utLinRegCloseSeries = utLinRegActive ? ta.linreg(close, utLinRegLengthInput, 0) : close
float utLinRegClosePrevSeries = utLinRegActive ? ta.linreg(close, utLinRegLengthInput, 1) : nz(close[1], close)

float utSignalLineValue = utModuleActive ? (utSignalSmaInput ? ta.sma(utLinRegCloseSeries, utSignalLengthInput) : ta.ema(utLinRegCloseSeries, utSignalLengthInput)) : na

bool utInLong = utModuleActive and utPosState == 1
bool utInShort = utModuleActive and utPosState == -1
bool utIsFlat = utModuleActive and utPosState == 0
bool utDirUp = utLinRegCloseSeries >= utLinRegOpenSeries

float utLinRegSlope = utModuleActive ? utLinRegCloseSeries - utLinRegClosePrevSeries : 0.0
int utLinRegSlopeDir = utModuleActive ? (utLinRegSlope > 0 ? 1 : utLinRegSlope < 0 ? -1 : 0) : 0
int utSignalDir = utModuleActive ? (utBuySignalConfirmed ? 1 : utSellSignalConfirmed ? -1 : 0) : 0
bool utSignalMissingOrConflict = not utModuleActive or utSignalDir == 0 or (utLinRegSlopeDir != 0 and utSignalDir != utLinRegSlopeDir)

type utLevel
    float top
    float bot
    int start
type utDrawing
    line top
    line bot
    linefill fill
    label lbl

var utUpperLevels = array.new<utLevel>()
var utLowerLevels = array.new<utLevel>()
var utUpperDrawings = array.new<utDrawing>()
var utLowerDrawings = array.new<utDrawing>()

float utHighestSeries = ta.highest(utLongevityLengthInput)
float utLowestSeries = ta.lowest(utLongevityLengthInput)
bool utHighPivot = high[1] == utHighestSeries[1] and high < utHighestSeries
bool utLowPivot = low[1] == utLowestSeries[1] and low > utLowestSeries
float utHalfAtr = ta.atr(20) * 0.5

bool utZonesActive = utModuleActive and utShowZonesInput
if utZonesActive
    if utHighPivot
        array.push(utUpperLevels, utLevel.new(utHighestSeries, utHighestSeries - utHalfAtr, bar_index - 1))
    if utLowPivot
        array.push(utLowerLevels, utLevel.new(utLowestSeries + utHalfAtr, utLowestSeries, bar_index - 1))
    if array.size(utUpperLevels) > 10
        array.shift(utUpperLevels)
    if array.size(utLowerLevels) > 10
        array.shift(utLowerLevels)
    for i = array.size(utUpperLevels) - 1 to 0
        if array.size(utUpperLevels) == 0
            break
        zUp = array.get(utUpperLevels, i)
        if high > zUp.top and bar_index > zUp.start
            array.remove(utUpperLevels, i)
    for i = array.size(utLowerLevels) - 1 to 0
        if array.size(utLowerLevels) == 0
            break
        zLo = array.get(utLowerLevels, i)
        if low < zLo.bot and bar_index > zLo.start
            array.remove(utLowerLevels, i)

if barstate.islast and utZonesActive
    if array.size(utUpperDrawings) > 0
        for i = 0 to array.size(utUpperDrawings) - 1
            d = array.get(utUpperDrawings, i)
            line.delete(d.top)
            line.delete(d.bot)
            if not na(d.fill)
                linefill.delete(d.fill)
            label.delete(d.lbl)
        array.clear(utUpperDrawings)
    if array.size(utLowerDrawings) > 0
        for i = 0 to array.size(utLowerDrawings) - 1
            d = array.get(utLowerDrawings, i)
            line.delete(d.top)
            line.delete(d.bot)
            if not na(d.fill)
                linefill.delete(d.fill)
            label.delete(d.lbl)
        array.clear(utLowerDrawings)
    if array.size(utUpperLevels) > 0
        for i = 0 to array.size(utUpperLevels) - 1
            z = array.get(utUpperLevels, i)
            l1 = line.new(z.start, z.top, bar_index, z.top, color=utLongevityUpperColorInput, width=8)
            l2 = line.new(z.start, z.bot, bar_index, z.bot, color=utLongevityUpperColorInput, width=8)
            f = linefill.new(l1, l2, color=utLongevityUpperColorInput)
            dur = bar_index - z.start
            daysTot = int(dur * (timeframe.in_seconds(timeframe.period) / 86400))
            txt = daysTot >= 365 ? str.tostring(int(daysTot / 365)) + ' Y (' + str.tostring(dur) + ' bars)' : daysTot >= 30 ? str.tostring(int(daysTot / 30)) + ' M (' + str.tostring(dur) + ' bars)' : str.tostring(daysTot) + ' D (' + str.tostring(dur) + ' bars)'
            lx = utLongevityLabelsAtRoot ? z.start : bar_index + utLongevityLabelOffsetInput
            ly = (z.top + z.bot) / 2
            lbl = label.new(lx, ly, txt, style=label.style_label_center, textcolor=color.white, color=color.new(color.black, 0))
            array.push(utUpperDrawings, utDrawing.new(l1, l2, f, lbl))
    if array.size(utLowerLevels) > 0
        for i = 0 to array.size(utLowerLevels) - 1
            z = array.get(utLowerLevels, i)
            l1 = line.new(z.start, z.top, bar_index, z.top, color=utLongevityLowerColorInput, width=8)
            l2 = line.new(z.start, z.bot, bar_index, z.bot, color=utLongevityLowerColorInput, width=8)
            f = linefill.new(l1, l2, color=utLongevityLowerColorInput)
            dur = bar_index - z.start
            daysTot = int(dur * (timeframe.in_seconds(timeframe.period) / 86400))
            txt = daysTot >= 365 ? str.tostring(int(daysTot / 365)) + ' Y (' + str.tostring(dur) + ' bars)' : daysTot >= 30 ? str.tostring(int(daysTot / 30)) + ' M (' + str.tostring(dur) + ' bars)' : str.tostring(daysTot) + ' D (' + str.tostring(dur) + ' bars)'
            lx = utLongevityLabelsAtRoot ? z.start : bar_index + utLongevityLabelOffsetInput
            ly = (z.top + z.bot) / 2
            lbl = label.new(lx, ly, txt, style=label.style_label_center, textcolor=color.white, color=color.new(color.black, 0))
            array.push(utLowerDrawings, utDrawing.new(l1, l2, f, lbl))
else if barstate.islast
    if array.size(utUpperDrawings) > 0
        for i = 0 to array.size(utUpperDrawings) - 1
            d = array.get(utUpperDrawings, i)
            line.delete(d.top)
            line.delete(d.bot)
            if not na(d.fill)
                linefill.delete(d.fill)
            label.delete(d.lbl)
        array.clear(utUpperDrawings)
    if array.size(utLowerDrawings) > 0
        for i = 0 to array.size(utLowerDrawings) - 1
            d = array.get(utLowerDrawings, i)
            line.delete(d.top)
            line.delete(d.bot)
            if not na(d.fill)
                linefill.delete(d.fill)
            label.delete(d.lbl)
        array.clear(utLowerDrawings)

float utH1000 = ta.highest(high, 1000)
float utH750 = ta.highest(high, 750)
float utH500 = ta.highest(high, 500)
float utH250 = ta.highest(high, 250)
float utH100 = ta.highest(high, 100)
float utH50 = ta.highest(high, 50)
float utH10 = ta.highest(high, 10)
float utL1000 = ta.lowest(low, 1000)
float utL750 = ta.lowest(low, 750)
float utL500 = ta.lowest(low, 500)
float utL250 = ta.lowest(low, 250)
float utL100 = ta.lowest(low, 100)
float utL50 = ta.lowest(low, 50)
float utL10 = ta.lowest(low, 10)


emaTrendTf(tf) =>
    float emaFast = request.security(syminfo.tickerid, tf, ta.ema(close, 9), barmerge.gaps_off, barmerge.lookahead_off)
    float emaSlow = request.security(syminfo.tickerid, tf, ta.ema(close, 21), barmerge.gaps_off, barmerge.lookahead_off)
    emaFast > emaSlow ? '🟢 BULL' : emaFast < emaSlow ? '🔴 BEAR' : '— FLAT'

trendStrHtF(tf) => emaTrendTf(tf)

utCalcVol() =>
    float _atr = ta.atr(14)
    float _std2 = 2.0 * ta.stdev(_atr, 20)
    float _sma = ta.sma(_atr, 20)
    float top = _sma + _std2
    float bot = _sma - _std2
    nz(30.0 + 40.0 * ((_atr - bot) / math.max(1e-10, (top - bot))), 50)

float utVolatilityPercent = utCalcVol()

user_ssth = input.string('20', 'Start Session Hour (EST)', options=['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23'])
user_sstm = input.string('00', 'Start Session Minute (EST)', options=['00', '15', '30', '45'])

user_esth = input.string('02', 'End Session Hour (EST)', options=['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23'])
user_estm = input.string('00', 'End Session Minute (EST)', options=['00', '15', '30', '45'])

user_elth = input.string('11', 'Extend Session Lines Until Hour (EST)', options=['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23'])
user_eltm = input.string('30', 'Extend Session Lines Until Minute (EST)', options=['00', '15', '30', '45'])



user_box_line_color = input.string('blue', 'Asian Range Border Color', options=['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 'silver', 'teal', 'white', 'yellow'])
boxLineWidthInput = input.int(title="Asian Box Line Width", defval=1)
boxLineWidth = clampInt(boxLineWidthInput, 0, 10)
user_box_line_style = input.string('solid', 'Asian Box Line Style', options=['solid', 'dashed', 'dotted'])

sessionLineWidthInput = input.int(title="Session High / Low / Mid Line Width", defval=2)
sessionLineWidth = clampInt(sessionLineWidthInput, 0, 20)
user_upperlower_line_style = input.string('dotted', 'Session High / Low Line Style', options=['solid', 'dashed', 'dotted'])

user_midline_color = input.string('orange', 'Middle Range Line Color', options=['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 'silver', 'teal', 'white', 'yellow'])
user_middle_line_style = input.string('dotted', 'Middle Range Line Style', options=['solid', 'dashed', 'dotted'])

user_text_color = input.string('blue', 'Text Color', options=['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 'silver', 'teal', 'white', 'yellow'])
user_label_size = input.string('normal', 'Text Size', options=['tiny', 'small', 'normal', 'large'])
show_asian_session = input.bool(defval=true, title="Show Asian Session Box")


show_london_session = input.bool(defval=true, title="Show London Session Box")
show_london_session_rng = input.bool(defval=true, title="Show London Session Range Pips")


london_ssth = input.string('03', 'London Start Hour (EST)', options=['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23'])
london_sstm = input.string('00', 'London Start Minute (EST)', options=['00', '15', '30', '45'])

london_esth = input.string('07', 'London End Hour (EST)', options=['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23'])
london_estm = input.string('00', 'London End Minute (EST)', options=['00', '15', '30', '45'])


luser_box_line_color = input.string('teal', 'London Range Border Color', options=['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 'silver', 'teal', 'white', 'yellow'])
lboxLineWidthInput = input.int(title="London Box Line Width", defval=1)
lboxLineWidth = clampInt(lboxLineWidthInput, 0, 10)
luser_box_line_style = input.string('solid', 'London Box Line Style', options=['solid', 'dashed', 'dotted'])

lsessionLineWidthInput = input.int(title="Session High / Low / Mid Line Width", defval=2)
lsessionLineWidth = clampInt(lsessionLineWidthInput, 0, 20)
luser_upperlower_line_style = input.string('dotted', 'Session High / Low Line Style', options=['solid', 'dashed', 'dotted'])

luser_midline_color = input.string('teal', 'Middle Range Line Color', options=['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 'silver', 'teal', 'white', 'yellow'])
luser_middle_line_style = input.string('dotted', 'Middle Range Line Style', options=['solid', 'dashed', 'dotted'])

luser_text_color = input.string('teal', 'Text Color', options=['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 'silver', 'teal', 'white', 'yellow'])
luser_label_size = input.string('normal', 'Text Size', options=['tiny', 'small', 'normal', 'large'])



show_ny_session = input.bool(defval=true, title="Show New York Session Box")
show_ny_session_rng = input.bool(defval=true, title="Show New York Session Range Pips")

ny_ssth = input.string('08', 'New York Start Hour (EST)', options=['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23'])
ny_sstm = input.string('00', 'New York Start Minute (EST)', options=['00', '15', '30', '45'])

ny_esth = input.string('12', 'New York End Hour (EST)', options=['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23'])
ny_estm = input.string('00', 'New York End Minute (EST)', options=['00', '15', '30', '45'])


nuser_box_line_color = input.string('silver', 'New York Range Border Color', options=['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 'silver', 'teal', 'white', 'yellow'])
nboxLineWidthInput = input.int(title="New York Box Line Width", defval=1)
nboxLineWidth = clampInt(nboxLineWidthInput, 0, 10)
nuser_box_line_style = input.string('solid', 'New York Box Line Style', options=['solid', 'dashed', 'dotted'])

nsessionLineWidthInput = input.int(title="Session High / Low / Mid Line Width", defval=2)
nsessionLineWidth = clampInt(nsessionLineWidthInput, 0, 20)
nuser_upperlower_line_style = input.string('dotted', 'Session High / Low Line Style', options=['solid', 'dashed', 'dotted'])

nuser_midline_color = input.string('silver', 'Middle Range Line Color', options=['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 'silver', 'teal', 'white', 'yellow'])
nuser_middle_line_style = input.string('dotted', 'Middle Range Line Style', options=['solid', 'dashed', 'dotted'])

nuser_text_color = input.string('silver', 'Text Color', options=['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 'silver', 'teal', 'white', 'yellow'])
nuser_label_size = input.string('normal', 'Text Size', options=['tiny', 'small', 'normal', 'large'])

showADR = input.bool(defval=true, title="Show Average Daily Range")
is_forex_pips = input.bool(defval=true, title="Display average range as forex pips?")
dailyAdrUserInput = input.int(defval=1, title="Show ADR for x days")
daily_adr_user = nonNegativeInt(dailyAdrUserInput)
dailyAdrLengthInput = input.int(defval=21, title="ADR Length parameter (Days - default 3 weeks, 21 days)")
daily_adr_length = nonNegativeInt(dailyAdrLengthInput)

showPreviousDayHiLo = input.bool(defval=true, title="Show Previous Days High / Low")
previousDayHiLoColor = input.string('yellow', 'Previous Days Line Color', options=['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 'silver', 'teal', 'white', 'yellow'])
supportLineWidthInput = input.int(title="Previous Days Line Width", defval=1)
supportLineWidth = clampInt(supportLineWidthInput, 0, 10)
previousDayHiLoLineStyle = input.string('dashed', 'Previous Days Line Style', options=['solid', 'dashed', 'dotted'])
showHiLoPriceRange = input.bool(defval=false, title="Show Previous Days Range")
showHiLoPriceLabel = input.bool(defval=false, title="Show Line Label (YH / YL)")


showLastWeeklyHiLo = input.bool(defval=true, title="Show Last Weeks High / Low")
lastWeeklyHiLoColor = input.string('orange', 'Last Week Line Color', options=['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 'silver', 'teal', 'white', 'yellow'])
supportLastWeekLineWidthInput = input.int(title="Last Week Line Width", defval=1)
supportLastWeekLineWidth = clampInt(supportLastWeekLineWidthInput, 0, 10)
lastWeeklyHiLoStyle = input.string('dashed', 'Last Week Line Style', options=['solid', 'dashed', 'dotted'])
lastWeeklyHiLoShowLabel = input.bool(defval=true, title="Show Line Label (PWH / PWL)")


showWeeklyHiLo = input.bool(defval=false, title="Show This Weeks High / Low")
weeklyHiLoColor = input.string('olive', 'This Weeks Line Color', options=['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 'silver', 'teal', 'white', 'yellow'])
supportWeekLineWidthInput = input.int(title="This Weeks Line Width", defval=1)
supportWeekLineWidth = clampInt(supportWeekLineWidthInput, 0, 10)
weeklyHiLoStyle = input.string('dashed', 'This Weeks Line Style', options=['solid', 'dashed', 'dotted'])
weeklyHiLoShowLabel = input.bool(defval=false, title="Show Line Label (WH / WL)")

showHiLoTime = input.bool(defval=false, title="Show Hi / Low Time of Day (Always Displays Eastern Standard Time)")





line_color = user_box_line_color == "aqua" ? color.aqua : user_box_line_color == "black" ? color.black : user_box_line_color == "blue" ? color.blue : user_box_line_color == "fuchsia" ? color.fuchsia : user_box_line_color == "gray" ? color.gray : user_box_line_color == "green" ? color.green : user_box_line_color == "lime" ? color.lime : user_box_line_color == "maroon" ? color.maroon : user_box_line_color == "navy" ? color.navy : user_box_line_color == "olive" ? color.olive : user_box_line_color == "orange" ? color.orange : user_box_line_color == "purple" ? color.purple : user_box_line_color == "red" ? color.red : user_box_line_color == "silver" ? color.silver : user_box_line_color == "teal" ? color.teal : user_box_line_color == "white" ? color.white : user_box_line_color == "yellow" ? color.yellow : color.black
midline_color = user_midline_color == "aqua" ? color.aqua : user_midline_color == "black" ? color.black : user_midline_color == "blue" ? color.blue : user_midline_color == "fuchsia" ? color.fuchsia : user_midline_color == "gray" ? color.gray : user_midline_color == "green" ? color.green : user_midline_color == "lime" ? color.lime : user_midline_color == "maroon" ? color.maroon : user_midline_color == "navy" ? color.navy : user_midline_color == "olive" ? color.olive : user_midline_color == "orange" ? color.orange : user_midline_color == "purple" ? color.purple : user_midline_color == "red" ? color.red : user_midline_color == "silver" ? color.silver : user_midline_color == "teal" ? color.teal : user_midline_color == "white" ? color.white : user_midline_color == "yellow" ? color.yellow : color.black
line_border_color = show_asian_session ? color.new(line_color, 100) : na
midline_border_color = show_asian_session ? color.new(midline_color, 100) : na
text_color = user_text_color == "aqua" ? color.aqua : user_text_color == "black" ? color.black : user_text_color == "blue" ? color.blue : user_text_color == "fuchsia" ? color.fuchsia : user_text_color == "gray" ? color.gray : user_text_color == "green" ? color.green : user_text_color == "lime" ? color.lime : user_text_color == "maroon" ? color.maroon : user_text_color == "navy" ? color.navy : user_text_color == "olive" ? color.olive : user_text_color == "orange" ? color.orange : user_text_color == "purple" ? color.purple : user_text_color == "red" ? color.red : user_text_color == "silver" ? color.silver : user_text_color == "teal" ? color.teal : user_text_color == "white" ? color.white : user_text_color == "yellow" ? color.yellow : color.black

box_line_style = user_box_line_style == "solid" ? line.style_solid : user_box_line_style == "dashed" ? line.style_dashed : user_box_line_style == "dotted" ? line.style_dotted : line.style_solid
upperlower_line_style = user_upperlower_line_style == "solid" ? line.style_solid : user_upperlower_line_style == "dashed" ? line.style_dashed : user_upperlower_line_style == "dotted" ? line.style_dotted : line.style_solid
middle_line_style = user_middle_line_style == "solid" ? line.style_solid : user_middle_line_style == "dashed" ? line.style_dashed : user_middle_line_style == "dotted" ? line.style_dotted : line.style_solid

labelsize = user_label_size == "tiny" ? size.tiny : user_label_size == "small" ? size.small : user_label_size == "normal" ? size.normal : user_label_size == "large" ? size.large : size.normal

lline_color = luser_box_line_color == "aqua" ? color.aqua : luser_box_line_color == "black" ? color.black : luser_box_line_color == "blue" ? color.blue : luser_box_line_color == "fuchsia" ? color.fuchsia : luser_box_line_color == "gray" ? color.gray : luser_box_line_color == "green" ? color.green : luser_box_line_color == "lime" ? color.lime : luser_box_line_color == "maroon" ? color.maroon : luser_box_line_color == "navy" ? color.navy : luser_box_line_color == "olive" ? color.olive : luser_box_line_color == "orange" ? color.orange : luser_box_line_color == "purple" ? color.purple : luser_box_line_color == "red" ? color.red : luser_box_line_color == "silver" ? color.silver : luser_box_line_color == "teal" ? color.teal : luser_box_line_color == "white" ? color.white : luser_box_line_color == "yellow" ? color.yellow : color.black
lmidline_color = luser_midline_color == "aqua" ? color.aqua : luser_midline_color == "black" ? color.black : luser_midline_color == "blue" ? color.blue : luser_midline_color == "fuchsia" ? color.fuchsia : luser_midline_color == "gray" ? color.gray : luser_midline_color == "green" ? color.green : luser_midline_color == "lime" ? color.lime : luser_midline_color == "maroon" ? color.maroon : luser_midline_color == "navy" ? color.navy : luser_midline_color == "olive" ? color.olive : luser_midline_color == "orange" ? color.orange : luser_midline_color == "purple" ? color.purple : luser_midline_color == "red" ? color.red : luser_midline_color == "silver" ? color.silver : luser_midline_color == "teal" ? color.teal : luser_midline_color == "white" ? color.white : luser_midline_color == "yellow" ? color.yellow : color.black
lline_border_color = show_london_session ? color.new(lline_color, 100) : na
lmidline_border_color = show_london_session ? color.new(lmidline_color, 100) : na
ltext_color = luser_text_color == "aqua" ? color.aqua : luser_text_color == "black" ? color.black : luser_text_color == "blue" ? color.blue : luser_text_color == "fuchsia" ? color.fuchsia : luser_text_color == "gray" ? color.gray : luser_text_color == "green" ? color.green : luser_text_color == "lime" ? color.lime : luser_text_color == "maroon" ? color.maroon : luser_text_color == "navy" ? color.navy : luser_text_color == "olive" ? color.olive : luser_text_color == "orange" ? color.orange : luser_text_color == "purple" ? color.purple : luser_text_color == "red" ? color.red : luser_text_color == "silver" ? color.silver : luser_text_color == "teal" ? color.teal : luser_text_color == "white" ? color.white : luser_text_color == "yellow" ? color.yellow : color.black

lbox_line_style = luser_box_line_style == "solid" ? line.style_solid : luser_box_line_style == "dashed" ? line.style_dashed : luser_box_line_style == "dotted" ? line.style_dotted : line.style_solid
lupperlower_line_style = luser_upperlower_line_style == "solid" ? line.style_solid : luser_upperlower_line_style == "dashed" ? line.style_dashed : luser_upperlower_line_style == "dotted" ? line.style_dotted : line.style_solid
lmiddle_line_style = luser_middle_line_style == "solid" ? line.style_solid : luser_middle_line_style == "dashed" ? line.style_dashed : luser_middle_line_style == "dotted" ? line.style_dotted : line.style_solid

llabelsize = luser_label_size == "tiny" ? size.tiny : luser_label_size == "small" ? size.small : luser_label_size == "normal" ? size.normal : luser_label_size == "large" ? size.large : size.normal

nline_color = nuser_box_line_color == "aqua" ? color.aqua : nuser_box_line_color == "black" ? color.black : nuser_box_line_color == "blue" ? color.blue : nuser_box_line_color == "fuchsia" ? color.fuchsia : nuser_box_line_color == "gray" ? color.gray : nuser_box_line_color == "green" ? color.green : nuser_box_line_color == "lime" ? color.lime : nuser_box_line_color == "maroon" ? color.maroon : nuser_box_line_color == "navy" ? color.navy : nuser_box_line_color == "olive" ? color.olive : nuser_box_line_color == "orange" ? color.orange : nuser_box_line_color == "purple" ? color.purple : nuser_box_line_color == "red" ? color.red : nuser_box_line_color == "silver" ? color.silver : nuser_box_line_color == "teal" ? color.teal : nuser_box_line_color == "white" ? color.white : nuser_box_line_color == "yellow" ? color.yellow : color.black
nmidline_color = nuser_midline_color == "aqua" ? color.aqua : nuser_midline_color == "black" ? color.black : nuser_midline_color == "blue" ? color.blue : nuser_midline_color == "fuchsia" ? color.fuchsia : nuser_midline_color == "gray" ? color.gray : nuser_midline_color == "green" ? color.green : nuser_midline_color == "lime" ? color.lime : nuser_midline_color == "maroon" ? color.maroon : nuser_midline_color == "navy" ? color.navy : nuser_midline_color == "olive" ? color.olive : nuser_midline_color == "orange" ? color.orange : nuser_midline_color == "purple" ? color.purple : nuser_midline_color == "red" ? color.red : nuser_midline_color == "silver" ? color.silver : nuser_midline_color == "teal" ? color.teal : nuser_midline_color == "white" ? color.white : nuser_midline_color == "yellow" ? color.yellow : color.black
nline_border_color = show_ny_session ? color.new(nline_color, 100) : na
nmidline_border_color = show_ny_session ? color.new(nmidline_color, 100) : na
ntext_color = nuser_text_color == "aqua" ? color.aqua : nuser_text_color == "black" ? color.black : nuser_text_color == "blue" ? color.blue : nuser_text_color == "fuchsia" ? color.fuchsia : nuser_text_color == "gray" ? color.gray : nuser_text_color == "green" ? color.green : nuser_text_color == "lime" ? color.lime : nuser_text_color == "maroon" ? color.maroon : nuser_text_color == "navy" ? color.navy : nuser_text_color == "olive" ? color.olive : nuser_text_color == "orange" ? color.orange : nuser_text_color == "purple" ? color.purple : nuser_text_color == "red" ? color.red : nuser_text_color == "silver" ? color.silver : nuser_text_color == "teal" ? color.teal : nuser_text_color == "white" ? color.white : nuser_text_color == "yellow" ? color.yellow : color.black

nbox_line_style = nuser_box_line_style == "solid" ? line.style_solid : nuser_box_line_style == "dashed" ? line.style_dashed : nuser_box_line_style == "dotted" ? line.style_dotted : line.style_solid
nupperlower_line_style = nuser_upperlower_line_style == "solid" ? line.style_solid : nuser_upperlower_line_style == "dashed" ? line.style_dashed : nuser_upperlower_line_style == "dotted" ? line.style_dotted : line.style_solid
nmiddle_line_style = nuser_middle_line_style == "solid" ? line.style_solid : nuser_middle_line_style == "dashed" ? line.style_dashed : nuser_middle_line_style == "dotted" ? line.style_dotted : line.style_solid

nlabelsize = nuser_label_size == "tiny" ? size.tiny : nuser_label_size == "small" ? size.small : nuser_label_size == "normal" ? size.normal : nuser_label_size == "large" ? size.large : size.normal

daily_adr = daily_adr_user
if dayofweek == dayofweek.sunday
    daily_adr := daily_adr + 1
if dayofweek == dayofweek.saturday
    daily_adr := daily_adr + 1

lblTP = 70

support_line_color = previousDayHiLoColor == "aqua" ? color.aqua : previousDayHiLoColor == "black" ? color.black : previousDayHiLoColor == "blue" ? color.blue : previousDayHiLoColor == "fuchsia" ? color.fuchsia : previousDayHiLoColor == "gray" ? color.gray : previousDayHiLoColor == "green" ? color.green : previousDayHiLoColor == "lime" ? color.lime : previousDayHiLoColor == "maroon" ? color.maroon : previousDayHiLoColor == "navy" ? color.navy : previousDayHiLoColor == "olive" ? color.olive : previousDayHiLoColor == "orange" ? color.orange : previousDayHiLoColor == "purple" ? color.purple : previousDayHiLoColor == "red" ? color.red : previousDayHiLoColor == "silver" ? color.silver : previousDayHiLoColor == "teal" ? color.teal : previousDayHiLoColor == "white" ? color.white : previousDayHiLoColor == "yellow" ? color.yellow : color.black
support_line_label_color = previousDayHiLoColor == "aqua" ? color.new(color.aqua,lblTP) : previousDayHiLoColor == "black" ? color.new(color.black,lblTP) : previousDayHiLoColor == "blue" ? color.new(color.blue,lblTP) : previousDayHiLoColor == "fuchsia" ? color.new(color.fuchsia,lblTP) : previousDayHiLoColor == "gray" ? color.new(color.gray,lblTP) : previousDayHiLoColor == "green" ? color.new(color.green,lblTP) : previousDayHiLoColor == "lime" ? color.new(color.lime,lblTP) : previousDayHiLoColor == "maroon" ? color.new(color.maroon,lblTP) : previousDayHiLoColor == "navy" ? color.new(color.navy,lblTP) : previousDayHiLoColor == "olive" ? color.new(color.olive,lblTP) : previousDayHiLoColor == "orange" ? color.new(color.orange,lblTP) : previousDayHiLoColor == "purple" ? color.new(color.purple,lblTP) : previousDayHiLoColor == "red" ? color.new(color.red,lblTP) : previousDayHiLoColor == "silver" ? color.new(color.silver,lblTP) : previousDayHiLoColor == "teal" ? color.new(color.teal,lblTP) : previousDayHiLoColor == "white" ? color.new(color.white,lblTP) : previousDayHiLoColor == "yellow" ? color.new(color.yellow,lblTP) : color.new(color.black,lblTP)

support_line_style = previousDayHiLoLineStyle == "solid" ? line.style_solid : previousDayHiLoLineStyle == "dashed" ? line.style_dashed : previousDayHiLoLineStyle == "dotted" ? line.style_dotted : line.style_solid


support_last_week_line_color = lastWeeklyHiLoColor == "aqua" ? color.aqua : lastWeeklyHiLoColor == "black" ? color.black : lastWeeklyHiLoColor == "blue" ? color.blue : lastWeeklyHiLoColor == "fuchsia" ? color.fuchsia : lastWeeklyHiLoColor == "gray" ? color.gray : lastWeeklyHiLoColor == "green" ? color.green : lastWeeklyHiLoColor == "lime" ? color.lime : lastWeeklyHiLoColor == "maroon" ? color.maroon : lastWeeklyHiLoColor == "navy" ? color.navy : lastWeeklyHiLoColor == "olive" ? color.olive : lastWeeklyHiLoColor == "orange" ? color.orange : lastWeeklyHiLoColor == "purple" ? color.purple : lastWeeklyHiLoColor == "red" ? color.red : lastWeeklyHiLoColor == "silver" ? color.silver : lastWeeklyHiLoColor == "teal" ? color.teal : lastWeeklyHiLoColor == "white" ? color.white : lastWeeklyHiLoColor == "yellow" ? color.yellow : color.black
support_last_week_line_label_color = lastWeeklyHiLoColor == "aqua" ? color.new(color.aqua,lblTP) : lastWeeklyHiLoColor == "black" ? color.new(color.black,lblTP) : lastWeeklyHiLoColor == "blue" ? color.new(color.blue,lblTP) : lastWeeklyHiLoColor == "fuchsia" ? color.new(color.fuchsia,lblTP) : lastWeeklyHiLoColor == "gray" ? color.new(color.gray,lblTP) : lastWeeklyHiLoColor == "green" ? color.new(color.green,lblTP) : lastWeeklyHiLoColor == "lime" ? color.new(color.lime,lblTP) : lastWeeklyHiLoColor == "maroon" ? color.new(color.maroon,lblTP) : lastWeeklyHiLoColor == "navy" ? color.new(color.navy,lblTP) : lastWeeklyHiLoColor == "olive" ? color.new(color.olive,lblTP) : lastWeeklyHiLoColor == "orange" ? color.new(color.orange,lblTP) : lastWeeklyHiLoColor == "purple" ? color.new(color.purple,lblTP) : lastWeeklyHiLoColor == "red" ? color.new(color.red,lblTP) : lastWeeklyHiLoColor == "silver" ? color.new(color.silver,lblTP) : lastWeeklyHiLoColor == "teal" ? color.new(color.teal,lblTP) : lastWeeklyHiLoColor == "white" ? color.new(color.white,lblTP) : lastWeeklyHiLoColor == "yellow" ? color.new(color.yellow,lblTP) : color.new(color.black,lblTP)

support_last_week_line_style = lastWeeklyHiLoStyle == "solid" ? line.style_solid : lastWeeklyHiLoStyle == "dashed" ? line.style_dashed : lastWeeklyHiLoStyle == "dotted" ? line.style_dotted : line.style_solid

wlineTP = 30
support_week_line_color = weeklyHiLoColor == "aqua" ? color.new(color.aqua,wlineTP) : weeklyHiLoColor == "black" ? color.new(color.black,wlineTP) : weeklyHiLoColor == "blue" ? color.new(color.blue,wlineTP) : weeklyHiLoColor == "fuchsia" ? color.new(color.fuchsia,wlineTP) : weeklyHiLoColor == "gray" ? color.new(color.gray,wlineTP) : weeklyHiLoColor == "green" ? color.new(color.green,wlineTP) : weeklyHiLoColor == "lime" ? color.new(color.lime,wlineTP) : weeklyHiLoColor == "maroon" ? color.new(color.maroon,wlineTP) : weeklyHiLoColor == "navy" ? color.new(color.navy,wlineTP) : weeklyHiLoColor == "olive" ? color.new(color.olive,wlineTP) : weeklyHiLoColor == "orange" ? color.new(color.orange,wlineTP) : weeklyHiLoColor == "purple" ? color.new(color.purple,wlineTP) : weeklyHiLoColor == "red" ? color.new(color.red,wlineTP) : weeklyHiLoColor == "silver" ? color.new(color.silver,wlineTP) : weeklyHiLoColor == "teal" ? color.new(color.teal,wlineTP) : weeklyHiLoColor == "white" ? color.new(color.white,wlineTP) : weeklyHiLoColor == "yellow" ? color.new(color.yellow,wlineTP) : color.new(color.black,wlineTP)
support_week_line_style = weeklyHiLoStyle == "solid" ? line.style_solid : weeklyHiLoStyle == "dashed" ? line.style_dashed : weeklyHiLoStyle == "dotted" ? line.style_dotted : line.style_solid



chart_time_period_int = timeframe.period == "1" ? 1 : timeframe.period == "3" ? 3 : timeframe.period == "5" ? 5 : timeframe.period == "15" ? 15 : timeframe.period == "30" ? 30 : timeframe.period == "45" ? 45 : 15
tickerExchangeOffset = 4

int start_session_hour_int = 0
int end_session_hour_int = 0
int end_line_hour_int = 0

start_session_hour_int := user_ssth == "00" ? 0 : user_ssth == "01" ? 1 : user_ssth == "02" ? 2 : user_ssth == "03" ? 3 : user_ssth == "04" ? 4 : user_ssth == "05" ? 5 : user_ssth == "06" ? 6 : user_ssth == "07" ? 7 : user_ssth == "08" ? 8 : user_ssth == "09" ? 9 : user_ssth == "10" ? 10 : user_ssth == "11" ? 11 : user_ssth == "12" ? 12 : user_ssth == "13" ? 13 : user_ssth == "14" ? 14 : user_ssth == "15" ? 15 : user_ssth == "16" ? 16 : user_ssth == "17" ? 17 : user_ssth == "18" ? 18 : user_ssth == "19" ? 19 : user_ssth == "20" ? 20 : user_ssth == "21" ? 21 : user_ssth == "22" ? 22 : user_ssth == "23" ? 23 : 0
start_session_minute_int = user_sstm == "00" ? 0 : user_sstm == "15" ? 15 : user_sstm == "30" ? 30 : user_sstm == "45" ? 45 : 0

end_session_hour_int := user_esth == "00" ? 0 : user_esth == "01" ? 1 : user_esth == "02" ? 2 : user_esth == "03" ? 3 : user_esth == "04" ? 4 : user_esth == "05" ? 5 : user_esth == "06" ? 6 : user_esth == "07" ? 7 : user_esth == "08" ? 8 : user_esth == "09" ? 9 : user_esth == "10" ? 10 : user_esth == "11" ? 11 : user_esth == "12" ? 12 : user_esth == "13" ? 13 : user_esth == "14" ? 14 : user_esth == "15" ? 15 : user_esth == "16" ? 16 : user_esth == "17" ? 17 : user_esth == "18" ? 18 : user_esth == "19" ? 19 : user_esth == "20" ? 20 : user_esth == "21" ? 21 : user_esth == "22" ? 22 : user_esth == "23" ? 23 : 0
end_session_minute_int = user_estm == "00" ? 0 : user_estm == "15" ? 15 : user_estm == "30" ? 30 : user_estm == "45" ? 45 : 0

end_line_hour_int := user_elth == "00" ? 0 : user_elth == "01" ? 1 : user_elth == "02" ? 2 : user_elth == "03" ? 3 : user_elth == "04" ? 4 : user_elth == "05" ? 5 : user_elth == "06" ? 6 : user_elth == "07" ? 7 : user_elth == "08" ? 8 : user_elth == "09" ? 9 : user_elth == "10" ? 10 : user_elth == "11" ? 11 : user_elth == "12" ? 12 : user_elth == "13" ? 13 : user_elth == "14" ? 14 : user_elth == "15" ? 15 : user_elth == "16" ? 16 : user_elth == "17" ? 17 : user_elth == "18" ? 18 : user_elth == "19" ? 19 : user_elth == "20" ? 20 : user_elth == "21" ? 21 : user_elth == "22" ? 22 : user_elth == "23" ? 23 : 0
end_line_minute_int = user_eltm == "00" ? 0 : user_eltm == "15" ? 15 : user_eltm == "30" ? 30 : user_eltm == "45" ? 45 : 0

end_session_minute_int_offset = (end_session_minute_int + chart_time_period_int)


int london_start_session_hour_int = 0
int london_end_session_hour_int = 0

london_start_session_hour_int := london_ssth == "00" ? 0 : london_ssth == "01" ? 1 : london_ssth == "02" ? 2 : london_ssth == "03" ? 3 : london_ssth == "04" ? 4 : london_ssth == "05" ? 5 : london_ssth == "06" ? 6 : london_ssth == "07" ? 7 : london_ssth == "08" ? 8 : london_ssth == "09" ? 9 : london_ssth == "10" ? 10 : london_ssth == "11" ? 11 : london_ssth == "12" ? 12 : london_ssth == "13" ? 13 : london_ssth == "14" ? 14 : london_ssth == "15" ? 15 : london_ssth == "16" ? 16 : london_ssth == "17" ? 17 : london_ssth == "18" ? 18 : london_ssth == "19" ? 19 : london_ssth == "20" ? 20 : london_ssth == "21" ? 21 : london_ssth == "22" ? 22 : london_ssth == "23" ? 23 : 0
london_start_session_minute_int = london_sstm == "00" ? 0 : london_sstm == "15" ? 15 : london_sstm == "30" ? 30 : london_sstm == "45" ? 45 : 0

london_end_session_hour_int := london_esth == "00" ? 0 : london_esth == "01" ? 1 : london_esth == "02" ? 2 : london_esth == "03" ? 3 : london_esth == "04" ? 4 : london_esth == "05" ? 5 : london_esth == "06" ? 6 : london_esth == "07" ? 7 : london_esth == "08" ? 8 : london_esth == "09" ? 9 : london_esth == "10" ? 10 : london_esth == "11" ? 11 : london_esth == "12" ? 12 : london_esth == "13" ? 13 : london_esth == "14" ? 14 : london_esth == "15" ? 15 : london_esth == "16" ? 16 : london_esth == "17" ? 17 : london_esth == "18" ? 18 : london_esth == "19" ? 19 : london_esth == "20" ? 20 : london_esth == "21" ? 21 : london_esth == "22" ? 22 : london_esth == "23" ? 23 : 0
london_end_session_minute_int = london_estm == "00" ? 0 : london_estm == "15" ? 15 : london_estm == "30" ? 30 : london_estm == "45" ? 45 : 0


london_end_session_minute_int_offset = (london_end_session_minute_int + chart_time_period_int)


isValidResolution() => not (timeframe.isdwm or timeframe.period == "120" or timeframe.period == "240" or timeframe.period == "180" or timeframe.period == "360")
isBelowHourValidResolution() => not (timeframe.isdwm or timeframe.period == "120" or timeframe.period == "240" or timeframe.period == "180" or timeframe.period == "360")


int ny_start_session_hour_int = 0
int ny_end_session_hour_int = 0

ny_start_session_hour_int := ny_ssth == "00" ? 0 : ny_ssth == "01" ? 1 : ny_ssth == "02" ? 2 : ny_ssth == "03" ? 3 : ny_ssth == "04" ? 4 : ny_ssth == "05" ? 5 : ny_ssth == "06" ? 6 : ny_ssth == "07" ? 7 : ny_ssth == "08" ? 8 : ny_ssth == "09" ? 9 : ny_ssth == "10" ? 10 : ny_ssth == "11" ? 11 : ny_ssth == "12" ? 12 : ny_ssth == "13" ? 13 : ny_ssth == "14" ? 14 : ny_ssth == "15" ? 15 : ny_ssth == "16" ? 16 : ny_ssth == "17" ? 17 : ny_ssth == "18" ? 18 : ny_ssth == "19" ? 19 : ny_ssth == "20" ? 20 : ny_ssth == "21" ? 21 : ny_ssth == "22" ? 22 : ny_ssth == "23" ? 23 : 0
ny_start_session_minute_int = ny_sstm == "00" ? 0 : ny_sstm == "15" ? 15 : ny_sstm == "30" ? 30 : ny_sstm == "45" ? 45 : 0

ny_end_session_hour_int := ny_esth == "00" ? 0 : ny_esth == "01" ? 1 : ny_esth == "02" ? 2 : ny_esth == "03" ? 3 : ny_esth == "04" ? 4 : ny_esth == "05" ? 5 : ny_esth == "06" ? 6 : ny_esth == "07" ? 7 : ny_esth == "08" ? 8 : ny_esth == "09" ? 9 : ny_esth == "10" ? 10 : ny_esth == "11" ? 11 : ny_esth == "12" ? 12 : ny_esth == "13" ? 13 : ny_esth == "14" ? 14 : ny_esth == "15" ? 15 : ny_esth == "16" ? 16 : ny_esth == "17" ? 17 : ny_esth == "18" ? 18 : ny_esth == "19" ? 19 : ny_esth == "20" ? 20 : ny_esth == "21" ? 21 : ny_esth == "22" ? 22 : ny_esth == "23" ? 23 : 0
ny_end_session_minute_int = ny_estm == "00" ? 0 : ny_estm == "15" ? 15 : ny_estm == "30" ? 30 : ny_estm == "45" ? 45 : 0


ny_end_session_minute_int_offset = (ny_end_session_minute_int + chart_time_period_int)



start_support_hour_int = 17
start_support_minute_int = 0
end_support_hour_int = 17
end_support_minute_int = 0

if (syminfo.timezone == "Etc/UTC")
    start_session_hour_int := start_session_hour_int + tickerExchangeOffset
    end_session_hour_int := end_session_hour_int + tickerExchangeOffset
    end_line_hour_int := end_line_hour_int + tickerExchangeOffset

    london_start_session_hour_int := london_start_session_hour_int + tickerExchangeOffset
    london_end_session_hour_int := london_end_session_hour_int + tickerExchangeOffset

    ny_start_session_hour_int := ny_start_session_hour_int + tickerExchangeOffset
    ny_end_session_hour_int := ny_end_session_hour_int + tickerExchangeOffset

    start_support_hour_int := start_support_hour_int + tickerExchangeOffset
    end_support_hour_int := end_support_hour_int + tickerExchangeOffset

    if (start_session_hour_int >= 24)
        if (start_session_hour_int == 24)
            user_ssth := "00"
        else
            user_ssth := "0" + str.tostring(start_session_hour_int - 24)
    else
        if (start_session_hour_int < 10)
            user_ssth := "0" + str.tostring(start_session_hour_int)
        else
            user_ssth := str.tostring(start_session_hour_int)


    if (end_session_hour_int >= 24)
        if (end_session_hour_int == 24)
            user_esth := "00"
        else
            user_esth := "0" + str.tostring(end_session_hour_int - 24)
    else
        if (end_session_hour_int < 10)
            user_esth := "0" + str.tostring(end_session_hour_int)
        else
            user_esth := str.tostring(end_session_hour_int)


    if (london_start_session_hour_int >= 24)
        if (london_start_session_hour_int == 24)
            london_ssth := "00"
        else
            london_ssth := "0" + str.tostring(london_start_session_hour_int - 24)
    else
        if (london_start_session_hour_int < 10)
            london_ssth := "0" + str.tostring(london_start_session_hour_int)
        else
            london_ssth := str.tostring(london_start_session_hour_int)


    if (london_end_session_hour_int >= 24)
        if (london_end_session_hour_int == 24)
            london_esth := "00"
        else
            london_esth := "0" + str.tostring(london_end_session_hour_int - 24)
    else
        if (london_end_session_hour_int < 10)
            london_esth := "0" + str.tostring(london_end_session_hour_int)
        else
            london_esth := str.tostring(london_end_session_hour_int)


    if (ny_start_session_hour_int >= 24)
        if (ny_start_session_hour_int == 24)
            ny_ssth := "00"
        else
            ny_ssth := "0" + str.tostring(ny_start_session_hour_int - 24)
    else
        if (ny_start_session_hour_int < 10)
            ny_ssth := "0" + str.tostring(ny_start_session_hour_int)
        else
            ny_ssth := str.tostring(ny_start_session_hour_int)


    if (ny_end_session_hour_int >= 24)
        if (ny_end_session_hour_int == 24)
            ny_esth := "00"
        else
            ny_esth := "0" + str.tostring(ny_end_session_hour_int - 24)
    else
        if (ny_end_session_hour_int < 10)
            ny_esth := "0" + str.tostring(ny_end_session_hour_int)
        else
            ny_esth := str.tostring(ny_end_session_hour_int)



trd_ses = (user_esth) + (user_estm) + "-" + (ny_esth) + (ny_estm)
rth_ses = ""
london_rth_ses = ""
ny_rth_ses = ""

rth_fill_ses = ""
london_rth_fill_ses = ""
ny_rth_fill_ses = ""

rth_ses := (user_ssth) + (user_sstm) + "-" + (user_esth) + user_estm
london_rth_ses := (london_ssth) + (london_sstm) + "-" + (london_esth) +  london_estm
ny_rth_ses := (ny_ssth) + (ny_sstm) + "-" + (ny_esth) + ny_estm

if (timeframe.period == "5" or timeframe.period == "3" or timeframe.period == "1") and end_session_minute_int == 0
    rth_fill_ses := (user_ssth) + (user_sstm) + "-" + (user_esth) + "0" + str.tostring(end_session_minute_int_offset)
else
    rth_fill_ses := (user_ssth) + (user_sstm) + "-" + (user_esth) + str.tostring(end_session_minute_int_offset)

if (timeframe.period == "5" or timeframe.period == "3" or timeframe.period == "1")  and london_end_session_minute_int == 0
    london_rth_fill_ses := (london_ssth) + (london_sstm) + "-" + (london_esth) +  "0" + str.tostring(london_end_session_minute_int_offset)
else
    london_rth_fill_ses := (london_ssth) + (london_sstm) + "-" + (london_esth) + str.tostring(london_end_session_minute_int_offset)


if (timeframe.period == "5" or timeframe.period == "3" or timeframe.period == "1")  and ny_end_session_minute_int == 0
    ny_rth_fill_ses := (ny_ssth) + (ny_sstm) + "-" + (ny_esth) + "0" + str.tostring(ny_end_session_minute_int_offset)
else
    ny_rth_fill_ses := (ny_ssth) + (ny_sstm) + "-" + (ny_esth) + str.tostring(ny_end_session_minute_int_offset)



open_bar(ses) =>
    t = time("D", ses)
    na(t[1]) and not na(t) or t[1] < t

is_open(ses) =>
    not na(time(timeframe.period, ses))


is_end_day() =>
    hour == 16 and minute == 45 ? true : false

is_new_day() =>
    syminfo.timezone == "Etc/UTC" and hour == 0 and minute == 0 ? true : syminfo.timezone != "Etc/UTC" and hour == 20 and minute == 0 ? true : false


get_label_offset(session) =>
    (timeframe.period == "1") ? time[180] : (timeframe.period == "3") ? time[60] : (timeframe.period == "5") ? time[36] : (timeframe.period == "15") ? time[12] : (timeframe.period == "60") ? time[3] : time[12]

is_new_day_switch_period() =>
    (hour >= 20 and minute == 0) and (hour <= 23 and minute <= 59) ? true: false


timerange(res, sess) => not na(time(res, sess))


adr(length) =>
    barRange = high - low
    ta.sma(barRange[1], length)
to_pips(val) =>
    is_forex_pips ? math.round(val/syminfo.mintick/10) : math.round(val/syminfo.mintick)


day_adr = request.security(syminfo.tickerid, 'D', adr(daily_adr_length), lookahead=barmerge.lookahead_on)
one_day = 1000 * 60 * 60 * 24


srcHi = high
srcLo = low

var session_hi = 10e-10
var session_lo = 10e10

startTimeDelta = 24 - start_session_hour_int + 1
endTimeDelta = 24 - start_session_hour_int + 1

startTimeAlignment() => (hour + startTimeDelta) > 24? 0 : 1


isStartTimeAlignment = startTimeAlignment()

endBoxTimeAlignment() => start_session_hour_int >= end_session_hour_int and (hour + startTimeDelta) > 24? 1 : start_session_hour_int >= end_session_hour_int and (hour + startTimeDelta) <= 24? 0 : start_session_hour_int < end_session_hour_int and (hour + startTimeDelta) > 24? 0 : -1
isEndBoxTimeAlignment = endBoxTimeAlignment()


endTimeAlignment() => start_session_hour_int >= end_session_hour_int and (hour + startTimeDelta) > 24? 1 : start_session_hour_int >= end_session_hour_int and (hour + startTimeDelta) <= 24? 0 : start_session_hour_int < end_session_hour_int and isEndBoxTimeAlignment == 0? 1 : start_session_hour_int < end_session_hour_int and (hour + endTimeDelta) > 24? -1 : 0

isEndTimeAlignment = endTimeAlignment()

FromDate = timestamp(year, month, dayofmonth - isStartTimeAlignment, start_session_hour_int, start_session_minute_int)
ToDate = timestamp(year, month, dayofmonth + isEndBoxTimeAlignment, end_session_hour_int, end_session_minute_int) - chart_time_period_int

LineFromDate = timestamp(year, month, dayofmonth + isEndBoxTimeAlignment, end_session_hour_int, end_session_minute_int) - chart_time_period_int
LineToDate = timestamp(year, month, dayofmonth + isEndTimeAlignment, end_line_hour_int, end_line_minute_int)

session_hi := ta.change(FromDate) != 0 ? srcHi : math.max(srcHi, session_hi)
session_lo := ta.change(FromDate) != 0 ? srcLo : math.min(srcLo, session_lo)

inSession = not na(time(timeframe.period, rth_ses))

rth_open_bar = open_bar(rth_ses)
rth_is_open = is_open(rth_ses)
rth_low = float(na)
rth_low := rth_is_open ? rth_open_bar ? low : math.min(rth_low[1], low) : rth_low[1]
rth_high = float(na)
rth_high := rth_is_open ? rth_open_bar ? high : math.max(rth_high[1], high) : rth_high[1]
rth_mid = (rth_low + rth_high) / 2

float sessionRange = na
var label sessionRangeLabel = na
bool showAsianRange = show_asian_session and isBelowHourValidResolution()

if showAsianRange
    trl = line.new(FromDate, rth_low, ToDate, rth_low, xloc=xloc.bar_time, color=line_border_color, style=box_line_style, width = boxLineWidth)
    line.delete(trl[1])

    trh = line.new(FromDate, rth_high, ToDate, rth_high, xloc=xloc.bar_time, color=line_border_color, style=box_line_style, width = boxLineWidth)
    line.delete(trh[1])

    trm = line.new(FromDate, rth_mid, ToDate, rth_mid, xloc=xloc.bar_time, color=midline_border_color, style=middle_line_style, width = sessionLineWidth)
    line.delete(trm[1])

    startBox = line.new(FromDate, rth_high, FromDate, rth_low, extend=extend.none, xloc=xloc.bar_time, color=line_border_color, style=box_line_style, width=boxLineWidth)
    line.delete(startBox[1])

    endBox = line.new(ToDate, rth_high, ToDate, rth_low, extend=extend.none, xloc=xloc.bar_time, color=line_border_color, style=box_line_style, width=boxLineWidth)
    line.delete(endBox[1])


    tl = line.new(LineFromDate, rth_low, LineToDate, rth_low, xloc=xloc.bar_time, color=line_border_color, style=upperlower_line_style, width = sessionLineWidth)
    line.delete(tl[1])

    th = line.new(LineFromDate, rth_high, LineToDate, rth_high, xloc=xloc.bar_time, color=line_border_color, style=upperlower_line_style, width = sessionLineWidth)
    line.delete(th[1])

    tm = line.new(LineFromDate, rth_mid, LineToDate, rth_mid, xloc=xloc.bar_time, color=midline_border_color, style=middle_line_style, width = sessionLineWidth)
    line.delete(tm[1])


highRes = rth_high
lowRes = rth_low

lineColor = color.new(color.white,100)

openRangeHigh = plot(timerange(timeframe.period, rth_fill_ses) and showAsianRange ? highRes : na, color=lineColor, style=plot.style_line, linewidth=1,  show_last=5, editable=false)
openRangeLow = plot(timerange(timeframe.period, rth_fill_ses) and showAsianRange ? lowRes : na, color=lineColor, style=plot.style_line, linewidth=1,  show_last=5, editable=false)
bgcolor(timerange(timeframe.period, rth_ses) and showAsianRange ? color.new(color.silver, 100) : na, title="Asian Session Background Color")


fill(openRangeHigh, openRangeLow, color=showAsianRange ? color.new(color.blue, 90) : na, title="Fill Asian Range Color")

if (not inSession and inSession[1] and showAsianRange)
    sessionRange := ((rth_high[1]-rth_low[1])/(syminfo.mintick))/10
    labelTime = get_label_offset(inSession)

    label.delete(sessionRangeLabel)
    if ((timeframe.isintraday or timeframe.isdaily) and showADR and (timenow - time) < (one_day * daily_adr))
        sessionRangeLabel := label.new(labelTime, rth_low[1], "A = " + str.tostring(sessionRange) + "\nADR = " + str.tostring(to_pips(day_adr)), xloc.bar_time, yloc.price, color.new(color.black,100), label.style_label_up, color.new(text_color, 100), labelsize)
    else
        sessionRangeLabel := label.new(labelTime, rth_low[1], "A = " + str.tostring(sessionRange), xloc.bar_time, yloc.price, color.new(color.black,100), label.style_label_up, color.new(text_color, 100), labelsize)

if not showAsianRange and not na(sessionRangeLabel)
    label.delete(sessionRangeLabel)
    sessionRangeLabel := na


var london_hi = 10e-10
var london_lo = 10e10

londonStartTimeDelta = 24 - london_start_session_hour_int + 1
londonEndTimeDelta = 24 - london_end_session_hour_int + 1

startLondonTimeAlignment() => (hour + londonStartTimeDelta) > 24? 0 : 1
isLondonStartTimeAlignment = startLondonTimeAlignment()


endLondonTimeAlignment() => (hour) >= (london_start_session_hour_int) and isLondonStartTimeAlignment == 0? 0 : 1
isLondonEndTimeAlignment = endLondonTimeAlignment()

float london_range = na
var label londonRangeLabel = na

LondonFromDate = timestamp(year, month, dayofmonth - isLondonStartTimeAlignment, london_start_session_hour_int, london_start_session_minute_int)
LondonToDate = timestamp(year, month, dayofmonth - isLondonEndTimeAlignment, london_end_session_hour_int, london_end_session_minute_int) - chart_time_period_int


london_hi := ta.change(LondonFromDate) != 0 ? srcHi : math.max(srcHi, london_hi)
london_lo := ta.change(LondonFromDate) != 0 ? srcLo : math.min(srcLo, london_lo)

inLondonSession = not na(time(timeframe.period, london_rth_ses))

london_rth_open_bar = open_bar(london_rth_ses)
london_rth_is_open = is_open(london_rth_ses)
london_rth_low = float(na)
london_rth_low := london_rth_is_open ? london_rth_open_bar ? low : math.min(london_rth_low[1], low) : london_rth_low[1]
london_rth_high = float(na)
london_rth_high := london_rth_is_open ? london_rth_open_bar ? high : math.max(london_rth_high[1], high) : london_rth_high[1]
london_rth_mid = (london_rth_low + london_rth_high) / 2

if (show_london_session and isValidResolution())

    ltrl = line.new(LondonFromDate, london_rth_low, LondonToDate, london_rth_low, xloc=xloc.bar_time, color=lline_border_color, style=lbox_line_style, width = lboxLineWidth)
    line.delete(ltrl[1])

    ltrh = line.new(LondonFromDate, london_rth_high, LondonToDate, london_rth_high, xloc=xloc.bar_time, color=lline_border_color, style=lbox_line_style, width = lboxLineWidth)
    line.delete(ltrh[1])

    ltrm = line.new(LondonFromDate, london_rth_mid, LondonToDate, london_rth_mid, xloc=xloc.bar_time, color=lmidline_border_color, style=lmiddle_line_style, width = lsessionLineWidth)
    line.delete(ltrm[1])

    londonStartBox = line.new(LondonFromDate, london_rth_high, LondonFromDate, london_rth_low, extend=extend.none, xloc=xloc.bar_time, color=lline_border_color, style=lbox_line_style, width=lboxLineWidth)
    line.delete(londonStartBox[1])

    londonEndBox = line.new(LondonToDate, london_rth_high, LondonToDate, london_rth_low, extend=extend.none, xloc=xloc.bar_time, color=lline_border_color, style=lbox_line_style, width=lboxLineWidth)
    line.delete(londonEndBox[1])






londonHighRes = london_rth_high
londonLowRes = london_rth_low

LondonLineColor = color.new(color.white,100)

londonOpenRangeHigh = plot(timerange(timeframe.period, london_rth_fill_ses) and show_london_session and isBelowHourValidResolution() ? londonHighRes : na, color=LondonLineColor, style=plot.style_line, linewidth=1,  show_last=5, editable=false)
londonOpenRangeLow = plot(timerange(timeframe.period, london_rth_fill_ses) and show_london_session and isBelowHourValidResolution() ? londonLowRes : na, color=LondonLineColor, style=plot.style_line, linewidth=1,  show_last=5, editable=false)
bgcolor(timerange(timeframe.period, london_rth_fill_ses) and show_london_session and isBelowHourValidResolution() ? color.new(color.silver, 100) : na, title="London Session Background Color")
fill(londonOpenRangeHigh, londonOpenRangeLow, color=show_london_session and isBelowHourValidResolution() ? color.new(color.teal, 90) : na, title="Fill London Range Color")

if show_london_session_rng and not inLondonSession and inLondonSession[1] and isBelowHourValidResolution()
    london_range := ((london_rth_high[1]-london_rth_low[1])/(syminfo.mintick))/10
    londonLabelTime = get_label_offset(inLondonSession)

    label.delete(londonRangeLabel)
    londonRangeLabel := label.new(londonLabelTime, london_rth_low[1], "L = " + str.tostring(london_range), xloc.bar_time, yloc.price, color.new(color.black,100), label.style_label_up, ltext_color, llabelsize)



var ny_hi = 10e-10
var ny_lo = 10e10

nyStartTimeDelta = 24 - ny_start_session_hour_int + 1
nyEndTimeDelta = 24 - ny_end_session_hour_int + 1

startNyTimeAlignment() => (hour + nyStartTimeDelta) > 24? 0 : 1
isNyStartTimeAlignment = startNyTimeAlignment()


endNyTimeAlignment() => (hour) >= (ny_start_session_hour_int)  and isNyStartTimeAlignment == 0? 0 : 1
isNyEndTimeAlignment = endNyTimeAlignment()


float ny_range = na
var label nyRangeLabel = na

NyFromDate = timestamp(year, month, dayofmonth - isNyStartTimeAlignment, ny_start_session_hour_int, ny_start_session_minute_int)
NyToDate = timestamp(year, month, dayofmonth - isNyEndTimeAlignment, ny_end_session_hour_int, ny_end_session_minute_int) - chart_time_period_int


ny_hi := ta.change(NyFromDate) != 0 ? srcHi : math.max(srcHi, ny_hi)
ny_lo := ta.change(NyFromDate) != 0 ? srcLo : math.min(srcLo, ny_lo)

inNySession = not na(time(timeframe.period, ny_rth_ses))

ny_rth_open_bar = open_bar(ny_rth_ses)
ny_rth_is_open = is_open(ny_rth_ses)
ny_rth_low = float(na)
ny_rth_low := ny_rth_is_open ? ny_rth_open_bar ? low : math.min(ny_rth_low[1], low) : ny_rth_low[1]
ny_rth_high = float(na)
ny_rth_high := ny_rth_is_open ? ny_rth_open_bar ? high : math.max(ny_rth_high[1], high) : ny_rth_high[1]
ny_rth_mid = (ny_rth_low + ny_rth_high) / 2

if (show_ny_session and isValidResolution())

    ntrl = line.new(NyFromDate, ny_rth_low, NyToDate, ny_rth_low, xloc=xloc.bar_time, color=nline_border_color, style=nbox_line_style, width = nboxLineWidth)
    line.delete(ntrl[1])

    ntrh = line.new(NyFromDate, ny_rth_high, NyToDate, ny_rth_high, xloc=xloc.bar_time, color=nline_border_color, style=nbox_line_style, width = nboxLineWidth)
    line.delete(ntrh[1])

    ntrm = line.new(NyFromDate, ny_rth_mid, NyToDate, ny_rth_mid, xloc=xloc.bar_time, color=nmidline_border_color, style=nmiddle_line_style, width = nsessionLineWidth)
    line.delete(ntrm[1])

    nyStartBox = line.new(NyFromDate, ny_rth_high, NyFromDate, ny_rth_low, extend=extend.none, xloc=xloc.bar_time, color=nline_border_color, style=nbox_line_style, width=nboxLineWidth)
    line.delete(nyStartBox[1])

    nyEndBox = line.new(NyToDate, ny_rth_high, NyToDate, ny_rth_low, extend=extend.none, xloc=xloc.bar_time, color=nline_border_color, style=nbox_line_style, width=nboxLineWidth)
    line.delete(nyEndBox[1])






nyHighRes = ny_rth_high
nyLowRes = ny_rth_low

NyLineColor = color.new(color.white,100)

nyOpenRangeHigh = plot(timerange(timeframe.period, ny_rth_fill_ses) and show_ny_session and isBelowHourValidResolution() ? nyHighRes : na, color=NyLineColor, style=plot.style_line, linewidth=1,  show_last=5, editable=false)
nyOpenRangeLow = plot(timerange(timeframe.period, ny_rth_fill_ses) and show_ny_session and isBelowHourValidResolution() ? nyLowRes : na, color=NyLineColor, style=plot.style_line, linewidth=1,  show_last=5, editable=false)
bgcolor(timerange(timeframe.period, ny_rth_fill_ses) and show_ny_session and isBelowHourValidResolution() ? color.new(color.silver, 100) : na, title="New York Session Background Color")
fill(nyOpenRangeHigh, nyOpenRangeLow, color=show_ny_session and isBelowHourValidResolution() ? color.new(color.silver, 90) : na, title="Fill New York Range Color")

if show_ny_session_rng and not inNySession and inNySession[1] and isBelowHourValidResolution()
    ny_range := ((ny_rth_high[1]-ny_rth_low[1])/(syminfo.mintick))/10
    nyLabelTime = get_label_offset(inNySession)

    label.delete(nyRangeLabel)
    nyRangeLabel := label.new(nyLabelTime, ny_rth_low[1], "N = " + str.tostring(ny_range), xloc.bar_time, yloc.price, color.new(color.black,100), label.style_label_up, ntext_color, nlabelsize)




getData(r, s) => request.security(syminfo.tickerid, r, s, barmerge.gaps_off, barmerge.lookahead_on)

pdh = getData('D', high[1])
pdl = getData('D', low[1])

wh = getData('1W', high[0])
wl = getData('1W', low[0])

lwh = getData('1W', high[1])
lwl = getData('1W', low[1])

float pdh_label_price = na
float pdl_label_price = na
int checkSwitch = 1

if (is_new_day_switch_period())
    pdh_label_price := getData('D', high[1])
    pdl_label_price := getData('D', low[1])
    checkSwitch := 0
else
    pdh_label_price := getData('D', high[0])
    pdl_label_price := getData('D', low[0])
    checkSwitch := 1



supportStartTimeDelta = 24 - start_session_hour_int + 1
supportEndTimeDelta = 24 - start_session_hour_int + 1

supportStartTimeAlignment() => (hour + supportStartTimeDelta) > 24? 0 : 1
isSupportStartTimeAlignment = supportStartTimeAlignment()

supportEndTimeAlignment() => (hour + supportEndTimeDelta) > 24? 1 : 0
isSupportEndTimeAlignment = supportEndTimeAlignment()



SupportFromStartWeekDate = timestamp(year, month, dayofmonth - isSupportStartTimeAlignment, start_support_hour_int, start_support_minute_int)
SupportFromDate = timestamp(year, month, dayofmonth - isSupportStartTimeAlignment, start_support_hour_int, start_support_minute_int)
SupportToDate = timestamp(year, month, dayofmonth + isSupportEndTimeAlignment, end_support_hour_int, end_support_minute_int) - chart_time_period_int

if (showPreviousDayHiLo and isBelowHourValidResolution())



    yesterdayHighLine = line.new(SupportFromDate, pdh, SupportToDate, pdh, xloc=xloc.bar_time, extend=extend.none, color=support_line_color, style=support_line_style, width = supportLineWidth)
    line.delete(yesterdayHighLine[1])

    yesterdayLowLine = line.new(SupportFromDate, pdl, SupportToDate, pdl, xloc=xloc.bar_time, extend=extend.none, color=support_line_color, style=support_line_style, width = supportLineWidth)
    line.delete(yesterdayLowLine[1])


    pdCheckIsNewDay = is_new_day()
    if (showHiLoPriceRange and pdCheckIsNewDay)

        if (showHiLoPriceLabel)
            label pdHi_label = label.new(time - (time-time[1])*15, pdh_label_price, "YH (" + str.tostring(((pdh_label_price-pdl_label_price)/(syminfo.mintick))/10) + ")", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_line_label_color, nlabelsize)
            label.delete(pdHi_label[1])

            label pdLow_label = label.new(time - (time-time[1])*14, pdl_label_price, "YL", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_line_label_color, nlabelsize)
            label.delete(pdLow_label[1])
        else
            label pdHi_label = label.new(time - (time-time[1])*15, pdh_label_price, str.tostring(((pdh_label_price-pdl_label_price)/(syminfo.mintick))/10), xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_line_label_color, nlabelsize)
            label.delete(pdHi_label[1])



    if (showHiLoPriceLabel and not showHiLoPriceRange and pdCheckIsNewDay)

        label pdHi_label = label.new(time - (time-time[1])*14, pdh_label_price, "YH", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_line_label_color, nlabelsize)
        label.delete(pdHi_label[1])

        label pdLow_label = label.new(time - (time-time[1])*14, pdl_label_price, "YL", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_line_label_color, nlabelsize)
        label.delete(pdLow_label[1])

if (showWeeklyHiLo and isBelowHourValidResolution())

    weekHighLine = line.new(SupportFromStartWeekDate, wh, SupportToDate, wh, xloc=xloc.bar_time, extend=extend.none, color=support_week_line_color, style=support_line_style, width = supportLineWidth)
    line.delete(weekHighLine[1])

    weekLowLine = line.new(SupportFromStartWeekDate, wl, SupportToDate, wl, xloc=xloc.bar_time, extend=extend.none, color=support_week_line_color, style=support_line_style, width = supportLineWidth)
    line.delete(weekLowLine[1])

    if (weeklyHiLoShowLabel and is_new_day())

        label wkHi_label = label.new(time - (time-time[1])*14, wh, "WH", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_week_line_color, nlabelsize)
        label.delete(wkHi_label[1])

        label wkLow_label = label.new(time - (time-time[1])*14, wl, "WL", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_week_line_color, nlabelsize)
        label.delete(wkLow_label[1])

var label lwkLow_label = na

if (showLastWeeklyHiLo and isBelowHourValidResolution())

    weekLastHighLine = line.new(SupportFromStartWeekDate, lwh, SupportToDate, lwh, xloc=xloc.bar_time, extend=extend.none, color=support_last_week_line_color, style=support_last_week_line_style, width = supportLastWeekLineWidth)
    line.delete(weekLastHighLine[1])

    weekLastLowLine = line.new(SupportFromStartWeekDate, lwl, SupportToDate, lwl, xloc=xloc.bar_time, extend=extend.none, color=support_last_week_line_color, style=support_last_week_line_style, width = supportLastWeekLineWidth)
    line.delete(weekLastLowLine[1])

    if (lastWeeklyHiLoShowLabel and is_new_day())

        label lwkHi_label = label.new(time - (time-time[1])*14, lwh, "PWH", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_last_week_line_label_color, nlabelsize)
        label.delete(lwkHi_label[1])

        lwkLow_label := label.new(time - (time-time[1])*14, lwl, "PWL", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_none, support_last_week_line_label_color, nlabelsize)
        label.delete(lwkLow_label[1])

utSrTolerance() => math.max(math.max(syminfo.mintick, 1e-10) * 2.0, 1e-10)
utSrMatches(value, reference) => not na(value) and not na(reference) and math.abs(value - reference) <= utSrTolerance()

utSrConflicts(value) =>
    conflict = false
    if showPreviousDayHiLo and isBelowHourValidResolution()
        conflict := conflict or utSrMatches(value, pdh) or utSrMatches(value, pdl)
    if showWeeklyHiLo and isBelowHourValidResolution()
        conflict := conflict or utSrMatches(value, wh) or utSrMatches(value, wl)
    if showLastWeeklyHiLo and isBelowHourValidResolution()
        conflict := conflict or utSrMatches(value, lwh) or utSrMatches(value, lwl)
    conflict

bool utSrVisible = utModuleActive and utShowSrInput

plot(utSrVisible and not utSrConflicts(utH1000) ? utH1000 : na, title='UT R1', color=close > utH1000 ? color.green : color.red, linewidth=1, offset=-9999, trackprice=true)
plot(utSrVisible and not utSrConflicts(utH750) ? utH750 : na, title='UT R2', color=close > utH750 ? color.green : color.red, linewidth=1, offset=-9999, trackprice=true)
plot(utSrVisible and not utSrConflicts(utH500) ? utH500 : na, title='UT R3', color=close > utH500 ? color.green : color.red, linewidth=1, offset=-9999, trackprice=true)
plot(utSrVisible and not utSrConflicts(utH250) ? utH250 : na, title='UT R4', color=close > utH250 ? color.green : color.red, linewidth=1, offset=-9999, trackprice=true)
plot(utSrVisible and not utSrConflicts(utH100) ? utH100 : na, title='UT R5', color=close > utH100 ? color.green : color.red, linewidth=1, offset=-9999, trackprice=true)
plot(utSrVisible and not utSrConflicts(utH50) ? utH50 : na, title='UT R6', color=close > utH50 ? color.green : color.red, linewidth=1, offset=-9999, trackprice=true)
plot(utSrVisible and not utSrConflicts(utH10) ? utH10 : na, title='UT R7', color=close > utH10 ? color.green : color.red, linewidth=1, offset=-9999, trackprice=true)
plot(utSrVisible and not utSrConflicts(utL1000) ? utL1000 : na, title='UT S1', color=close > utL1000 ? color.green : color.red, linewidth=1, offset=-9999, trackprice=true)
plot(utSrVisible and not utSrConflicts(utL750) ? utL750 : na, title='UT S2', color=close > utL750 ? color.green : color.red, linewidth=1, offset=-9999, trackprice=true)
plot(utSrVisible and not utSrConflicts(utL500) ? utL500 : na, title='UT S3', color=close > utL500 ? color.green : color.red, linewidth=1, offset=-9999, trackprice=true)
plot(utSrVisible and not utSrConflicts(utL250) ? utL250 : na, title='UT S4', color=close > utL250 ? color.green : color.red, linewidth=1, offset=-9999, trackprice=true)
plot(utSrVisible and not utSrConflicts(utL100) ? utL100 : na, title='UT S5', color=close > utL100 ? color.green : color.red, linewidth=1, offset=-9999, trackprice=true)
plot(utSrVisible and not utSrConflicts(utL50) ? utL50 : na, title='UT S6', color=close > utL50 ? color.green : color.red, linewidth=1, offset=-9999, trackprice=true)
plot(utSrVisible and not utSrConflicts(utL10) ? utL10 : na, title='UT S7', color=close > utL10 ? color.green : color.red, linewidth=1, offset=-9999, trackprice=true)




endOfDay = is_end_day()


var int highOfDayHour = na
var int highOfDayMinute = na
var int lowOfDayHour = na
var int lowOfDayMinute = na
var int hourIndexNullHour = na

lookbackLength = 95


hb = ta.highestbars(lookbackLength)
highBarIndex = -hb

highBarTime = time[highBarIndex]
highBarHour = hour[highBarIndex]
highBarMinute = minute[highBarIndex]


lb = ta.lowestbars(lookbackLength)
lowBarIndex = -lb

lowBarTime = time[lowBarIndex]
lowBarHour = hour[lowBarIndex]
lowBarMinute = minute[lowBarIndex]


if (showHiLoTime and isValidResolution() and endOfDay)

    highOfDayHour := highBarHour
    lowOfDayHour := lowBarHour

    label.new(bar_index[10], high[highBarIndex], "HOD: " + str.tostring(highOfDayHour) + ":" + str.tostring(highBarMinute), style=label.style_none, textcolor=color.silver)
    label.new(bar_index[10], low[lowBarIndex], "LOD: " + str.tostring(lowOfDayHour) + ":" + str.tostring(lowBarMinute), style=label.style_none, textcolor=color.silver)

hourIndexNullHour := ta.valuewhen(not na(highOfDayHour), highOfDayHour, 0)




inTradableSession = not na(time(timeframe.period, trd_ses))

isCloseBelow = false
isCloseAbove = false

if (inTradableSession and close[1] >= rth_low and close < rth_low)
    isCloseBelow := true

if (inTradableSession and close[1] <= rth_high and close > rth_high)
    isCloseAbove := true


alertcondition((isCloseBelow or isCloseAbove), title='Asian Range Break', message='Price has closed outside the Asian Session Range.')

f_print(_txt) => var label _lbl = na, label.delete(_lbl), _lbl := label.new(time + (time-time[1])*3, high, _txt, xloc.bar_time, yloc.price, size = size.large)


const string o          = 'Options'
const string sp1        = '       '
const string sp2        = '              '
const string hl         = 'High / Low    ' + sp1
const string ny_        = 'New York'       + sp1
const string lo_        = 'London Open'
const string lc_        = 'London Close'
const string as_        = 'Asian'

i_mode     = input.string(         'Present'      , title = 'Mode'                   , options =['Present', 'Historical']                                              )

showMS     = input.bool  (           true         , title = ''                       ,   group = 'Market Structures', inline = 'MS'                                    )
lenInput   = input.int   (             5          , title = '     Length   ' +sp2    ,   group = 'Market Structures', inline = 'MS'                                   )
len        = clampInt(lenInput, 3, 10)

iMSS       = input.bool  (           true         , title = '       MSS'     +sp1    ,   group = 'Market Structures', inline = 'M1'                                    )
cMSSbl     = input.color (color.new(#00e6a1,  0), title = 'bullish'                ,   group = 'Market Structures', inline = 'M1'                                    )
cMSSbr     = input.color (color.new(#e60400,  0), title = 'bearish'                ,   group = 'Market Structures', inline = 'M1'                                    )

iBOS       = input.bool  (           true         , title = '       BOS'     +sp1    ,   group = 'Market Structures', inline = 'BS'                                    )
cBOSbl     = input.color (color.new(#00e6a1,  0), title = 'bullish'                ,   group = 'Market Structures', inline = 'BS'                                    )
cBOSbr     = input.color (color.new(#e60400,  0), title = 'bearish'                ,   group = 'Market Structures', inline = 'BS'                                    )

sDispl     = input.bool  (           false        , title = 'Show Displacement'      ,   group = 'Displacement'                                                        )

perc_Body  = 0.36
bxBack     = 10

sVimbl     = input.bool  (           true         , title = ''                       ,   group = 'Volume Imbalance' , inline = 'VI'                                    )
visVimInput= input.int   (             2          , title = "   # Visible VI's  "+sp1,   group = 'Volume Imbalance' , inline = 'VI'                                 )
visVim     = clampInt(visVimInput, 2, 100)
cVimbl     = input.color (color.new(#06b2d0,  0), title = ''                       ,   group = 'Volume Imbalance' , inline = 'VI'                                    )

showOB     = input.bool  (           true         , title = 'Show Order Blocks'      ,   group = 'Order Blocks'      )
lengthInput= input.int   (            10          , title = 'Swing Lookback'         ,   group = 'Order Blocks'      )
length     = ensureMinInt(lengthInput, 3)
showBullInput= input.int   (             1          , title = 'Show Last Bullish OB'   ,   group = 'Order Blocks'     )
showBull   = nonNegativeInt(showBullInput)
showBearInput= input.int   (             1          , title = 'Show Last Bearish OB'   ,   group = 'Order Blocks'     )
showBear   = nonNegativeInt(showBearInput)
useBody    = input.bool  (           true         , title = 'Use Candle Body'          )

bullCss    = input.color (color.new(#3e89fa,  0), title = 'Bullish OB  '           ,   group = 'Order Blocks'     , inline = 'bullcss'                               )
bullBrkCss = input.color (color.new(#4785f9, 85), title = 'Bullish Break  '        ,   group = 'Order Blocks'     , inline = 'bullcss'                               )

bearCss    = input.color (color.new(#FF3131,  0), title = 'Bearish OB'             ,   group = 'Order Blocks'     , inline = 'bearcss'                               )
bearBrkCss = input.color (color.new(#f9ff57, 85), title = 'Bearish Break'          ,   group = 'Order Blocks'     , inline = 'bearcss'                               )

showLabels = input.bool  (          false, title = 'Show Historical Polarity Changes',   group = 'Order Blocks'                                                        )

showLq     = input.bool  (           true         , title = 'Show Liquidity'         ,   group = 'Liquidity'                                                           )
liquidityMarginInput = input.float (             4          , title = 'margin'                 ,   group = 'Liquidity'   , step = 0.1                               )
a     = 10 / clampFloat(liquidityMarginInput, 2.0, 7.0)
visLiqInput = input.int   (             2          , title = '# Visible Liq. boxes'   ,   group = 'Liquidity'        )
visLiq     = clampInt(visLiqInput, 1, 50)
cLIQ_B     = input.color (color.new(#fa451c,  0), title = 'Buyside Liquidity  '    ,   group = 'Liquidity'                                                           )
cLIQ_S     = input.color (color.new(#1ce4fa,  0), title = 'Sellside Liquidity'     ,   group = 'Liquidity'                                                           )

shwFVG     = input.bool  (           true         , title = 'Show FVGs'              ,   group = 'Fair Value Gaps'                                                     )
i_BPR      = input.bool  (           false        , title = 'Balance Price Range'    ,   group = 'Fair Value Gaps'                                                     )
i_FVG      = input.string(           'FVG'        , title = o                        ,   group = 'Fair Value Gaps'  , options=['FVG', 'IFVG']                           )
visBxsInput = input.int   (             2          , title = '# Visible FVG\'s'       ,   group = 'Fair Value Gaps'  )
visBxs     = clampInt(visBxsInput, 1, 20)

cFVGbl     = input.color (color.new(#00e676,  0), title = 'Bullish FVG  '          ,   group = 'Fair Value Gaps'  , inline = 'FVGbl'                                 )
cFVGblBR   = input.color (color.new(#808000,  0), title = 'Break'                  ,   group = 'Fair Value Gaps'  , inline = 'FVGbl'                                 )
cFVGbr     = input.color (color.new(#ff5252,  0), title = 'Bearish FVG '           ,   group = 'Fair Value Gaps'  , inline = 'FVGbr'                                 )
cFVGbrBR   = input.color (color.new(#FF0000,  0), title = 'Break'                  ,   group = 'Fair Value Gaps'  , inline = 'FVGbr'                                 )

iNWOG      = input.bool  (           true         , title = ''        , inline='NWOG',   group = 'NWOG/NDOG'                                                           )
cNWOG1     = input.color (color.new(#ff5252, 28), title = 'NWOG    ', inline='NWOG',   group = 'NWOG/NDOG'                                                           )
cNWOG2     = input.color (color.new(#b2b5be, 50), title = ''        , inline='NWOG',   group = 'NWOG/NDOG'                                                           )
maxNWOGInput= input.int   (             3          , title = 'Show max', inline='NWOG',   group = 'NWOG/NDOG'       )
maxNWOG    = clampInt(maxNWOGInput, 0, 50)

iNDOG      = input.bool  (           false        , title = ''        , inline='NDOG',   group = 'NWOG/NDOG'                                                           )
cNDOG1     = input.color (color.new(#ff9800, 20), title = 'NDOG    ', inline='NDOG',   group = 'NWOG/NDOG'                                                           )
cNDOG2     = input.color (color.new(#4dd0e1, 65), title =    ''     , inline='NDOG',   group = 'NWOG/NDOG'                                                           )
maxNDOGInput= input.int   (             1          , title = 'Show max', inline='NDOG',   group = 'NWOG/NDOG'       )
maxNDOG    = clampInt(maxNDOGInput, 0, 50)

iFib       = input.string(           'NONE'      , title = 'Fibonacci between last: ',   group = 'Fibonacci', options=['FVG', 'BPR', 'OB', 'Liq', 'VI', 'NWOG', 'NONE'])
iExt       = input.bool  (           false       , title = 'Extend lines'            ,   group = 'Fibonacci'                                                           )

showKZ     = input.bool  (           false        , title = 'Show Killzones'         ,   group = 'Killzones'                                                           )
showNy     = input.bool  (           true         , title = ny_      , inline = 'ny' ,   group = 'Killzones'                                                           ) and showKZ
nyCss      = input.color (color.new(#ff5d00, 93), title = ''       , inline = 'ny' ,   group = 'Killzones'                                                           )
showLdno   = input.bool  (           true         , title = lo_      , inline = 'lo' ,   group = 'Killzones'                                                           ) and showKZ
ldnoCss    = input.color (color.new(#00bcd4, 93), title = ''       , inline = 'lo' ,   group = 'Killzones'                                                           )
showLdnc   = input.bool  (           true         , title = lc_      , inline = 'lc' ,   group = 'Killzones'                                                           ) and showKZ
ldncCss    = input.color (color.new(#2157f3, 93), title = ''       , inline = 'lc' ,   group = 'Killzones'                                                           )
showAsia   = input.bool  (           true         , title = as_ + sp2, inline = 'as' ,   group = 'Killzones'                                                           ) and showKZ
asiaCss    = input.color (color.new(#e91e63, 93), title = ''       , inline = 'as' ,   group = 'Killzones'                                                           )

n          =                      bar_index
hi         =                      high
lo         =                      low
tf_msec    = timeframe.in_seconds(timeframe.period) * 1000
maxSize    =        50
atr        = ta.atr(10)
per        = i_mode == 'Present' ? last_bar_index - bar_index <=  500 : true
perB       = last_bar_index - bar_index <= 1000  ? true : false
xloc       = iFib   ==   'OB'    ? xloc.bar_time : xloc.bar_index
ext        = iExt                ?  extend.right : extend.none
plus       = iFib   ==   'OB'    ?  tf_msec * 50 : 50
mx         = math.max(close , open)
mn         = math.min(close , open)
body       = math.abs(close - open)
meanBody   = ta.sma  (body  ,  len)
max        = useBody ?  mx  : high
min        = useBody ?  mn  : low
blBrkConf  = 0
brBrkConf  = 0
r          = color.r(chart.bg_color)
g          = color.g(chart.bg_color)
b          = color.b(chart.bg_color)
isDark     = r < 80 and g < 80 and b < 80

type ZZ
    int   [] d
    int   [] x
    float [] y
    bool  [] b

type ln_d
    line  l
    int   d

type _2ln_lb
    line  l1
    line  l2
    label lb

type bx_ln
    box   b
    line  l

type bx_ln_lb
    box   bx
    line  ln
    label lb

type mss
    int     dir
    line [] l_mssBl
    line [] l_mssBr
    line [] l_bosBl
    line [] l_bosBr
    label[] lbMssBl
    label[] lbMssBr
    label[] lbBosBl
    label[] lbBosBr

type liq
    box   bx
    bool  broken
    bool  brokenTop
    bool  brokenBtm
    line  ln

type ob
    float   top       = na
    float   btm       = na
    int     loc       = bar_index
    bool    breaker   = false
    int     break_loc = na

type swing
    float y = na
    int   x = na
    bool  crossed = false

type FVG
    box box
    bool active
    int  pos

var mss MSS = mss.new(
 0
 , array.new < line  >()
 , array.new < line  >()
 , array.new < line  >()
 , array.new < line  >()
 , array.new < label >()
 , array.new < label >()
 , array.new < label >()
 , array.new < label >()
 )

maxVimb = 2

var float friCp = na, var int friCi = na
var float monOp = na, var int monOi = na

var float prDCp = na, var int prDCi = na
var float cuDOp = na, var int cuDOi = na

var _2ln_lb [] Vimbal     = array.new<  _2ln_lb >()

var   liq   [] b_liq_B    = array.new<    liq   >(1, liq.new(na, false, false, false, na))
var   liq   [] b_liq_S    = array.new<    liq   >(1, liq.new(na, false, false, false, na))

var    ob   [] bullish_ob = array.new<    ob    >()
var    ob   [] bearish_ob = array.new<    ob    >()

var bx_ln   [] bl_NWOG    = array.new<   bx_ln  >()
var bx_ln   [] bl_NDOG    = array.new<   bx_ln  >()

var bx_ln_lb[] a_bx_ln_lb = array.new< bx_ln_lb >()

var FVG     [] bFVG_UP    = array.new<    FVG   >()
var FVG     [] bFVG_DN    = array.new<    FVG   >()

var FVG     [] bBPR_UP    = array.new<    FVG   >()
var FVG     [] bBPR_DN    = array.new<    FVG   >()

var  ZZ         aZZ       =
 ZZ.new(
 array.new < int    >(maxSize,  0),
 array.new < int    >(maxSize,  0),
 array.new < float  >(maxSize, na),
 array.new < bool   >(maxSize, false))

var line _diag = line.new(na, na, na, na, color=color.new(color.silver, 50), style=line.style_dashed, xloc= xloc            )
var line _vert = line.new(na, na, na, na, color=color.new(color.silver, 50), style=line.style_dotted, xloc= xloc            )
var line _zero = line.new(na, na, na, na, color=color.new(color.silver,  5), style=line.style_solid , xloc= xloc, extend=ext)
var line _0236 = line.new(na, na, na, na, color=color.new(color.orange, 25), style=line.style_solid , xloc= xloc, extend=ext)
var line _0382 = line.new(na, na, na, na, color=color.new(color.yellow, 25), style=line.style_solid , xloc= xloc, extend=ext)
var line _0500 = line.new(na, na, na, na, color=color.new(color.green , 25), style=line.style_solid , xloc= xloc, extend=ext)
var line _0618 = line.new(na, na, na, na, color=color.new(color.yellow, 25), style=line.style_solid , xloc= xloc, extend=ext)
var line _0786 = line.new(na, na, na, na, color=color.new(color.orange, 25), style=line.style_solid , xloc= xloc, extend=ext)
var line _one_ = line.new(na, na, na, na, color=color.new(color.silver,  5), style=line.style_solid , xloc= xloc, extend=ext)
var line _1618 = line.new(na, na, na, na, color=color.new(color.yellow, 25), style=line.style_solid , xloc= xloc, extend=ext)

method in_out(ZZ aZZ, int d, int x1, float y1, int x2, float y2, color col, bool b) =>
    aZZ.d.unshift(d), aZZ.x.unshift(x2), aZZ.y.unshift(y2), aZZ.b.unshift(b), aZZ.d.pop(), aZZ.x.pop(), aZZ.y.pop(), aZZ.b.pop()

method timeinrange(string res, string sess) => not na(time(timeframe.period, res, sess))

method setLine(line ln, int x1, float y1, int x2, float y2) => ln.set_xy1(x1, y1), ln.set_xy2(x2, y2)

method clear_aLine(line[] l) =>
    if l.size() > 0
        for i = l.size() -1 to 0
            l.pop().delete()

method clear_aLabLin(label[] l) =>
    if l.size() > 0
        for i = l.size() -1 to 0
            l.pop().delete()

method clear_aLabLin(line[] l) =>
    if l.size() > 0
        for i = l.size() -1 to 0
            l.pop().delete()

method notransp(color css) => color.rgb(color.r(css), color.g(css), color.b(css))

method display(ob id, css, break_css, str)=>
    if showOB
        if id.breaker
            a_bx_ln_lb.unshift(
             bx_ln_lb.new(
               box.new(id.loc, id.top, timenow + (tf_msec * 10), id.btm, na
             , bgcolor = break_css
             , extend  = extend.none
             , xloc    = xloc.bar_time)
             , na
             , na)
             )
        else
            y  = str == 'bl' ? id.btm : id.top
            s  = str == 'bl' ? label.style_label_up : label.style_label_down
            a_bx_ln_lb.unshift(
             bx_ln_lb.new(
               na
             , line.new(id.loc,   y  , id.loc  + (tf_msec * 10),    y
             , xloc    = xloc.bar_time, color=css, width=2)
             , label.new(              id.loc  + (tf_msec * 10),    y
             , text  = str == 'bl' ? '+OB' : '-OB'
             , xloc  = xloc.bar_time
             , style = s    , color = na
             , textcolor=css, size  = size.small))
             )

swings(len)=>
    var os = 0
    var swing top = swing.new(na, na)
    var swing btm = swing.new(na, na)

    upper = ta.highest(len)
    lower = ta.lowest(len)

    os := high[len] > upper ? 0
       :  low [len] < lower ? 1 : os

    if os == 0 and os[1] != 0
        top := swing.new(high[length], bar_index[length])

    if os == 1 and os[1] != 1
        btm := swing.new(low[length], bar_index[length])

    [top, btm]

set_lab(i, str) =>
    style = str == 'Bl' ? label.style_label_down : label.style_label_up
    txcol = str == 'Bl' ? color.lime : color.red
    label.new(math.round((aZZ.x.get(i) + n) / 2), aZZ.y.get(i), text='BOS'
     , style=style, color=na, textcolor=txcol, size=size.tiny)
set_lin(i, str) =>
    color = str == 'Bl' ? color.lime : color.red
    line.new(aZZ.x.get(i), aZZ.y.get(i), n, aZZ.y.get(i), color=color, style=line.style_dotted)

draw(left, col) =>
    max_bars_back(time, 1000)
    var int dir= na, var int x1= na, var float y1= na, var int x2= na, var float y2= na
    sz       = aZZ.d.size( )
    x2      := bar_index -1
    ph       = ta.pivothigh(hi, left, 1)
    pl       = ta.pivotlow (lo, left, 1)
    if not na(ph)
        dir := aZZ.d.get (0)
        x1  := aZZ.x.get (0)
        y1  := aZZ.y.get (0)
        y2  :=      nz(hi[1])
        if dir <  1
            aZZ.in_out( 1, x1, y1, x2, y2, col, true)
        else
            if dir ==  1 and ph > y1
                aZZ.x.set(0, x2), aZZ.y.set(0, y2)
        if showLq and per and sz > 0
            count = 0
            st_P  = 0.
            st_B  = 0
            minP  = 0.
            maxP  = 10e6
            for i = 0 to math.min(sz, 50) -1
                if aZZ.d.get(i) ==  1
                    if aZZ.y.get(i) > ph + (atr/a)
                        break
                    else
                        if aZZ.y.get(i) > ph - (atr/a) and aZZ.y.get(i) < ph + (atr/a)
                            count += 1
                            st_B := aZZ.x.get(i)
                            st_P := aZZ.y.get(i)
                            if aZZ.y.get(i) > minP
                                minP := aZZ.y.get(i)
                            if aZZ.y.get(i) < maxP
                                maxP := aZZ.y.get(i)
            if count > 2
                getB = b_liq_B.get(0)
                liqMid = (minP + maxP) / 2
                liqTop = liqMid + (atr / a)
                liqBottom = liqMid - (atr / a)
                if st_B == getB.bx.get_left()
                    getB.bx.set_top(liqTop)
                    getB.bx.set_rightbottom(n + 10, liqBottom)
                else
                    newLiqBBox = box.new(st_B, liqTop, n + 10, liqBottom)
                    box.set_border_color(newLiqBBox, color.new(cLIQ_B, 0))
                    box.set_bgcolor(newLiqBBox, na)
                    box.set_text(newLiqBBox, 'Buyside liquidity')
                    box.set_text_size(newLiqBBox, size.tiny)
                    box.set_text_halign(newLiqBBox, text.align_left)
                    box.set_text_valign(newLiqBBox, text.align_bottom)
                    box.set_text_color(newLiqBBox, color.new(cLIQ_B, 25))
                    newLiqBLine = line.new(st_B, st_P, n - 1, st_P, color = color.new(cLIQ_B, 0))
                    newLiqB = liq.new(newLiqBBox, false, false, false, newLiqBLine)
                    b_liq_B.unshift(newLiqB)
                if b_liq_B.size() > visLiq
                    getLast = b_liq_B.pop()
                    getLast.bx.delete()
                    getLast.ln.delete()
    if not na(pl)
        dir := aZZ.d.get (0)
        x1  := aZZ.x.get (0)
        y1  := aZZ.y.get (0)
        y2  :=      nz(lo[1])
        if dir > -1
            aZZ.in_out(-1, x1, y1, x2, y2, col, true)
        else
            if dir == -1 and pl < y1
                aZZ.x.set(0, x2), aZZ.y.set(0, y2)
        if showLq and per and sz > 0
            count = 0
            st_P  = 0.
            st_B  = 0
            minP  = 0.
            maxP  = 10e6
            for i = 0 to math.min(sz, 50) -1
                if aZZ.d.get(i) == -1
                    if aZZ.y.get(i) < pl - (atr/a)
                        break
                    else
                        if aZZ.y.get(i) > pl - (atr/a) and aZZ.y.get(i) < pl + (atr/a)
                            count += 1
                            st_B := aZZ.x.get(i)
                            st_P := aZZ.y.get(i)
                            if aZZ.y.get(i) > minP
                                minP := aZZ.y.get(i)
                            if aZZ.y.get(i) < maxP
                                maxP := aZZ.y.get(i)
            if count > 2
                getB = b_liq_S.get(0)
                liqMid = (minP + maxP) / 2
                liqTop = liqMid + (atr / a)
                liqBottom = liqMid - (atr / a)
                if st_B == getB.bx.get_left()
                    getB.bx.set_top(liqTop)
                    getB.bx.set_rightbottom(n + 10, liqBottom)
                else
                    newLiqSBox = box.new(st_B, liqTop, n + 10, liqBottom)
                    box.set_border_color(newLiqSBox, color.new(cLIQ_S, 0))
                    box.set_bgcolor(newLiqSBox, na)
                    box.set_text(newLiqSBox, 'Sellside liquidity')
                    box.set_text_size(newLiqSBox, size.tiny)
                    box.set_text_halign(newLiqSBox, text.align_left)
                    box.set_text_valign(newLiqSBox, text.align_bottom)
                    box.set_text_color(newLiqSBox, color.new(cLIQ_S, 25))
                    newLiqSLine = line.new(st_B, st_P, n - 1, st_P, color = color.new(cLIQ_S, 0))
                    newLiqS = liq.new(newLiqSBox, false, false, false, newLiqSLine)
                    b_liq_S.unshift(newLiqS)
                if b_liq_S.size() > visLiq
                    getLast = b_liq_S.pop()
                    getLast.bx.delete()
                    getLast.ln.delete()
    if showMS
        iH = aZZ.d.get(2) ==  1 ? 2 : 1
        iL = aZZ.d.get(2) == -1 ? 2 : 1
        switch
            close > aZZ.y.get(iH) and aZZ.d.get(iH) ==  1 and MSS.dir <  1 =>
                MSS.dir :=  1
                if i_mode == 'Present'
                    MSS.l_bosBl.clear_aLabLin(), MSS.l_bosBr.clear_aLabLin()
                    MSS.lbBosBl.clear_aLabLin(), MSS.lbBosBr.clear_aLabLin()
                    MSS.l_mssBl.clear_aLabLin(), MSS.l_mssBr.clear_aLabLin()
                    MSS.lbMssBl.clear_aLabLin(), MSS.lbMssBr.clear_aLabLin()
                MSS.l_mssBl.unshift(line.new (
                  aZZ.x.get(iH), aZZ.y.get(iH), n, aZZ.y.get(iH), color=cMSSbl))
                MSS.lbMssBl.unshift(label.new(
                  math.round((aZZ.x.get(iH) + n) / 2), aZZ.y.get(iH), text ='MSS'
                 , style=label.style_label_down, size=size.tiny, color=na, textcolor=cMSSbl))
            close < aZZ.y.get(iL) and aZZ.d.get(iL) == -1 and MSS.dir > -1 =>
                MSS.dir := -1
                if i_mode == 'Present'
                    MSS.l_bosBl.clear_aLabLin(), MSS.l_bosBr.clear_aLabLin()
                    MSS.lbBosBl.clear_aLabLin(), MSS.lbBosBr.clear_aLabLin()
                    MSS.l_mssBl.clear_aLabLin(), MSS.l_mssBr.clear_aLabLin()
                    MSS.lbMssBl.clear_aLabLin(), MSS.lbMssBr.clear_aLabLin()
                MSS.l_mssBr.unshift(line.new (
                  aZZ.x.get(iL), aZZ.y.get(iL), n, aZZ.y.get(iL), color=cMSSbr))
                MSS.lbMssBr.unshift(label.new(
                  math.round((aZZ.x.get(iL) + n) / 2), aZZ.y.get(iL), text ='MSS'
                 , style=label.style_label_up  , size=size.tiny, color=na, textcolor=cMSSbr))
            MSS.dir ==  1 and close > aZZ.y.get(iH) and iBOS =>
                if MSS.l_bosBl.size() > 0
                    if aZZ.y.get(iH) != MSS.l_bosBl.get(0).get_y2() and
                       aZZ.y.get(iH) != MSS.l_mssBl.get(0).get_y2()
                        MSS.l_bosBl.unshift(set_lin(iH, 'Bl')), MSS.lbBosBl.unshift(set_lab(iH, 'Bl'))
                else
                    if aZZ.y.get(iH) != MSS.l_mssBl.get(0).get_y2()
                        MSS.l_bosBl.unshift(set_lin(iH, 'Bl')), MSS.lbBosBl.unshift(set_lab(iH, 'Bl'))
            MSS.dir == -1 and close < aZZ.y.get(iL) and iBOS =>
                if MSS.l_bosBr.size() > 0
                    if aZZ.y.get(iL) != MSS.l_bosBr.get(0).get_y2() and
                       aZZ.y.get(iL) != MSS.l_mssBr.get(0).get_y2()
                        MSS.l_bosBr.unshift(set_lin(iL, 'Br')), MSS.lbBosBr.unshift(set_lab(iL, 'Br'))
                else
                    if aZZ.y.get(iL) != MSS.l_mssBr.get(0).get_y2()
                        MSS.l_bosBr.unshift(set_lin(iL, 'Br')), MSS.lbBosBr.unshift(set_lab(iL, 'Br'))
        if not iMSS
            MSS.l_mssBl.get(0).set_color(na), MSS.lbMssBl.get(0).set_textcolor(na)
            MSS.l_mssBr.get(0).set_color(na), MSS.lbMssBr.get(0).set_textcolor(na)



draw(len, color.yellow)

if MSS.l_bosBl.size() > 200
    MSS.l_bosBl.pop().delete()
    MSS.lbBosBl.pop().delete()

if MSS.l_bosBr.size() > 200
    MSS.l_bosBr.pop().delete()
    MSS.lbBosBr.pop().delete()

ny          = not na(time(timeframe.period, input.session('0700-0900', '', inline = 'ny', group = 'Killzones'), "America/New_York")) and showNy
ldn_open    = not na(time(timeframe.period, input.session('0700-1000', '', inline = 'lo', group = 'Killzones'), 'Europe/London'   )) and showLdno
ldn_close   = not na(time(timeframe.period, input.session('1500-1700', '', inline = 'lc', group = 'Killzones'), 'Europe/London'   )) and showLdnc
asian       = not na(time(timeframe.period, input.session('1000-1400', '', inline = 'as', group = 'Killzones'), 'Asia/Tokyo'      )) and showAsia

ph          = ta.pivothigh(3, 1), lPh = fixnan(ph)
pl          = ta.pivotlow (3, 1), lPl = fixnan(pl)

L_body      =
 high - mx  < body * perc_Body and
 mn - low   < body * perc_Body

L_bodyUP    =   body > meanBody  and L_body and close > open
L_bodyDN    =   body > meanBody  and L_body and close < open

bsNOTbodyUP = ta.barssince(not L_bodyUP)
bsNOTbodyDN = ta.barssince(not L_bodyDN)

bsIs_bodyUP = ta.barssince(    L_bodyUP)
bsIs_bodyDN = ta.barssince(    L_bodyDN)

lwst        = math.min(lPh [bsNOTbodyUP[1]], low[bsNOTbodyUP[1]])
hgst        = math.max(high[bsNOTbodyDN[1]], lPl[bsNOTbodyDN[1]])

imbalanceUP = L_bodyUP[1] and (i_FVG == 'FVG' ? low  > high[2] : low  < high[2])
imbalanceDN = L_bodyDN[1] and (i_FVG == 'FVG' ? high < low [2] : high > low [2])

vImb_Bl     = open > close[1] and high[1] > low  and close > close[1] and open > open[1] and high[1] < mn
vImb_Br     = open < close[1] and low [1] < high and close < close[1] and open < open[1] and low [1] > mx

if sVimbl
    if vImb_Bl
        Vimbal.unshift(
         _2ln_lb.new(
          line.new (n -1, mx[1], n +3, mx[1], color=cVimbl)
         , line.new (n   , mn   , n +3, mn   , color=cVimbl)
          , label.new(n +3, (mx[1] + mn) / 2, text='VI'
         , color=na , textcolor=cVimbl, style=label.style_label_left)
          )
         )
    if vImb_Br
        Vimbal.unshift(
         _2ln_lb.new(
          line.new (n -1, mn[1], n +3, mn[1], color=cVimbl)
         , line.new (n   , mx   , n +3, mx   , color=cVimbl)
          , label.new(n +3, (mn[1] + mx) / 2, text='VI'
         , color=na , textcolor=cVimbl, style=label.style_label_left)
          )
         )
    if Vimbal.size() > visVim
        pop = Vimbal.pop()
        pop.l1.delete()
        pop.l2.delete()
        pop.lb.delete()

if barstate.isfirst
    for i = 0 to visBxs -1
        bFVG_UP.unshift(FVG.new(na, false))
        bFVG_DN.unshift(FVG.new(na, false))
        if i_BPR
            bBPR_UP.unshift(FVG.new(na, false))
            bBPR_DN.unshift(FVG.new(na, false))

if imbalanceUP and per and shwFVG
    if imbalanceUP[1]
        bFVG_UP.get(0).box.set_lefttop    (n -2, low    )
        bFVG_UP.get(0).box.set_rightbottom(n +8, high[2])
    else
        bFVG_UP.unshift(FVG.new(
          box.new(
           n -2
         ,    i_FVG == 'FVG' ? low : high[2]
         , n, i_FVG == 'FVG' ? high[2] : low
         , bgcolor     = i_BPR ? na : color.new(cFVGbl, 90)
         , border_color= i_BPR ? na : color.new(cFVGbl, 65)
         , text_color  = i_BPR ? na : color.new(cFVGbl, 65)
         , text_size=size.small
         , text=i_FVG
         )
         , true)
         )
        bFVG_UP.pop().box.delete()

if imbalanceDN and per and shwFVG
    if imbalanceDN[1]
        bFVG_DN.get(0).box.set_lefttop    (n -2, low[2])
        bFVG_DN.get(0).box.set_rightbottom(n +8, high  )
    else
        bFVG_DN.unshift(FVG.new(
         box.new(
           n -2
         ,    i_FVG == 'FVG' ? low[2] : high
         , n, i_FVG == 'FVG' ? high   : low[2]
         , bgcolor     = i_BPR ? na : color.new(cFVGbr, 90)
         , border_color= i_BPR ? na : color.new(cFVGbr, 65)
         , text_color  = i_BPR ? na : color.new(cFVGbr, 65)
         , text_size=size.small
         , text=i_FVG
         )
         , true)
         )
        bFVG_DN.pop().box.delete()

if i_BPR and bFVG_UP.size() > 0 and bFVG_DN.size() > 0
    bxUP    = bFVG_UP.get(0)
    bxDN    = bFVG_DN.get(0)
    bxUPbtm = bxUP.box.get_bottom()
    bxDNbtm = bxDN.box.get_bottom()
    bxUPtop = bxUP.box.get_top()
    bxDNtop = bxDN.box.get_top()
    left    = math.min(bxUP.box.get_left (), bxDN.box.get_left ())
    right   = math.max(bxUP.box.get_right(), bxDN.box.get_right())
    if bxUPbtm < bxDNtop and
       bxDNbtm < bxUPbtm
        if left == bBPR_UP.get(0).box.get_left()
            if  bBPR_UP.get(0).active
                bBPR_UP.get(0).box.set_right(right)
        else
            bBPR_UP.unshift(FVG.new(
             box.new(
              left, bxDNtop, right, bxUPbtm
             , bgcolor     = i_BPR ? color.new(cFVGbl, 90) : na
             , border_color= i_BPR ? color.new(cFVGbl, 65) : na
             , text_color  = i_BPR ? color.new(cFVGbl, 65) : na
              , text_size=size.small
              , text= 'BPR'                 )
              , true
              , close > bxUPbtm ? 1 : close < bxDNtop ? -1 : 0
              )
             )
            bBPR_UP.pop().box.delete()
    if bxDNbtm < bxUPtop and
       bxUPbtm < bxDNbtm
        if left == bBPR_DN.get(0).box.get_left()
            if  bBPR_DN.get(0).active
                bBPR_DN.get(0).box.set_right(right)
        else
            bBPR_DN.unshift(FVG.new(
             box.new(
              left, bxUPtop, right, bxDNbtm
             , bgcolor     = i_BPR ? color.new(cFVGbr, 90) : na
             , border_color= i_BPR ? color.new(cFVGbr, 65) : na
             , text_color  = i_BPR ? color.new(cFVGbr, 65) : na
              , text_size=size.small
              , text= 'BPR'                 )
              , true
              , close > bxDNbtm ? 1 : close < bxUPtop ? -1 : 0
              )
             )
            bBPR_DN.pop().box.delete()

for i = 0 to math.min(bxBack, bFVG_UP.size() -1)
    getUPi = bFVG_UP.get(i)
    if getUPi.active
        getUPi.box.set_right(bar_index +8)
        if low  < getUPi.box.get_top() and not i_BPR
            getUPi.box.set_border_style(line.style_dashed)
        if low  < getUPi.box.get_bottom()
            if not i_BPR
                getUPi.box.set_bgcolor(color.new(cFVGblBR, 95))
                getUPi.box.set_border_style(line.style_dotted)
            getUPi.box.set_right(bar_index)
            getUPi.active := false

for i = 0 to math.min(bxBack, bFVG_DN.size() -1)
    getDNi = bFVG_DN.get(i)
    if getDNi.active
        getDNi.box.set_right(bar_index +8)
        if high > getDNi.box.get_bottom() and not i_BPR
            getDNi.box.set_border_style(line.style_dashed)
        if high > getDNi.box.get_top()
            if not i_BPR
                getDNi.box.set_bgcolor(color.new(cFVGbrBR, 95))
                getDNi.box.set_border_style(line.style_dotted)
            getDNi.box.set_right(bar_index)
            getDNi.active := false

if i_BPR
    for i = 0 to math.min(bxBack, bBPR_UP.size() -1)
        getUPi = bBPR_UP.get(i)
        if getUPi.active
            getUPi.box.set_right(bar_index +8)
            switch getUPi.pos
                -1 =>
                    if high > getUPi.box.get_bottom()
                        getUPi.box.set_border_style(line.style_dashed)
                    if high > getUPi.box.get_top   ()
                        getUPi.box.set_bgcolor(color.new(cFVGblBR, 95))
                        getUPi.box.set_border_style(line.style_dotted)
                        getUPi.box.set_right(bar_index)
                        getUPi.active := false
                1 =>
                    if low  < getUPi.box.get_top   ()
                        getUPi.box.set_border_style(line.style_dashed)
                    if low  < getUPi.box.get_bottom()
                        getUPi.box.set_bgcolor(color.new(cFVGblBR, 95))
                        getUPi.box.set_border_style(line.style_dotted)
                        getUPi.box.set_right(bar_index)
                        getUPi.active := false

    for i = 0 to math.min(bxBack, bBPR_DN.size() -1)
        getDNi = bBPR_DN.get(i)
        if getDNi.active
            getDNi.box.set_right(bar_index +8)
            switch getDNi.pos
                -1 =>
                    if high > getDNi.box.get_bottom()
                        getDNi.box.set_border_style(line.style_dashed)
                    if high > getDNi.box.get_top   ()
                        getDNi.box.set_bgcolor(color.new(cFVGbrBR, 95))
                        getDNi.box.set_border_style(line.style_dotted)
                        getDNi.box.set_right(bar_index)
                        getDNi.active := false
                1 =>
                    if low  < getDNi.box.get_top   ()
                        getDNi.box.set_border_style(line.style_dashed)
                    if low  < getDNi.box.get_bottom()
                        getDNi.box.set_bgcolor(color.new(cFVGbrBR, 95))
                        getDNi.box.set_border_style(line.style_dotted)
                        getDNi.box.set_right(bar_index)
                        getDNi.active := false

if barstate.isfirst
    for i = 0 to maxNWOG -1
        bl_NWOG.unshift(bx_ln.new(na, na))
    for i = 0 to maxNDOG -1
        bl_NDOG.unshift(bx_ln.new(na, na))

if dayofweek == dayofweek.friday
    friCp := close, friCi := n

if ta.change(dayofweek) != 0
    if  dayofweek == dayofweek.monday and iNWOG
        monOp := open , monOi := n
        bl_NWOG.unshift(bx_ln.new(
         box.new(
           friCi        ,   math.max (friCp  , monOp  )
         , monOi        ,   math.min (friCp  , monOp  )
         , bgcolor      =   color    ( na             )
         , border_color =             cNWOG2
         , extend       =             extend.right    )
         ,
         line.new(
           monOi        ,   (friCp + monOp) / 2
         , monOi +1     ,   (friCp + monOp) / 2
         , color        =             cNWOG1
         , style        =             line.style_dotted
         , extend       =             extend.right    )
         ))
        bl = bl_NWOG.pop(), bl.b.delete(), bl.l.delete()
    if iNDOG
        cuDOp := open    , cuDOi := n
        prDCp := close[1], prDCi := n -1
        bl_NDOG.unshift(bx_ln.new(
         box.new(
           prDCi        ,   math.max (prDCp  , cuDOp  )
         , cuDOi        ,   math.min (prDCp  , cuDOp  )
         , bgcolor      =   color    ( na             )
         , border_color =             cNDOG2
         , extend       =             extend.right    )
         ,
         line.new(
           cuDOi        ,   (prDCp + cuDOp) / 2
         , cuDOi +1     ,   (prDCp + cuDOp) / 2
         , color        =             cNDOG1
         , style        =             line.style_dotted
         , extend       =             extend.right    )
         ))
        bl = bl_NDOG.pop(), bl.b.delete(), bl.l.delete()

for i = 0 to b_liq_B.size() -1
    x = b_liq_B.get(i)
    if not x.broken
        x.bx.set_right(n +3)
        x.ln.set_x2   (n +3)
        if not x.brokenTop
            if close > x.bx.get_top   ()
                x.brokenTop := true
        if not x.brokenBtm
            if close > x.bx.get_bottom()
                x.brokenBtm := true
        if x.brokenBtm
            x.bx.set_bgcolor(color.new(cLIQ_B, 90))
            x.ln.delete()
            if x.brokenTop
                x.broken := true
                x.bx.set_right(n)

for i = 0 to b_liq_S.size() -1
    x = b_liq_S.get(i)
    if not x.broken
        x.bx.set_right(n +3)
        x.ln.set_x2   (n +3)
        if not x.brokenTop
            if close < x.bx.get_top   ()
                x.brokenTop := true
        if not x.brokenBtm
            if close < x.bx.get_bottom()
                x.brokenBtm := true
        if x.brokenTop
            x.bx.set_bgcolor(color.new(cLIQ_S, 90))
            x.ln.delete()
            if x.brokenBtm
                x.broken := true
                x.bx.set_right(n)

[top, btm] = swings(length)

if showOB and per
    if close > top.y and not top.crossed
        top.crossed := true

        minima = max[1]
        maxima = min[1]
        loc = time[1]

        for i = 1 to (n - top.x)-1
            minima := math.min(min[i], minima)
            maxima := minima == min[i] ? max[i] : maxima
            loc := minima == min[i] ? time[i] : loc
        bullish_ob.unshift(ob.new(maxima, minima, loc))

    if bullish_ob.size() > 0
        for i = bullish_ob.size()-1 to 0
            element = bullish_ob.get(i)

            if not element.breaker
                if math.min(close, open) < element.btm
                    element.breaker := true
                    element.break_loc := time
            else
                if close > element.top
                    bullish_ob.remove(i)
                else if i < showBull and top.y < element.top and top.y > element.btm
                    blBrkConf := 1

    if blBrkConf > blBrkConf[1] and showLabels
        label.new(top.x, top.y, '▼', color = na
          , textcolor = bearCss.notransp()
          , style = label.style_label_down
          , size = size.tiny)

if showOB and per
    if close < btm.y and not btm.crossed
        btm.crossed := true

        minima = min[1]
        maxima = max[1]
        loc = time[1]

        for i = 1 to (n - btm.x)-1
            maxima := math.max(max[i], maxima)
            minima := maxima == max[i] ? min[i] : minima
            loc := maxima == max[i] ? time[i] : loc
        bearish_ob.unshift(ob.new(maxima, minima, loc))

    if bearish_ob.size() > 0
        for i = bearish_ob.size()-1 to 0
            element = bearish_ob.get(i)

            if not element.breaker
                if math.max(close, open) > element.top
                    element.breaker := true
                    element.break_loc := time
            else
                if close < element.btm
                    bearish_ob.remove(i)
                else if i < showBear and btm.y > element.btm and btm.y < element.top
                    brBrkConf := 1

    if brBrkConf > brBrkConf[1] and showLabels
        label.new(btm.x, btm.y, '▲', color = na
          , textcolor = bullCss.notransp()
          , style = label.style_label_up
          , size = size.tiny)

if barstate.islast and showOB
    if a_bx_ln_lb.size() > 0
        for i = a_bx_ln_lb.size() -1 to 0
            item = a_bx_ln_lb.remove(i)
            item.bx.delete()
            item.ln.delete()
            item.lb.delete()
    if showBull > 0
        blSz = bullish_ob.size()
        if blSz > 0
            for i = 0 to math.min(showBull, bullish_ob.size()) -1
                get_ob = bullish_ob.get(i)
                get_ob.display(bullCss, bullBrkCss, 'bl')
    if showBear > 0
        brSz = bearish_ob.size()
        if brSz > 0
            for i = 0 to math.min(showBear, bearish_ob.size()) -1
                get_ob = bearish_ob.get(i)
                get_ob.display(bearCss, bearBrkCss, 'br')

if barstate.islast
    x1 = 0, y1 = 0., x2 = 0, y2 = 0., box up = na, box dn = na
    switch iFib
        'FVG'   =>
            if bFVG_UP.size() > 0 and bFVG_DN.size() > 0
                up  := bFVG_UP.get(0).box
                dn  := bFVG_DN.get(0).box
                dnFirst = up.get_left() > dn.get_left()
                dnBottm = up.get_top () > dn.get_top ()
                x1  := dnFirst ? dn.get_left  () : up.get_left  ()
                x2  := dnFirst ? up.get_right () : dn.get_right ()
                y1  := dnFirst ?
                 dnBottm       ? dn.get_bottom() : dn.get_top   () :
                 dnBottm       ? up.get_top   () : up.get_bottom()
                y2  := dnFirst ?
                 dnBottm       ? up.get_top   () : up.get_bottom() :
                 dnBottm       ? dn.get_bottom() : dn.get_top   ()
        'BPR'   =>
            if bBPR_UP.size() > 0 and bBPR_DN.size() > 0
                up  := bBPR_UP.get(0).box
                dn  := bBPR_DN.get(0).box
                dnFirst = up.get_left() > dn.get_left()
                dnBottm = up.get_top () > dn.get_top ()
                x1  := dnFirst ? dn.get_left  () : up.get_left  ()
                x2  := dnFirst ? up.get_right () : dn.get_right ()
                y1  := dnFirst ?
                 dnBottm       ? dn.get_bottom() : dn.get_top   () :
                 dnBottm       ? up.get_top   () : up.get_bottom()
                y2  := dnFirst ?
                 dnBottm       ? up.get_top   () : up.get_bottom() :
                 dnBottm       ? dn.get_bottom() : dn.get_top   ()
        'OB'    =>
            oSz = a_bx_ln_lb.size()
            if oSz > 1
                xA = nz(
                   a_bx_ln_lb.get(oSz -1).ln.get_x1    ()
                 , a_bx_ln_lb.get(oSz -1).bx.get_left  ()
                 )
                xB = nz(
                   a_bx_ln_lb.get(oSz -2).ln.get_x1    ()
                 , a_bx_ln_lb.get(oSz -2).bx.get_left  ()
                 )
                AFirst = xB > xA
                yAT = nz(
                   a_bx_ln_lb.get(oSz -1).ln.get_y1    ()
                 , a_bx_ln_lb.get(oSz -1).bx.get_top   ()
                 )
                yAB = nz(
                   a_bx_ln_lb.get(oSz -1).ln.get_y1    ()
                 , a_bx_ln_lb.get(oSz -1).bx.get_bottom()
                 )
                yBT = nz(
                   a_bx_ln_lb.get(oSz -2).ln.get_y1    ()
                 , a_bx_ln_lb.get(oSz -2).bx.get_top   ()
                 )
                yBB = nz(
                   a_bx_ln_lb.get(oSz -2).ln.get_y1    ()
                 , a_bx_ln_lb.get(oSz -2).bx.get_bottom()
                 )
                ABottom = yAB < yBB
                x1  := AFirst ? xA : xB
                x2  := AFirst ? xB : xA
                y1  := AFirst ?
                 ABottom ? yAB : yAT :
                 ABottom ? yBT : yBB
                y2  := AFirst ?
                 ABottom ? yBT : yBB :
                 ABottom ? yAB : yAT
        'Liq'   =>
            if b_liq_B.size() > 0 and b_liq_S.size() > 0
                xA = nz(
                   b_liq_B.get(0).ln.get_x1    ()
                 , b_liq_B.get(0).bx.get_left  ()
                 )
                xB = nz(
                   b_liq_S.get(0).ln.get_x1    ()
                 , b_liq_S.get(0).bx.get_left  ()
                 )
                AFirst = xB > xA
                yAT = nz(
                   b_liq_B.get(0).ln.get_y1    ()
                 , b_liq_B.get(0).bx.get_top   ()
                 )
                yAB = nz(
                   b_liq_B.get(0).ln.get_y1    ()
                 , b_liq_B.get(0).bx.get_bottom()
                 )
                yBT = nz(
                   b_liq_S.get(0).ln.get_y1    ()
                 , b_liq_S.get(0).bx.get_top   ()
                 )
                yBB = nz(
                   b_liq_S.get(0).ln.get_y1    ()
                 , b_liq_S.get(0).bx.get_bottom()
                 )
                ABottom = yAB < yBB
                x1  := AFirst ? xA : xB
                x2  := AFirst ? xB : xA
                y1  := AFirst ?
                 ABottom ? yAB : yAT :
                 ABottom ? yBT : yBB
                y2  := AFirst ?
                 ABottom ? yBT : yBB :
                 ABottom ? yAB : yAT
        'VI'    =>
            if Vimbal.size() > 1
                AxA = Vimbal.get(1).l2.get_x1(), AxB = Vimbal.get(1).l1.get_x1()
                BxA = Vimbal.get(0).l2.get_x1(), BxB = Vimbal.get(0).l1.get_x1()
                AyA = Vimbal.get(1).l2.get_y1(), AyB = Vimbal.get(1).l1.get_y1()
                ByA = Vimbal.get(0).l2.get_y1(), ByB = Vimbal.get(0).l1.get_y1()
                ABt = math.min(ByA, ByB) > math.min(AyA, AyB)
                x1 := math.max(AxA, AxB)
                x2 := math.max(BxA, BxB)
                y1 := ABt ? math.min(AyA, AyB) : math.max(AyA, AyB)
                y2 := ABt ? math.max(ByA, ByB) : math.min(ByA, ByB)
        'NWOG'  =>
            if bl_NWOG.size() > 1
                up  := bl_NWOG.get(0).b
                dn  := bl_NWOG.get(1).b
                dnFirst = up.get_left() > dn.get_left()
                dnBottm = up.get_top () > dn.get_top ()
                x1  := dnFirst ? dn.get_left () : up.get_left ()
                x2  := dnFirst ? up.get_right() : dn.get_right()
                y1  := dnFirst ?
                 dnBottm ? dn.get_bottom() : dn.get_top   () :
                 dnBottm ? up.get_top   () : up.get_bottom()
                y2  := dnFirst ?
                 dnBottm ? up.get_top   () : up.get_bottom() :
                 dnBottm ? dn.get_bottom() : dn.get_top   ()
    if iFib != 'NONE'
        rt = math.max(x1, x2)
        lt = math.min(x1, x2)
        tp = math.max(y1, y2)
        bt = math.min(y1, y2)
        _0 = rt == x1 ? y1 : y2
        _1 = rt == x1 ? y2 : y1
        df = _1 - _0
        m0236 = df * 0.236
        m0382 = df * 0.382
        m0500 = df * 0.500
        m0618 = df * 0.618
        m0786 = df * 0.786
        m1618 = df * 1.618
        _diag.setLine(x1, y1        , x2       , y2        )
        _vert.setLine(rt, _0        , rt       , _0 + m1618)
        _zero.setLine(rt, _0        , rt + plus, _0        )
        _0236.setLine(rt, _0 + m0236, rt + plus, _0 + m0236)
        _0382.setLine(rt, _0 + m0382, rt + plus, _0 + m0382)
        _0500.setLine(rt, _0 + m0500, rt + plus, _0 + m0500)
        _0618.setLine(rt, _0 + m0618, rt + plus, _0 + m0618)
        _0786.setLine(rt, _0 + m0786, rt + plus, _0 + m0786)
        _one_.setLine(rt, _1        , rt + plus, _1        )
        _1618.setLine(rt, _0 + m1618, rt + plus, _0 + m1618)

plotshape(sDispl ? per       ?
     L_bodyUP    ? low  : na : na : na
     , title     = 'Displacement UP'
     , style     = shape.labelup
     , color     = color.lime
     , location  = location.belowbar)
plotshape(sDispl ? per       ?
     L_bodyDN    ? high : na : na : na
     , title     = 'Displacement DN'
     , style     = shape.labeldown
     , color     = color.red
     , location  = location.abovebar)

bgcolor  (per    ? ny        ? nyCss   : na : na, editable = false)
bgcolor  (per    ? ldn_open  ? ldnoCss : na : na, editable = false)
bgcolor  (per    ? ldn_close ? ldncCss : na : na, editable = false)
bgcolor  (per    ? asian     ? asiaCss : na : na, editable = false)


const int BULLISH_LEG                     = 1
const int BEARISH_LEG                     = 0

const int BULLISH                         = +1
const int BEARISH                         = -1

const color GREEN                          = #089981
const color RED                            = #F23645
const color BLUE                           = #2157f3
const color GRAY                           = #878b94
const color MONO_BULLISH                   = #b2b5be
const color MONO_BEARISH                   = #5d606b

const string HISTORICAL                    = 'Historical'
const string PRESENT                       = 'Present'

const string COLORED                       = 'Colored'
const string MONOCHROME                    = 'Monochrome'

const string ALL                           = 'All'
const string BOS                           = 'BOS'
const string CHOCH                         = 'CHoCH'

const string TINY                          = size.tiny
const string SMALL                         = size.small
const string NORMAL                        = size.normal

const string ATR                           = 'Atr'
const string RANGE                         = 'Cumulative Mean Range'

const string CLOSE                         = 'Close'
const string HIGHLOW                       = 'High/Low'

const string SOLID                         = '⎯⎯⎯'
const string DASHED                        = '----'
const string DOTTED                        = '····'

const string SMART_GROUP                   = 'Smart Money Concepts'
const string INTERNAL_GROUP                = 'Real Time Internal Structure'
const string SWING_GROUP                   = 'Real Time Swing Structure'
const string BLOCKS_GROUP                  = 'Order Blocks'
const string EQUAL_GROUP                   = 'EQH/EQL'
const string GAPS_GROUP                    = 'Fair Value Gaps'
const string LEVELS_GROUP                  = 'Highs & Lows MTF'
const string ZONES_GROUP                   = 'Premium & Discount Zones'


modeInput                       = input.string( HISTORICAL, 'Mode',                     group = SMART_GROUP, options = [HISTORICAL, PRESENT])
styleInput                      = input.string( COLORED,    'Style',                    group = SMART_GROUP, options = [COLORED, MONOCHROME])
showTrendInput                  = input(        false,      'Color Candles',            group = SMART_GROUP)

showInternalsInput              = input(        true,       'Show Internal Structure',  group = INTERNAL_GROUP)
showInternalBullInput           = input.string( ALL,        'Bullish Structure',        group = INTERNAL_GROUP, inline = 'ibull', options = [ALL,BOS,CHOCH])
internalBullColorInput          = input(        GREEN,      '',                         group = INTERNAL_GROUP, inline = 'ibull')
showInternalBearInput           = input.string( ALL,        'Bearish Structure' ,       group = INTERNAL_GROUP, inline = 'ibear', options = [ALL,BOS,CHOCH])
internalBearColorInput          = input(        RED,        '',                         group = INTERNAL_GROUP, inline = 'ibear')
internalFilterConfluenceInput   = input(        false,      'Confluence Filter',        group = INTERNAL_GROUP)
internalStructureSize           = input.string( TINY,       'Internal Label Size',      group = INTERNAL_GROUP, options = [TINY,SMALL,NORMAL])

showStructureInput              = input(        true,       'Show Swing Structure',     group = SWING_GROUP)
showSwingBullInput              = input.string( ALL,        'Bullish Structure',        group = SWING_GROUP,    inline = 'bull',    options = [ALL,BOS,CHOCH])
swingBullColorInput             = input(        GREEN,      '',                         group = SWING_GROUP,    inline = 'bull')
showSwingBearInput              = input.string( ALL,        'Bearish Structure',        group = SWING_GROUP,    inline = 'bear',    options = [ALL,BOS,CHOCH])
swingBearColorInput             = input(        RED,        '',                         group = SWING_GROUP,    inline = 'bear')
swingStructureSize              = input.string( SMALL,      'Swing Label Size',         group = SWING_GROUP,    options = [TINY,SMALL,NORMAL])
showSwingsInput                 = input(        false,      'Show Swings Points',       group = SWING_GROUP,inline = 'swings')
swingsLengthInputRaw            = input.int(    50,         '',                         group = SWING_GROUP,                    inline = 'swings')
swingsLengthInput               = ensureMinInt(swingsLengthInputRaw, 10)
showHighLowSwingsInput          = input(        true,       'Show Strong/Weak High/Low',group = SWING_GROUP)

showInternalOrderBlocksInput    = input(        true,       'Internal Order Blocks' ,   group = BLOCKS_GROUP,   inline = 'iob')
internalOrderBlocksSizeInputRaw = input.int(    5,          '',                         group = BLOCKS_GROUP,                     inline = 'iob')
internalOrderBlocksSizeInput    = clampInt(internalOrderBlocksSizeInputRaw, 1, 20)
showSwingOrderBlocksInput       = input(        false,      'Swing Order Blocks',       group = BLOCKS_GROUP,      inline = 'ob')
swingOrderBlocksSizeInputRaw    = input.int(    5,          '',                         group = BLOCKS_GROUP,                     inline = 'ob')
swingOrderBlocksSizeInput       = clampInt(swingOrderBlocksSizeInputRaw, 1, 20)
orderBlockFilterInput           = input.string( 'Atr',      'Order Block Filter',       group = BLOCKS_GROUP,          options = [ATR, RANGE])
orderBlockMitigationInput       = input.string( HIGHLOW,    'Order Block Mitigation',   group = BLOCKS_GROUP,      options = [CLOSE,HIGHLOW])
internalBullishOrderBlockColor  = input.color(color.new(#3179f5, 80), 'Internal Bullish OB',    group = BLOCKS_GROUP)
internalBearishOrderBlockColor  = input.color(color.new(#f77c80, 80), 'Internal Bearish OB',    group = BLOCKS_GROUP)
swingBullishOrderBlockColor     = input.color(color.new(#1848cc, 80), 'Bullish OB',             group = BLOCKS_GROUP)
swingBearishOrderBlockColor     = input.color(color.new(#b22833, 80), 'Bearish OB',             group = BLOCKS_GROUP)

showEqualHighsLowsInput         = input(        true,       'Equal High/Low',           group = EQUAL_GROUP)
equalHighsLowsLengthInputRaw    = input.int(    3,          'Bars Confirmation',        group = EQUAL_GROUP)
equalHighsLowsLengthInput       = ensureMinInt(equalHighsLowsLengthInputRaw, 1)
equalHighsLowsThresholdInputRaw = input.float(  0.1,        'Threshold',                group = EQUAL_GROUP,   step = 0.1)
equalHighsLowsThresholdInput    = clampFloat(equalHighsLowsThresholdInputRaw, 0.0, 0.5)
equalHighsLowsSizeInput         = input.string( TINY,       'Label Size',               group = EQUAL_GROUP,    options = [TINY,SMALL,NORMAL])

showFairValueGapsInput          = input(        false,      'Fair Value Gaps',          group = GAPS_GROUP)
fairValueGapsThresholdInput     = input(        true,       'Auto Threshold',           group = GAPS_GROUP)
fairValueGapsTimeframeInput     = input.timeframe('',       'Timeframe',                group = GAPS_GROUP)
fairValueGapsBullColorInput     = input.color(color.new(#00ff68, 70), 'Bullish FVG' , group = GAPS_GROUP)
fairValueGapsBearColorInput     = input.color(color.new(#ff0008, 70), 'Bearish FVG' , group = GAPS_GROUP)
fairValueGapsExtendInputRaw     = input.int(    1,          'Extend FVG',               group = GAPS_GROUP)
fairValueGapsExtendInput        = nonNegativeInt(fairValueGapsExtendInputRaw)

showDailyLevelsInput            = input(        false,      'Daily',    group = LEVELS_GROUP,   inline = 'daily')
dailyLevelsStyleInput           = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'daily',   options = [SOLID,DASHED,DOTTED])
dailyLevelsColorInput           = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'daily')
showWeeklyLevelsInput           = input(        false,      'Weekly',   group = LEVELS_GROUP,   inline = 'weekly')
weeklyLevelsStyleInput          = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'weekly',  options = [SOLID,DASHED,DOTTED])
weeklyLevelsColorInput          = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'weekly')
showMonthlyLevelsInput          = input(        false,      'Monthly',   group = LEVELS_GROUP,   inline = 'monthly')
monthlyLevelsStyleInput         = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'monthly', options = [SOLID,DASHED,DOTTED])
monthlyLevelsColorInput         = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'monthly')

showPremiumDiscountZonesInput   = input(        false,      'Premium/Discount Zones',   group = ZONES_GROUP )
premiumZoneColorInput           = input.color(  RED,        'Premium Zone',             group = ZONES_GROUP)
equilibriumZoneColorInput       = input.color(  GRAY,       'Equilibrium Zone',         group = ZONES_GROUP)
discountZoneColorInput          = input.color(  GREEN,      'Discount Zone',            group = ZONES_GROUP)



type alerts
    bool internalBullishBOS         = false
    bool internalBearishBOS         = false
    bool internalBullishCHoCH       = false
    bool internalBearishCHoCH       = false
    bool swingBullishBOS            = false
    bool swingBearishBOS            = false
    bool swingBullishCHoCH          = false
    bool swingBearishCHoCH          = false
    bool internalBullishOrderBlock  = false
    bool internalBearishOrderBlock  = false
    bool swingBullishOrderBlock     = false
    bool swingBearishOrderBlock     = false
    bool equalHighs                 = false
    bool equalLows                  = false
    bool bullishFairValueGap        = false
    bool bearishFairValueGap        = false

type trailingExtremes
    float top
    float bottom
    int barTime
    int barIndex
    int lastTopTime
    int lastBottomTime

type fairValueGap
    float top
    float bottom
    int bias
    box topBox
    box bottomBox

type trend
    int bias

type equalDisplay
    line l_ine      = na
    label l_abel    = na

type pivot
    float currentLevel
    float lastLevel
    bool crossed
    int barTime     = time
    int barIndex    = bar_index

type orderBlock
    float barHigh
    float barLow
    int barTime
    int bias

var pivot swingHigh                 = pivot.new(na,na,false)
var pivot swingLow                  = pivot.new(na,na,false)
var pivot internalHigh              = pivot.new(na,na,false)
var pivot internalLow               = pivot.new(na,na,false)
var pivot equalHigh                 = pivot.new(na,na,false)
var pivot equalLow                  = pivot.new(na,na,false)
var trend swingTrend                = trend.new(0)
var trend internalTrend             = trend.new(0)
var equalDisplay equalHighDisplay   = equalDisplay.new()
var equalDisplay equalLowDisplay    = equalDisplay.new()
var array<fairValueGap> fairValueGaps = array.new<fairValueGap>()
var array<float> parsedHighs        = array.new<float>()
var array<float> parsedLows         = array.new<float>()
var array<float> highs              = array.new<float>()
var array<float> lows               = array.new<float>()
var array<int> times                = array.new<int>()
var trailingExtremes trailing       = trailingExtremes.new()
var array<orderBlock> swingOrderBlocks      = array.new<orderBlock>()
var array<orderBlock> internalOrderBlocks   = array.new<orderBlock>()
var array<box> swingOrderBlocksBoxes        = array.new<box>()
var array<box> internalOrderBlocksBoxes     = array.new<box>()
var swingBullishColor               = styleInput == MONOCHROME ? MONO_BULLISH : swingBullColorInput
var swingBearishColor               = styleInput == MONOCHROME ? MONO_BEARISH : swingBearColorInput
var fairValueGapBullishColor        = styleInput == MONOCHROME ? color.new(MONO_BULLISH,70) : fairValueGapsBullColorInput
var fairValueGapBearishColor        = styleInput == MONOCHROME ? color.new(MONO_BEARISH,70) : fairValueGapsBearColorInput
var premiumZoneColor                = styleInput == MONOCHROME ? MONO_BEARISH : premiumZoneColorInput
var discountZoneColor               = styleInput == MONOCHROME ? MONO_BULLISH : discountZoneColorInput
varip int currentBarIndex           = bar_index
varip int lastBarIndex              = bar_index
alerts currentAlerts                = alerts.new()
var initialTime                     = time

if barstate.isfirst
    if showSwingOrderBlocksInput
        for index = 1 to swingOrderBlocksSizeInput
            swingOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time,extend = extend.right))
    if showInternalOrderBlocksInput
        for index = 1 to internalOrderBlocksSizeInput
            internalOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time,extend = extend.right))

bearishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : high
bullishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : low
atrMeasure                          = ta.atr(200)
volatilityMeasure                   = orderBlockFilterInput == ATR ? atrMeasure : ta.cum(ta.tr)/bar_index
highVolatilityBar                   = (high - low) >= (2 * volatilityMeasure)
parsedHigh                          = highVolatilityBar ? low : high
parsedLow                           = highVolatilityBar ? high : low

parsedHighs.push(parsedHigh)
parsedLows.push(parsedLow)
highs.push(high)
lows.push(low)
times.push(time)

leg(int size) =>
    var leg     = 0
    newLegHigh  = high[size] > ta.highest( size)
    newLegLow   = low[size]  < ta.lowest(  size)

    if newLegHigh
        leg := BEARISH_LEG
    else if newLegLow
        leg := BULLISH_LEG
    leg

startOfNewLeg(int leg)      => ta.change(leg) != 0

startOfBearishLeg(int leg)  => ta.change(leg) == -1

startOfBullishLeg(int leg)  => ta.change(leg) == +1

drawLabel(int labelTime, float labelPrice, string tag, color labelColor, string labelStyle) =>
    var label l_abel = na

    if modeInput == PRESENT
        l_abel.delete()

    l_abel := label.new(chart.point.new(labelTime,na,labelPrice),tag,xloc.bar_time,color=na,textcolor=labelColor,style = labelStyle,size = size.small)

drawEqualHighLow(pivot p_ivot, float level, int size, bool equalHigh) =>
    equalDisplay e_qualDisplay = equalHigh ? equalHighDisplay : equalLowDisplay

    string tag          = 'EQL'
    color equalColor    = swingBullishColor
    string labelStyle   = label.style_label_up

    if equalHigh
        tag         := 'EQH'
        equalColor  := swingBearishColor
        labelStyle  := label.style_label_down

    if modeInput == PRESENT
        line.delete(    e_qualDisplay.l_ine)
        label.delete(   e_qualDisplay.l_abel)

    e_qualDisplay.l_ine     := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time[size],na,level), xloc = xloc.bar_time, color = equalColor, style = line.style_dotted)
    labelPosition           = math.round(0.5*(p_ivot.barIndex + bar_index - size))
    e_qualDisplay.l_abel    := label.new(chart.point.new(na,labelPosition,level), tag, xloc.bar_index, color = na, textcolor = equalColor, style = labelStyle, size = equalHighsLowsSizeInput)

getCurrentStructure(int size,bool equalHighLow = false, bool internal = false) =>
    currentLeg              = leg(size)
    newPivot                = startOfNewLeg(currentLeg)
    pivotLow                = startOfBullishLeg(currentLeg)
    pivotHigh               = startOfBearishLeg(currentLeg)

    if newPivot
        if pivotLow
            pivot p_ivot    = equalHighLow ? equalLow : internal ? internalLow : swingLow

            if equalHighLow and math.abs(p_ivot.currentLevel - low[size]) < equalHighsLowsThresholdInput * atrMeasure
                drawEqualHighLow(p_ivot, low[size], size, false)
                currentAlerts.equalLows := true

            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := low[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]

            if not equalHighLow and not internal
                trailing.bottom         := p_ivot.currentLevel
                trailing.barTime        := p_ivot.barTime
                trailing.barIndex       := p_ivot.barIndex
                trailing.lastBottomTime := p_ivot.barTime

            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel < p_ivot.lastLevel ? 'LL' : 'HL', swingBullishColor, label.style_label_up)
        else
            pivot p_ivot = equalHighLow ? equalHigh : internal ? internalHigh : swingHigh

            if equalHighLow and math.abs(p_ivot.currentLevel - high[size]) < equalHighsLowsThresholdInput * atrMeasure
                drawEqualHighLow(p_ivot,high[size],size,true)
                currentAlerts.equalHighs := true

            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := high[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]

            if not equalHighLow and not internal
                trailing.top            := p_ivot.currentLevel
                trailing.barTime        := p_ivot.barTime
                trailing.barIndex       := p_ivot.barIndex
                trailing.lastTopTime    := p_ivot.barTime

            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel > p_ivot.lastLevel ? 'HH' : 'LH', swingBearishColor, label.style_label_down)

drawStructure(pivot p_ivot, string tag, color structureColor, string lineStyle, string labelStyle, string labelSize) =>
    var line l_ine      = line.new(na,na,na,na,xloc = xloc.bar_time)
    var label l_abel    = label.new(na,na)

    if modeInput == PRESENT
        l_ine.delete()
        l_abel.delete()

    l_ine   := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time,na,p_ivot.currentLevel), xloc.bar_time, color=structureColor, style=lineStyle)
    l_abel  := label.new(chart.point.new(na,math.round(0.5*(p_ivot.barIndex+bar_index)),p_ivot.currentLevel), tag, xloc.bar_index, color=na, textcolor=structureColor, style=labelStyle, size = labelSize)

deleteOrderBlocks(bool internal = false) =>
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks

    for [index,eachOrderBlock] in orderBlocks
        bool crossedOderBlock = false

        if bearishOrderBlockMitigationSource > eachOrderBlock.barHigh and eachOrderBlock.bias == BEARISH
            crossedOderBlock := true
            if internal
                currentAlerts.internalBearishOrderBlock := true
            else
                currentAlerts.swingBearishOrderBlock    := true
        else if bullishOrderBlockMitigationSource < eachOrderBlock.barLow and eachOrderBlock.bias == BULLISH
            crossedOderBlock := true
            if internal
                currentAlerts.internalBullishOrderBlock := true
            else
                currentAlerts.swingBullishOrderBlock    := true
        if crossedOderBlock
            orderBlocks.remove(index)

storeOrdeBlock(pivot p_ivot,bool internal = false,int bias) =>
    if (not internal and showSwingOrderBlocksInput) or (internal and showInternalOrderBlocksInput)

        array<float> a_rray = na
        int parsedIndex = na

        if bias == BEARISH
            a_rray      := parsedHighs.slice(p_ivot.barIndex,bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.max())
        else
            a_rray      := parsedLows.slice(p_ivot.barIndex,bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.min())

        orderBlock o_rderBlock          = orderBlock.new(parsedHighs.get(parsedIndex), parsedLows.get(parsedIndex), times.get(parsedIndex),bias)
        array<orderBlock> orderBlocks   = internal ? internalOrderBlocks : swingOrderBlocks

        if orderBlocks.size() >= 100
            orderBlocks.pop()
        orderBlocks.unshift(o_rderBlock)

drawOrderBlocks(bool internal = false) =>
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks
    orderBlocksSize = orderBlocks.size()

    if orderBlocksSize > 0
        maxOrderBlocks                      = internal ? internalOrderBlocksSizeInput : swingOrderBlocksSizeInput
        array<orderBlock> parsedOrdeBlocks  = orderBlocks.slice(0, math.min(maxOrderBlocks,orderBlocksSize))
        array<box> b_oxes                   = internal ? internalOrderBlocksBoxes : swingOrderBlocksBoxes

        for [index,eachOrderBlock] in parsedOrdeBlocks
            orderBlockColor = styleInput == MONOCHROME ? (eachOrderBlock.bias == BEARISH ? color.new(MONO_BEARISH,80) : color.new(MONO_BULLISH,80)) : internal ? (eachOrderBlock.bias == BEARISH ? internalBearishOrderBlockColor : internalBullishOrderBlockColor) : (eachOrderBlock.bias == BEARISH ? swingBearishOrderBlockColor : swingBullishOrderBlockColor)

            box b_ox        = b_oxes.get(index)
            b_ox.set_top_left_point(    chart.point.new(eachOrderBlock.barTime,na,eachOrderBlock.barHigh))
            b_ox.set_bottom_right_point(chart.point.new(last_bar_time,na,eachOrderBlock.barLow))
            b_ox.set_border_color(      internal ? na : orderBlockColor)
            b_ox.set_bgcolor(           orderBlockColor)

displayStructure(bool internal = false) =>
    var bullishBar = true
    var bearishBar = true

    if internalFilterConfluenceInput
        bullishBar := high - math.max(close, open) > math.min(close, open - low)
        bearishBar := high - math.max(close, open) < math.min(close, open - low)

    pivot p_ivot    = internal ? internalHigh : swingHigh
    trend t_rend    = internal ? internalTrend : swingTrend

    lineStyle       = internal ? line.style_dashed : line.style_solid
    labelSize       = internal ? internalStructureSize : swingStructureSize

    extraCondition  = internal ? internalHigh.currentLevel != swingHigh.currentLevel and bullishBar : true
    bullishColor    = styleInput == MONOCHROME ? MONO_BULLISH : internal ? internalBullColorInput : swingBullColorInput

    if ta.crossover(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == BEARISH ? CHOCH : BOS

        if internal
            currentAlerts.internalBullishCHoCH  := tag == CHOCH
            currentAlerts.internalBullishBOS    := tag == BOS
        else
            currentAlerts.swingBullishCHoCH     := tag == CHOCH
            currentAlerts.swingBullishBOS       := tag == BOS

        p_ivot.crossed  := true
        t_rend.bias     := BULLISH

        displayCondition = internal ? showInternalsInput and (showInternalBullInput == ALL or (showInternalBullInput == BOS and tag != CHOCH) or (showInternalBullInput == CHOCH and tag == CHOCH)) : showStructureInput and (showSwingBullInput == ALL or (showSwingBullInput == BOS and tag != CHOCH) or (showSwingBullInput == CHOCH and tag == CHOCH))

        if displayCondition
            drawStructure(p_ivot,tag,bullishColor,lineStyle,label.style_label_down,labelSize)

        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot,internal,BULLISH)

    p_ivot          := internal ? internalLow : swingLow
    extraCondition  := internal ? internalLow.currentLevel != swingLow.currentLevel and bearishBar : true
    bearishColor    = styleInput == MONOCHROME ? MONO_BEARISH : internal ? internalBearColorInput : swingBearColorInput

    if ta.crossunder(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == BULLISH ? CHOCH : BOS

        if internal
            currentAlerts.internalBearishCHoCH  := tag == CHOCH
            currentAlerts.internalBearishBOS    := tag == BOS
        else
            currentAlerts.swingBearishCHoCH     := tag == CHOCH
            currentAlerts.swingBearishBOS       := tag == BOS

        p_ivot.crossed := true
        t_rend.bias := BEARISH

        displayCondition = internal ? showInternalsInput and (showInternalBearInput == ALL or (showInternalBearInput == BOS and tag != CHOCH) or (showInternalBearInput == CHOCH and tag == CHOCH)) : showStructureInput and (showSwingBearInput == ALL or (showSwingBearInput == BOS and tag != CHOCH) or (showSwingBearInput == CHOCH and tag == CHOCH))

        if displayCondition
            drawStructure(p_ivot,tag,bearishColor,lineStyle,label.style_label_up,labelSize)

        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot,internal,BEARISH)

fairValueGapBox(leftTime,rightTime,topPrice,bottomPrice,boxColor) => box.new(chart.point.new(leftTime,na,topPrice),chart.point.new(rightTime + fairValueGapsExtendInput * (time-time[1]),na,bottomPrice), xloc=xloc.bar_time, border_color = boxColor, bgcolor = boxColor)

deleteFairValueGaps() =>
    for [index,eachFairValueGap] in fairValueGaps
        if (low < eachFairValueGap.bottom and eachFairValueGap.bias == BULLISH) or (high > eachFairValueGap.top and eachFairValueGap.bias == BEARISH)
            eachFairValueGap.topBox.delete()
            eachFairValueGap.bottomBox.delete()
            fairValueGaps.remove(index)

drawFairValueGaps() =>
    [lastClose, lastOpen, lastTime, currentHigh, currentLow, currentTime, last2High, last2Low] = request.security(syminfo.tickerid, fairValueGapsTimeframeInput, [close[1], open[1], time[1], high[0], low[0], time[0], high[2], low[2]],lookahead = barmerge.lookahead_on)

    barDeltaPercent     = (lastClose - lastOpen) / (lastOpen * 100)
    newTimeframe        = timeframe.change(fairValueGapsTimeframeInput)
    threshold           = fairValueGapsThresholdInput ? ta.cum(math.abs(newTimeframe ? barDeltaPercent : 0)) / bar_index * 2 : 0

    bullishFairValueGap = currentLow > last2High and lastClose > last2High and barDeltaPercent > threshold and newTimeframe
    bearishFairValueGap = currentHigh < last2Low and lastClose < last2Low and -barDeltaPercent > threshold and newTimeframe

    if bullishFairValueGap
        currentAlerts.bullishFairValueGap := true
        midPoint = (currentLow + last2High) / 2
        fairValueGaps.unshift(fairValueGap.new(currentLow,last2High,BULLISH,fairValueGapBox(lastTime,currentTime,currentLow,midPoint,fairValueGapBullishColor),fairValueGapBox(lastTime,currentTime,midPoint,last2High,fairValueGapBullishColor)))
    if bearishFairValueGap
        currentAlerts.bearishFairValueGap := true
        midPoint = (currentHigh + last2Low) / 2
        fairValueGaps.unshift(fairValueGap.new(currentHigh,last2Low,BEARISH,fairValueGapBox(lastTime,currentTime,currentHigh,midPoint,fairValueGapBearishColor),fairValueGapBox(lastTime,currentTime,midPoint,last2Low,fairValueGapBearishColor)))

getStyle(string style) =>
    switch style
        SOLID => line.style_solid
        DASHED => line.style_dashed
        DOTTED => line.style_dotted

drawLevels(string timeframe, bool sameTimeframe, string style, color levelColor) =>
    [topLevel, bottomLevel, leftTime, rightTime] = request.security(syminfo.tickerid, timeframe, [high[1], low[1], time[1], time],lookahead = barmerge.lookahead_on)

    float parsedTop         = sameTimeframe ? high : topLevel
    float parsedBottom      = sameTimeframe ? low : bottomLevel

    int parsedLeftTime      = sameTimeframe ? time : leftTime
    int parsedRightTime     = sameTimeframe ? time : rightTime

    int parsedTopTime       = time
    int parsedBottomTime    = time

    if not sameTimeframe
        int leftIndex               = times.binary_search_rightmost(parsedLeftTime)
        int rightIndex              = times.binary_search_rightmost(parsedRightTime)

        array<int> timeArray        = times.slice(leftIndex,rightIndex)
        array<float> topArray       = highs.slice(leftIndex,rightIndex)
        array<float> bottomArray    = lows.slice(leftIndex,rightIndex)

        parsedTopTime               := timeArray.size() > 0 ? timeArray.get(topArray.indexof(topArray.max())) : initialTime
        parsedBottomTime            := timeArray.size() > 0 ? timeArray.get(bottomArray.indexof(bottomArray.min())) : initialTime

    var line topLine        = line.new(na, na, na, na, xloc = xloc.bar_time, color = levelColor, style = getStyle(style))
    var line bottomLine     = line.new(na, na, na, na, xloc = xloc.bar_time, color = levelColor, style = getStyle(style))
    var label topLabel      = label.new(na, na, xloc = xloc.bar_time, text = str.format('P{0}H',timeframe), color=na, textcolor = levelColor, size = size.small, style = label.style_label_left)
    var label bottomLabel   = label.new(na, na, xloc = xloc.bar_time, text = str.format('P{0}L',timeframe), color=na, textcolor = levelColor, size = size.small, style = label.style_label_left)

    topLine.set_first_point(    chart.point.new(parsedTopTime,na,parsedTop))
    topLine.set_second_point(   chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedTop))
    topLabel.set_point(         chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedTop))

    bottomLine.set_first_point( chart.point.new(parsedBottomTime,na,parsedBottom))
    bottomLine.set_second_point(chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedBottom))
    bottomLabel.set_point(      chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedBottom))

higherTimeframe(string timeframe) => timeframe.in_seconds() > timeframe.in_seconds(timeframe)

updateTrailingExtremes() =>
    trailing.top            := math.max(high,trailing.top)
    trailing.lastTopTime    := trailing.top == high ? time : trailing.lastTopTime
    trailing.bottom         := math.min(low,trailing.bottom)
    trailing.lastBottomTime := trailing.bottom == low ? time : trailing.lastBottomTime

drawHighLowSwings() =>
    var line topLine        = line.new(na, na, na, na, color = swingBearishColor, xloc = xloc.bar_time)
    var line bottomLine     = line.new(na, na, na, na, color = swingBullishColor, xloc = xloc.bar_time)
    var label topLabel      = label.new(na, na, color=na, textcolor = swingBearishColor, xloc = xloc.bar_time, style = label.style_label_down, size = size.tiny)
    var label bottomLabel   = label.new(na, na, color=na, textcolor = swingBullishColor, xloc = xloc.bar_time, style = label.style_label_up, size = size.tiny)

    rightTimeBar            = last_bar_time + 20 * (time - time[1])

    topLine.set_first_point(    chart.point.new(trailing.lastTopTime, na, trailing.top))
    topLine.set_second_point(   chart.point.new(rightTimeBar, na, trailing.top))
    topLabel.set_point(         chart.point.new(rightTimeBar, na, trailing.top))
    topLabel.set_text(          swingTrend.bias == BEARISH ? 'Strong High' : 'Weak High')

    bottomLine.set_first_point( chart.point.new(trailing.lastBottomTime, na, trailing.bottom))
    bottomLine.set_second_point(chart.point.new(rightTimeBar, na, trailing.bottom))
    bottomLabel.set_point(      chart.point.new(rightTimeBar, na, trailing.bottom))
    bottomLabel.set_text(       swingTrend.bias == BULLISH ? 'Strong Low' : 'Weak Low')

drawZone(float labelLevel, int labelIndex, float top, float bottom, string tag, color zoneColor, string style) =>
    var label l_abel    = label.new(na,na,text = tag, color=na,textcolor = zoneColor, style = style, size = size.small)
    var box b_ox        = box.new(na,na,na,na,bgcolor = color.new(zoneColor,80),border_color = na, xloc = xloc.bar_time)

    b_ox.set_top_left_point(    chart.point.new(trailing.barTime,na,top))
    b_ox.set_bottom_right_point(chart.point.new(last_bar_time,na,bottom))

    l_abel.set_point(           chart.point.new(na,labelIndex,labelLevel))

drawPremiumDiscountZones() =>
    drawZone(trailing.top, math.round(0.5*(trailing.barIndex + last_bar_index)), trailing.top, 0.95*trailing.top + 0.05*trailing.bottom, 'Premium', premiumZoneColor, label.style_label_down)

    equilibriumLevel = (trailing.top + trailing.bottom) / 2
    drawZone(equilibriumLevel, last_bar_index, 0.525*trailing.top + 0.475*trailing.bottom, 0.525*trailing.bottom + 0.475*trailing.top, 'Equilibrium', equilibriumZoneColorInput, label.style_label_left)

    drawZone(trailing.bottom, math.round(0.5*(trailing.barIndex + last_bar_index)), 0.95*trailing.bottom + 0.05*trailing.top, trailing.bottom, 'Discount', discountZoneColor, label.style_label_up)

parsedOpen  = showTrendInput ? open : na
candleColor = internalTrend.bias == BULLISH ? swingBullishColor : swingBearishColor
plotcandle(parsedOpen,high,low,close,color = candleColor, wickcolor = candleColor, bordercolor = candleColor)

if showHighLowSwingsInput or showPremiumDiscountZonesInput
    updateTrailingExtremes()

    if showHighLowSwingsInput
        drawHighLowSwings()

    if showPremiumDiscountZonesInput
        drawPremiumDiscountZones()

if showFairValueGapsInput
    deleteFairValueGaps()

getCurrentStructure(swingsLengthInput,false)
getCurrentStructure(5,false,true)

if showEqualHighsLowsInput
    getCurrentStructure(equalHighsLowsLengthInput,true)

if showInternalsInput or showInternalOrderBlocksInput or showTrendInput
    displayStructure(true)

if showStructureInput or showSwingOrderBlocksInput or showHighLowSwingsInput
    displayStructure()

if showInternalOrderBlocksInput
    deleteOrderBlocks(true)

if showSwingOrderBlocksInput
    deleteOrderBlocks()

if showFairValueGapsInput
    drawFairValueGaps()

if barstate.islastconfirmedhistory or barstate.islast
    if showInternalOrderBlocksInput
        drawOrderBlocks(true)

    if showSwingOrderBlocksInput
        drawOrderBlocks()

lastBarIndex    := currentBarIndex
currentBarIndex := bar_index
newBar          = currentBarIndex != lastBarIndex

if barstate.islastconfirmedhistory or (barstate.isrealtime and newBar)
    if showDailyLevelsInput and not higherTimeframe('D')
        drawLevels('D',timeframe.isdaily,dailyLevelsStyleInput,dailyLevelsColorInput)

    if showWeeklyLevelsInput and not higherTimeframe('W')
        drawLevels('W',timeframe.isweekly,weeklyLevelsStyleInput,weeklyLevelsColorInput)

    if showMonthlyLevelsInput and not higherTimeframe('M')
        drawLevels('M',timeframe.ismonthly,monthlyLevelsStyleInput,monthlyLevelsColorInput)

alertcondition(currentAlerts.internalBullishBOS,        'Internal Bullish BOS',         'Internal Bullish BOS formed')
alertcondition(currentAlerts.internalBullishCHoCH,      'Internal Bullish CHoCH',       'Internal Bullish CHoCH formed')
alertcondition(currentAlerts.internalBearishBOS,        'Internal Bearish BOS',         'Internal Bearish BOS formed')
alertcondition(currentAlerts.internalBearishCHoCH,      'Internal Bearish CHoCH',       'Internal Bearish CHoCH formed')
alertcondition(currentAlerts.swingBullishBOS,           'Bullish BOS',                  'Internal Bullish BOS formed')
alertcondition(currentAlerts.swingBullishCHoCH,         'Bullish CHoCH',                'Internal Bullish CHoCH formed')
alertcondition(currentAlerts.swingBearishBOS,           'Bearish BOS',                  'Bearish BOS formed')
alertcondition(currentAlerts.swingBearishCHoCH,         'Bearish CHoCH',                'Bearish CHoCH formed')
alertcondition(currentAlerts.internalBullishOrderBlock, 'Bullish Internal OB Breakout', 'Price broke bullish internal OB')
alertcondition(currentAlerts.internalBearishOrderBlock, 'Bearish Internal OB Breakout', 'Price broke bearish internal OB')
alertcondition(currentAlerts.swingBullishOrderBlock,    'Bullish Swing OB Breakout',    'Price broke bullish swing OB')
alertcondition(currentAlerts.swingBearishOrderBlock,    'Bearish Swing OB Breakout',    'Price broke bearish swing OB')
alertcondition(currentAlerts.equalHighs,                'Equal Highs',                  'Equal highs detected')
alertcondition(currentAlerts.equalLows,                 'Equal Lows',                   'Equal lows detected')
alertcondition(currentAlerts.bullishFairValueGap,       'Bullish FVG',                  'Bullish FVG formed')
alertcondition(currentAlerts.bearishFairValueGap,       'Bearish FVG',                  'Bearish FVG formed')

TimeFrame = input('W')
start = request.security(syminfo.tickerid, TimeFrame, time)
newSession = ta.change(start) != 0
var float vwapsum = na
var float volumesum = na
var float v2sum = na
var float prevwap = na
vwapsum := newSession ? hl2 * volume : nz(vwapsum[1]) + hl2 * volume
volumesum := newSession ? volume : nz(volumesum[1]) + volume
v2sum := newSession ? volume * hl2 * hl2 : nz(v2sum[1]) + volume * hl2 * hl2
myvwap = volumesum != 0 ? vwapsum / volumesum : na
dev = volumesum != 0 ? math.sqrt(math.max(v2sum / volumesum - nz(myvwap) * nz(myvwap), 0)) : na
vwapAboveColor = input.color(color.green, title="VWAP Above Color", inline="VWAP")
vwapBelowColor = input.color(color.red, title="VWAP Below Color", inline="VWAP")
prevVwapAboveColor = input.color(color.green, title="Prev VWAP Above Color", inline="PVWAP")
prevVwapBelowColor = input.color(color.red, title="Prev VWAP Below Color", inline="PVWAP")
showBcol = input.bool(false, title="Show barcolors")
showPrevVWAP = input.bool(false, title="Show previous VWAP close")
Coloring = close > myvwap ? vwapAboveColor : vwapBelowColor
av = myvwap
ntzDayHigh = request.security(syminfo.tickerid, 'D', high)
ntzDayLow = request.security(syminfo.tickerid, 'D', low)
ntzDayRange = ntzDayHigh - ntzDayLow
ntzFibLower = ntzDayLow + ntzDayRange * 0.45
ntzFibUpper = ntzDayLow + ntzDayRange * 0.55
ntzClose5 = request.security(syminfo.tickerid, '5', close)
ntzClose15 = request.security(syminfo.tickerid, '15', close)
ntzWithin5 = ntzDayRange > 0 ? ntzClose5 >= ntzFibLower and ntzClose5 <= ntzFibUpper : false
ntzWithin15 = ntzDayRange > 0 ? ntzClose15 >= ntzFibLower and ntzClose15 <= ntzFibUpper : false
ntzChochActive = currentAlerts.internalBullishCHoCH or currentAlerts.internalBearishCHoCH or currentAlerts.swingBullishCHoCH or currentAlerts.swingBearishCHoCH
ntzCurrentMssDir = MSS.dir
ntzMssActive = ntzCurrentMssDir != ntzPrevMssDir
ntzPrevMssDir := ntzCurrentMssDir
ntzAtr14 = ta.atr(14)
ntzNearVwap = not na(myvwap) and nz(ntzAtr14) > 0 ? math.abs(close - myvwap) <= 0.25 * ntzAtr14 : false
ntzVolumeAvg = ta.sma(volume, 50)
ntzLowVolume = not na(ntzVolumeAvg) and volume < ntzVolumeAvg
ntz = enableNtzInput and ntzWithin5 and ntzWithin15 and not ntzChochActive and not ntzMssActive and utSignalMissingOrConflict and ntzNearVwap and ntzLowVolume

alertcondition(enableNtzAlertInput and ntz, 'No Trade Zone', 'Price is in NO TRADE ZONE – skip new entries.')

if showNtzLabelInput and ntz
    ntzLabelPrice = high + nz(ntzAtr14, 0) * 0.25
    ntzLabelPrice := math.max(ntzLabelPrice, high)
    if na(ntzLabel)
        ntzLabel := label.new(bar_index, ntzLabelPrice, 'NO TRADE ZONE', xloc = xloc.bar_index, style = label.style_label_up, size = size.small, color = color.new(color.yellow, 0), textcolor = color.black)
    else
        label.set_xy(ntzLabel, bar_index, ntzLabelPrice)
        label.set_text(ntzLabel, 'NO TRADE ZONE')
        label.set_color(ntzLabel, color.new(color.yellow, 0))
        label.set_textcolor(ntzLabel, color.black)
        label.set_style(ntzLabel, label.style_label_up)
else if (not showNtzLabelInput or not ntz) and not na(ntzLabel)
    label.delete(ntzLabel)
    ntzLabel := na

bgcolor(showNtzBackgroundInput and ntz ? color.new(color.yellow, 82) : na)

utAllowEntries = utModuleActive and not ntz
utPlotBuyShape = utAllowEntries and utBuySignalVisible
utPlotSellShape = utAllowEntries and utSellSignalVisible
utTrailBuyPlotValue = utModuleActive and utShowTrailBuyInput ? utTrailBuy : na
utTrailSellPlotValue = utModuleActive and utShowTrailSellInput ? utTrailSell : na
utSignalPlotValue = utModuleActive ? utSignalLineValue : na
utBarColorConditional = utAllowEntries ? utBarColorSeries : na
vwapColorConditional = showBcol ? Coloring : na
finalBarColor = not na(utBarColorConditional) ? utBarColorConditional : vwapColorConditional
utBuyAlertCondition = utAllowEntries and utBuySignalConfirmed
utSellAlertCondition = utAllowEntries and utSellSignalConfirmed

prevwap := newSession ? myvwap[1] : prevwap[1]
plot(showPrevVWAP ? prevwap : na, style=plot.style_circles, color=close > prevwap ? prevVwapAboveColor : prevVwapBelowColor)
A = plot(av, style=plot.style_circles, color=Coloring)
barcolor(finalBarColor)

plotshape(utPlotBuyShape, title='UT Buy', style=shape.labelup, location=location.belowbar, color=color.green, textcolor=color.white, size=size.tiny, text='Buy')
plotshape(utPlotSellShape, title='UT Sell', style=shape.labeldown, location=location.abovebar, color=color.red, textcolor=color.white, size=size.tiny, text='Sell')
plot(utTrailBuyPlotValue, title='UT Bot Buy Trail', color=color.new(color.green, 0), linewidth=1)
plot(utTrailSellPlotValue, title='UT Bot Sell Trail', color=color.new(color.red, 0), linewidth=1)
plot(utSignalPlotValue, color=color.blue, linewidth=2, title='LinReg Signal')
plotcandle(open=utInLong ? utLinRegOpenSeries : na, high=utInLong ? utLinRegHighSeries : na, low=utInLong ? utLinRegLowSeries : na, close=utInLong ? utLinRegCloseSeries : na, title='LinReg Long (regime)', color=color.green, wickcolor=color.green, bordercolor=color.green)
plotcandle(open=utInShort ? utLinRegOpenSeries : na, high=utInShort ? utLinRegHighSeries : na, low=utInShort ? utLinRegLowSeries : na, close=utInShort ? utLinRegCloseSeries : na, title='LinReg Short (regime)', color=color.red, wickcolor=color.red, bordercolor=color.red)
plotcandle(open=utIsFlat and utDirUp ? utLinRegOpenSeries : na, high=utIsFlat and utDirUp ? utLinRegHighSeries : na, low=utIsFlat and utDirUp ? utLinRegLowSeries : na, close=utIsFlat and utDirUp ? utLinRegCloseSeries : na, title='LinReg Flat Green', color=color.green, wickcolor=color.green, bordercolor=color.green)
plotcandle(open=utIsFlat and not utDirUp ? utLinRegOpenSeries : na, high=utIsFlat and not utDirUp ? utLinRegHighSeries : na, low=utIsFlat and not utDirUp ? utLinRegLowSeries : na, close=utIsFlat and not utDirUp ? utLinRegCloseSeries : na, title='LinReg Flat Red', color=color.red, wickcolor=color.red, bordercolor=color.red)

alertcondition(utBuyAlertCondition, title='UT Long', message='UT Long')
alertcondition(utSellAlertCondition, title='UT Short', message='UT Short')





type Candle
	float o
	float c
	float h
	float l
    int o_time
	int o_idx
	int c_idx
	int h_idx
	int l_idx
    string dow
	box body
	line wick_up
	line wick_down
    label dow_label

type Trace
	line o
	line c
	line h
	line l
	label o_l
	label c_l
	label h_l
	label l_l

type Imbalance
	box b
	int idx

type CandleSettings
	bool show
	string htf
	int max_display

type Settings
	int max_sets
	color bull_body
	color bull_border
	color bull_wick
	color bear_body
	color bear_border
	color bear_wick
	int offset
	int buffer
	int htf_buffer
	int width
	bool use_custom_daily
    string custom_daily
    bool daily_name
	bool trace_show
	color trace_o_color
	string trace_o_style
	int trace_o_size
	color trace_c_color
	string trace_c_style
	int trace_c_size
	color trace_h_color
	string trace_h_style
	int trace_h_size
	color trace_l_color
	string trace_l_style
	int trace_l_size
	string trace_anchor
	bool label_show
	color label_color
	string label_size
    string label_position
    string label_alignment
	bool fvg_show
	color fvg_color
	bool vi_show
	color vi_color
	bool htf_label_show
	color htf_label_color
	string htf_label_size
	bool htf_timer_show
	color htf_timer_color
	string htf_timer_size
    color dow_color
    string dow_size

type CandleSet
	array<Candle> candles
	array<Imbalance> imbalances
	CandleSettings settings
	label tfNameTop
    label tfNameBottom
	label tfTimerTop
    label tfTimerBottom

type Helper
	string name = 'Helper'

Settings settings = Settings.new()

var CandleSettings SettingsHTF1 = CandleSettings.new()
var CandleSettings SettingsHTF2 = CandleSettings.new()
var CandleSettings SettingsHTF3 = CandleSettings.new()
var CandleSettings SettingsHTF4 = CandleSettings.new()
var CandleSettings SettingsHTF5 = CandleSettings.new()
var CandleSettings SettingsHTF6 = CandleSettings.new()

var array<Candle> candles_1 = array.new<Candle>(0)
var array<Candle> candles_2 = array.new<Candle>(0)
var array<Candle> candles_3 = array.new<Candle>(0)
var array<Candle> candles_4 = array.new<Candle>(0)
var array<Candle> candles_5 = array.new<Candle>(0)
var array<Candle> candles_6 = array.new<Candle>(0)

var array<Imbalance> imbalances_1 = array.new<Imbalance>()
var array<Imbalance> imbalances_2 = array.new<Imbalance>()
var array<Imbalance> imbalances_3 = array.new<Imbalance>()
var array<Imbalance> imbalances_4 = array.new<Imbalance>()
var array<Imbalance> imbalances_5 = array.new<Imbalance>()
var array<Imbalance> imbalances_6 = array.new<Imbalance>()

var CandleSet htf1 = CandleSet.new()
htf1.settings := SettingsHTF1
htf1.candles := candles_1
htf1.imbalances := imbalances_1

var CandleSet htf2 = CandleSet.new()
htf2.settings := SettingsHTF2
htf2.candles := candles_2
htf2.imbalances := imbalances_2

var CandleSet htf3 = CandleSet.new()
htf3.settings := SettingsHTF3
htf3.candles := candles_3
htf3.imbalances := imbalances_3

var CandleSet htf4 = CandleSet.new()
htf4.settings := SettingsHTF4
htf4.candles := candles_4
htf4.imbalances := imbalances_4

var CandleSet htf5 = CandleSet.new()
htf5.settings := SettingsHTF5
htf5.candles := candles_5
htf5.imbalances := imbalances_5

var CandleSet htf6 = CandleSet.new()
htf6.settings := SettingsHTF6
htf6.candles := candles_6
htf6.imbalances := imbalances_6


string group_style              = "Styling "
string group_label              = "Label Settings "
string group_imbalance          = "Imbalance "
string group_trace              = "Trace "

htf1.settings.show              := input.bool(true, 'HTF 1      ', inline = 'htf1')
htf_1                           = input.timeframe('5', '', inline = 'htf1')
htf1.settings.htf := htf_1
htf1.settings.max_display       := input.int(10, '', inline = 'htf1')

htf2.settings.show              := input.bool(true, 'HTF 2      ', inline = 'htf2')
htf_2                           = input.timeframe('15', '', inline = 'htf2')
htf2.settings.htf := htf_2
htf2.settings.max_display       := input.int(10, '', inline = 'htf2')

htf3.settings.show              := input.bool(true, 'HTF 3      ', inline = 'htf3')
htf_3                           = input.timeframe('60', '', inline = 'htf3')
htf3.settings.htf := htf_3
htf3.settings.max_display       := input.int(10, '', inline = 'htf3')

htf4.settings.show              := input.bool(true, 'HTF 4      ', inline = 'htf4')
htf_4                           = input.timeframe('240', '', inline = 'htf4')
htf4.settings.htf               := htf_4
htf4.settings.max_display       := input.int(10, '', inline = 'htf4')

htf5.settings.show              := input.bool(true, 'HTF 5      ', inline = 'htf5')
htf_5                           = input.timeframe('1D', '', inline = 'htf5')
htf5.settings.htf := htf_5
htf5.settings.max_display       := input.int(10, '', inline = 'htf5')

htf6.settings.show              := input.bool(true, 'HTF 6      ', inline = 'htf6')
htf_6                           = input.timeframe('1W', '', inline = 'htf6')
htf6.settings.htf               := htf_6
htf6.settings.max_display       := input.int(10, '', inline = 'htf6')

settings.max_sets               := input.int(6, 'Limit to next HTFs only', minval = 1, maxval = 6)
settings.use_custom_daily       := input.bool(false, 'Custom daily candle open     ', inline='customdaily')
settings.custom_daily           := input.string('Midnight', '', options=['Midnight', '8:30', '9:30'], inline='customdaily')
settings.bull_body              := input.color(color.new(color.green, 10), 'Body  ', inline = 'body', group=group_style)
settings.bear_body              := input.color(color.new(color.red, 10), '', inline = 'body', group=group_style)
settings.bull_border            := input.color(color.new(color.black, 10), 'Borders', inline = 'borders', group=group_style)
settings.bear_border            := input.color(color.new(color.black, 10), '', inline = 'borders', group=group_style)
settings.bull_wick              := input.color(color.new(color.black, 10), 'Wick  ', inline = 'wick', group=group_style)
settings.bear_wick              := input.color(color.new(color.black, 10), '', inline = 'wick', group=group_style)

settings.offset                 := input.int(10, 'padding from current candles', minval = 1, group=group_style)
settings.buffer                 := input.int(1, 'space between candles', minval = 1, maxval = 4, group=group_style)
settings.htf_buffer             := input.int(10, 'space between Higher Timeframes', minval = 1, maxval = 10, group=group_style)
settings.width                  := input.int(1, 'Candle Width', minval = 1, maxval = 4, group=group_style) * 2

settings.htf_label_show         := input.bool(true, 'HTF Label           ', group=group_label, inline = 'HTFlabel')
settings.htf_label_color        := input.color(color.new(color.black, 10), '', group=group_label, inline = 'HTFlabel')
settings.htf_label_size         := input.string(size.large, '', [size.tiny, size.small, size.normal, size.large, size.huge], group=group_label, inline = 'HTFlabel')

settings.label_position         := input.string("Both", 'Label Positions', options=['Both', 'Top', 'Bottom'], group=group_label)
settings.label_alignment        := input.string("Align", "Label Alignment", options=['Align', 'Follow Candles'], group=group_label)

settings.htf_timer_show         := input.bool(true, 'Remaining time      ', inline = 'timer', group=group_label)
settings.htf_timer_color        := input.color(color.new(color.black, 10), '', inline = 'timer', group=group_label)
settings.htf_timer_size         := input.string(size.normal, '', [size.tiny, size.small, size.normal, size.large, size.huge], group=group_label, inline = 'timer')

settings.daily_name             := input.bool(false, 'Interval Value        ', group=group_label, inline = 'dow')
settings.dow_color              := input.color(color.black , '', group=group_label, inline = 'dow')
settings.dow_size               := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], group=group_label, inline = 'dow')

settings.fvg_show               := input.bool(true, 'Fair Value Gap   ', group = group_imbalance, inline = 'fvg')
settings.fvg_color              := input.color(color.new(color.gray, 80), '', inline = 'fvg', group = group_imbalance)

settings.vi_show                := input.bool(true, 'Volume Imbalance', group = group_imbalance, inline = 'vi')
settings.vi_color               := input.color(color.new(color.red, 50), '', inline = 'vi', group = group_imbalance)

settings.trace_show             := input.bool(false, 'Trace lines', group = group_trace)
settings.trace_o_color          := input.color(color.new(color.gray, 50), 'Open    ', inline = '1', group = group_trace)
settings.trace_o_style          := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '1', group = group_trace)
settings.trace_o_size           := input.int(1, '', options = [1, 2, 3, 4], inline = '1', group = group_trace)
settings.trace_c_color          := input.color(color.new(color.gray, 50), 'Close    ', inline = '2', group = group_trace)
settings.trace_c_style          := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '2', group = group_trace)
settings.trace_c_size           := input.int(1, '', options = [1, 2, 3, 4], inline = '2', group = group_trace)
settings.trace_h_color          := input.color(color.new(color.gray, 50), 'High     ', inline = '3', group = group_trace)
settings.trace_h_style          := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '3', group = group_trace)
settings.trace_h_size           := input.int(1, '', options = [1, 2, 3, 4], inline = '3', group = group_trace)
settings.trace_l_color          := input.color(color.new(color.gray, 50), 'Low     ', inline = '4', group = group_trace)
settings.trace_l_style          := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '4', group = group_trace)
settings.trace_l_size           := input.int(1, '', options = [1, 2, 3, 4], inline = '4', group = group_trace)
settings.trace_anchor           := input.string('First Timeframe', 'Anchor to', options = ['First Timeframe', 'Last Timeframe'], group = group_trace)

settings.label_show             := input.bool(false, 'Price Label           ', inline = 'label')
settings.label_color            := input.color(color.new(color.black, 10), '', inline = 'label')
settings.label_size             := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline = 'label')


Helper helper = Helper.new()
var Trace trace = Trace.new()
color color_transparent = #ffffff00


lineStyleFromSetting(string styleName) =>
    switch styleName
        '----' => line.style_dashed
        '····' => line.style_dotted
        => line.style_solid


ensureTraceLine(line current, int x1, float y1, int x2, float y2, color lineColor, string styleSetting, int widthSetting) =>
    line result = current
    lineStyleValue = lineStyleFromSetting(styleSetting)
    if na(result)
        result := line.new(x1, y1, x2, y2, xloc = xloc.bar_index, color = lineColor, style = lineStyleValue, width = widthSetting)
    else
        line.set_xy1(result, x1, y1)
        line.set_xy2(result, x2, y2)
        line.set_color(result, lineColor)
        line.set_style(result, lineStyleValue)
        line.set_width(result, widthSetting)
    result


refreshTraceLabel(label target, int x, float y, string textValue) =>
    if not na(target)
        label.set_xy(target, x, y)
        label.set_text(target, textValue)
        label.set_textcolor(target, settings.label_color)
        label.set_size(target, settings.label_size)
        label.set_style(target, label.style_label_left)
        label.set_textalign(target, text.align_center)
    target


ensureTraceLabel(label current, int x, float y, string textValue) =>
    label result = current
    if na(result)
        result := label.new(x, y, textValue, textalign = text.align_center, style = label.style_label_left, size = settings.label_size, color = color_transparent, textcolor = settings.label_color)
    result := refreshTraceLabel(result, x, y, textValue)

updateLabelRef(label current, float x, float y, string textValue, color textColor, string sizeValue, styleValue) =>
    int xInt = int(math.round(x))
    label result = current
    if na(result)
        result := label.new(xInt, y, textValue, color = color_transparent, textcolor = textColor, style = styleValue, size = sizeValue)
    else
        label.set_xy(result, xInt, y)
        label.set_text(result, textValue)
        label.set_textcolor(result, textColor)
        label.set_size(result, sizeValue)
        label.set_style(result, styleValue)
    result

updateTimerText(label current, string textValue) =>
    if not na(current)
        label.set_text(current, textValue)
    current

shouldShowTrace(int processedCount, int lastEnabled) =>
    (settings.trace_anchor == 'First Timeframe' and processedCount == 0) or (settings.trace_anchor == 'Last Timeframe' and (settings.max_sets == 1 or processedCount == lastEnabled - 1))


method DayofWeek(Helper helper, int index) =>
    helper.name := 'DOW'
    switch
        index == 1 => 'M'
        index == 2 => 'T'
        index == 3 => 'W'
        index == 4 => 'T'
        index == 5 => 'F'
        index == 6 => 'S'
        index == 7 => 'S'
        na(index) => ''

method ValidTimeframe(Helper helper, string HTF) =>
    helper.name := HTF
    if timeframe.in_seconds(HTF) >= timeframe.in_seconds('D') and timeframe.in_seconds(HTF) > timeframe.in_seconds()
        true
    else
        n1 = timeframe.in_seconds()
        n2 = timeframe.in_seconds(HTF)
        n3 = n1 % n2
        n1 < n2 and math.round(n2 / n1) == n2 / n1


method RemainingTime(Helper helper, string HTF) =>
    helper.name := HTF
    if barstate.isrealtime
        timeRemaining = (time_close(HTF) - timenow) / 1000
        days = math.floor(timeRemaining / 86400)
        hours = math.floor((timeRemaining - days * 86400) / 3600)
        minutes = math.floor((timeRemaining - days * 86400 - hours * 3600) / 60)
        seconds = math.floor(timeRemaining - days * 86400 - hours * 3600 - minutes * 60)

        string remainingText = str.tostring(seconds, '00')
        if minutes > 0 or hours > 0 or days > 0
            remainingText := str.tostring(minutes, '00') + ':' + remainingText
            remainingText
        if hours > 0 or days > 0
            remainingText := str.tostring(hours, '00') + ':' + remainingText
            remainingText
        if days > 0
            remainingText := str.tostring(days) + 'D ' + remainingText
            remainingText
        remainingText
    else
        'n/a'

method HTFName(Helper helper, string HTF) =>
    helper.name := 'HTFName'
    formatted = HTF

    seconds = timeframe.in_seconds(HTF)
    if seconds < 60
        formatted := str.tostring(seconds) + 's'
        formatted
    else if seconds / 60 < 60
        formatted := str.tostring(seconds / 60) + 'm'
        formatted
    else if seconds / 60 / 60 < 24
        formatted := str.tostring(seconds / 60 / 60) + 'H'
        formatted
    formatted

method HTFEnabled(Helper helper) =>
    helper.name := 'HTFEnabled'
    int enabled = 0
    enabled := enabled + (htf1.settings.show ? 1 : 0)
    enabled := enabled + (htf2.settings.show ? 1 : 0)
    enabled := enabled + (htf3.settings.show ? 1 : 0)
    enabled := enabled + (htf4.settings.show ? 1 : 0)
    enabled := enabled + (htf5.settings.show ? 1 : 0)
    enabled := enabled + (htf6.settings.show ? 1 : 0)
    int last = math.min(enabled, settings.max_sets)

    last

method CandleSetHigh(Helper helper, array<Candle> candles, float h) =>
    helper.name := 'CandlesSetHigh'
    float _h = h
    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.h > _h
                _h := c.h
                _h
    _h

method CandleSetLow(Helper helper, array<Candle> candles, float l) =>
    helper.name := 'CandlesSetLow'
    float _l = l
    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.l < _l
                _l := c.l
                _l
    _l

method CandlesHigh(Helper helper, array<Candle> candles) =>
    helper.name := 'CandlesHigh'
    h = 0.0
    int cnt = 0
    int last = helper.HTFEnabled()

    if htf1.settings.show and helper.ValidTimeframe(htf1.settings.htf)
        h := helper.CandleSetHigh(htf1.candles, h)
        cnt := cnt + 1
    if htf2.settings.show and helper.ValidTimeframe(htf2.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf2.candles, h)
        cnt := cnt + 1
    if htf3.settings.show and helper.ValidTimeframe(htf3.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf3.candles, h)
        cnt := cnt + 1
    if htf4.settings.show and helper.ValidTimeframe(htf4.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf4.candles, h)
        cnt := cnt + 1
    if htf5.settings.show and helper.ValidTimeframe(htf5.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf5.candles, h)
        cnt := cnt + 1
    if htf6.settings.show and helper.ValidTimeframe(htf6.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf6.candles, h)

    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.h > h
                h := c.h
    h

method CandlesLow(Helper helper, array<Candle> candles, float h) =>
    helper.name := 'CandlesLow'
    l = h
    int cnt = 0
    int last = helper.HTFEnabled()

    if htf1.settings.show and helper.ValidTimeframe(htf1.settings.htf)
        l := helper.CandleSetLow(htf1.candles, l)
        cnt := cnt + 1
    if htf2.settings.show and helper.ValidTimeframe(htf2.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf2.candles, l)
        cnt := cnt + 1
    if htf3.settings.show and helper.ValidTimeframe(htf3.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf3.candles, l)
        cnt := cnt + 1
    if htf4.settings.show and helper.ValidTimeframe(htf4.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf4.candles, l)
        cnt := cnt + 1
    if htf5.settings.show and helper.ValidTimeframe(htf5.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf5.candles, l)
        cnt := cnt + 1
    if htf6.settings.show and helper.ValidTimeframe(htf6.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf6.candles, l)

    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.l < l
                l := c.l
    l

method UpdateTime(CandleSet candleSet, int offset) =>
    if settings.htf_timer_show and (barstate.isrealtime or barstate.islast)
        string tmr = '(' + helper.RemainingTime(candleSet.settings.htf) + ')'

        candleSet.tfTimerTop := updateTimerText(candleSet.tfTimerTop, tmr)
        candleSet.tfTimerBottom := updateTimerText(candleSet.tfTimerBottom, tmr)
    candleSet

method Reorder(CandleSet candleSet, int offset) =>
    size = candleSet.candles.size()

    if size > 0
        for i = size - 1 to 0 by 1
            Candle candle = candleSet.candles.get(i)
            t_buffer = offset + (settings.width + settings.buffer) * (size - i - 1)
            box.set_left(candle.body, bar_index + t_buffer)
            box.set_right(candle.body, bar_index + settings.width + t_buffer)
            line.set_x1(candle.wick_up, bar_index + settings.width / 2 + t_buffer)
            line.set_x2(candle.wick_up, bar_index + settings.width / 2 + t_buffer)
            line.set_x1(candle.wick_down, bar_index + settings.width / 2 + t_buffer)
            line.set_x2(candle.wick_down, bar_index + settings.width / 2 + t_buffer)

            if settings.daily_name
                if not na(candle.dow_label)
                    candle.dow_label.set_y(candle.h)
                    candle.dow_label.set_x(bar_index + settings.width / 2 + t_buffer)
                    candle.dow_label.set_text(candle.dow)
                else
                    candle.dow_label := label.new(bar_index + settings.width / 2 + t_buffer, candle.h, candle.dow, color = color_transparent, textcolor = settings.dow_color, style = label.style_label_down, size = settings.dow_size)

    float labelTop = 0.0
    float labelBottom = 0.0

    if settings.label_alignment == 'Align'
        labelTop := helper.CandlesHigh(candleSet.candles)
        labelBottom := helper.CandlesLow(candleSet.candles, labelTop)
    if settings.label_alignment == 'Follow Candles'
        labelTop := helper.CandleSetHigh(candleSet.candles, 0)
        labelBottom := helper.CandleSetLow(candleSet.candles, labelTop)

    left = bar_index + offset + (settings.width + settings.buffer) * (size - 1) / 2

    if settings.htf_label_show
        string lblt = helper.HTFName(candleSet.settings.htf)
        string lbll = lblt
        if settings.htf_timer_show
            lblt := lblt + '\n'
            lbll := '\n' + lbll
        if settings.daily_name
            lblt := lblt + '\n'

        bool showTop = settings.label_position == 'Both' or settings.label_position == 'Top'
        bool showBottom = settings.label_position == 'Both' or settings.label_position == 'Bottom'

        if showTop
            candleSet.tfNameTop := updateLabelRef(candleSet.tfNameTop, left, labelTop, lblt, settings.htf_label_color, settings.htf_label_size, label.style_label_down)
        if showBottom
            candleSet.tfNameBottom := updateLabelRef(candleSet.tfNameBottom, left, labelBottom, lbll, settings.htf_label_color, settings.htf_label_size, label.style_label_up)

        if settings.htf_timer_show
            string tmr = '(' + helper.RemainingTime(candleSet.settings.htf) + ')' + (settings.daily_name ? '\n' : '')
            if showTop
                candleSet.tfTimerTop := updateLabelRef(candleSet.tfTimerTop, left, labelTop, tmr, settings.htf_timer_color, settings.htf_timer_size, label.style_label_down)
            if showBottom
                candleSet.tfTimerBottom := updateLabelRef(candleSet.tfTimerBottom, left, labelBottom, tmr, settings.htf_timer_color, settings.htf_timer_size, label.style_label_up)

    candleSet

method FindImbalance(CandleSet candleSet) =>
    if barstate.isrealtime or barstate.islast
        if candleSet.imbalances.size() > 0
            for i = candleSet.imbalances.size() - 1 to 0 by 1
                Imbalance del = candleSet.imbalances.get(i)
                box.delete(del.b)
                candleSet.imbalances.pop()

        if candleSet.candles.size() > 3 and settings.fvg_show
            for i = 0 to candleSet.candles.size() - 3 by 1
                candle1 = candleSet.candles.get(i)
                candle2 = candleSet.candles.get(i + 2)
                candle3 = candleSet.candles.get(i + 1)

                if candle1.l > candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
                    Imbalance imb = Imbalance.new()
                    imb.b := box.new(box.get_left(candle2.body), candle2.h, box.get_right(candle1.body), candle1.l, bgcolor = settings.fvg_color, border_color = color_transparent, xloc = xloc.bar_index)
                    candleSet.imbalances.push(imb)
                if candle1.h < candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
                    Imbalance imb = Imbalance.new()
                    imb.b := box.new(box.get_right(candle1.body), candle1.h, box.get_left(candle2.body), candle2.l, bgcolor = settings.fvg_color, border_color = color_transparent)
                    candleSet.imbalances.push(imb)
                box temp = box.copy(candle3.body)
                box.delete(candle3.body)
                candle3.body := temp
                candle3.body

        if candleSet.candles.size() > 2 and settings.vi_show
            for i = 0 to candleSet.candles.size() - 2 by 1
                candle1 = candleSet.candles.get(i)
                candle2 = candleSet.candles.get(i + 1)
                if candle1.l < candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
                    Imbalance imb = Imbalance.new()
                    imb.b := box.new(box.get_left(candle2.body), math.min(candle1.o, candle1.c), box.get_right(candle1.body), math.max(candle2.o, candle2.c), bgcolor = settings.vi_color, border_color = color_transparent)
                    candleSet.imbalances.push(imb)
                if candle1.h > candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
                    Imbalance imb = Imbalance.new()
                    imb.b := box.new(box.get_right(candle1.body), math.min(candle2.o, candle2.c), box.get_left(candle2.body), math.max(candle1.o, candle1.c), bgcolor = settings.vi_color, border_color = color_transparent)
                    candleSet.imbalances.push(imb)
    candleSet

method Monitor(CandleSet candleSet) =>
    HTFBarTime = time(candleSet.settings.htf, 'america/New_York')
    isNewHTFCandle = ta.change(HTFBarTime) > 0

    if settings.use_custom_daily
        if candleSet.settings.htf == '1D'
            if settings.custom_daily == 'Midnight'
                isNewHTFCandle := dayofweek(time, 'America/New_York') != dayofweek(time - (time - time[1]), 'America/New_York')
            if settings.custom_daily == '8:30'
                isNewHTFCandle := not na(time(timeframe.period, "0830-0831:123456", 'America/New_York')) and na(time(timeframe.period, "0830-0831:123456", 'America/New_York')[1])
            if settings.custom_daily == '9:30'
                isNewHTFCandle := not na(time(timeframe.period, "0930-0931:123456", 'America/New_York')) and na(time(timeframe.period, "0930-0931:123456", 'America/New_York')[1])
    if isNewHTFCandle
        Candle candle = Candle.new()
        candle.o := open
        candle.c := close
        candle.h := high
        candle.l := low
        candle.o_time := time
        candle.o_idx := bar_index
        candle.c_idx := bar_index
        candle.h_idx := bar_index
        candle.l_idx := bar_index
        candle.dow := switch
            candleSet.settings.htf == '1D' =>
                helper.DayofWeek(dayofweek(time_tradingday, "America/New_York"))
            str.tonumber(candleSet.settings.htf) < 60 =>
                str.format_time(candle.o_time, 'm', 'America/New_York')
            str.tonumber(candleSet.settings.htf) >= 60 =>
                str.format_time(candle.o_time, 'H', 'America/New_York')
            candleSet.settings.htf == '1M' =>
                str.format_time(candle.o_time, 'M', 'America/New_York')
            =>
                ''
        bull = candle.c > candle.o

        candle.body := box.new(bar_index, math.max(candle.o, candle.c), bar_index + 2, math.min(candle.o, candle.c), bull ? settings.bull_border : settings.bear_border, 1, bgcolor = bull ? settings.bull_body : settings.bear_body)
        candle.wick_up := line.new(bar_index + 1, candle.h, bar_index, math.max(candle.o, candle.c), color = bull ? settings.bull_wick : settings.bear_wick)
        candle.wick_down := line.new(bar_index + 1, math.min(candle.o, candle.c), bar_index, candle.l, color = bull ? settings.bull_wick : settings.bear_wick)

        candleSet.candles.unshift(candle)

        if candleSet.candles.size() > candleSet.settings.max_display
            Candle delCandle = array.pop(candleSet.candles)
            box.delete(delCandle.body)
            line.delete(delCandle.wick_up)
            line.delete(delCandle.wick_down)
            delCandle.dow_label.delete()

    candleSet

method Update(CandleSet candleSet, int offset, bool showTrace) =>
    if candleSet.candles.size() > 0
        Candle candle = candleSet.candles.first()
        candle.h_idx := high > candle.h ? bar_index : candle.h_idx
        candle.h := high > candle.h ? high : candle.h
        candle.l_idx := low < candle.l ? bar_index : candle.l_idx
        candle.l := low < candle.l ? low : candle.l
        candle.c := close
        candle.c_idx := bar_index

        bull = candle.c > candle.o

        box.set_top(candle.body, candle.o)
        box.set_bottom(candle.body, candle.c)
        box.set_bgcolor(candle.body, bull ? settings.bull_body : settings.bear_body)
        box.set_border_color(candle.body, bull ? settings.bull_border : settings.bear_border)
        line.set_color(candle.wick_up, bull ? settings.bull_wick : settings.bear_wick)
        line.set_color(candle.wick_down, bull ? settings.bull_wick : settings.bear_wick)
        line.set_y1(candle.wick_up, candle.h)
        line.set_y2(candle.wick_up, math.max(candle.o, candle.c))
        line.set_y1(candle.wick_down, candle.l)
        line.set_y2(candle.wick_down, math.min(candle.o, candle.c))

        if barstate.isrealtime or barstate.islast
            candleSet.Reorder(offset)
            if settings.trace_show and showTrace
                if bar_index - candle.o_idx < 5000
                    trace.o := ensureTraceLine(trace.o, candle.o_idx, candle.o, box.get_left(candle.body), candle.o, settings.trace_o_color, settings.trace_o_style, settings.trace_o_size)
                    if settings.label_show
                        trace.o_l := ensureTraceLabel(trace.o_l, int(math.round(box.get_right(candle.body))), candle.o, str.tostring(candle.o))

                if bar_index - candle.c_idx < 5000
                    trace.c := ensureTraceLine(trace.c, candle.c_idx, candle.c, box.get_left(candle.body), candle.c, settings.trace_c_color, settings.trace_c_style, settings.trace_c_size)
                    if settings.label_show
                        trace.c_l := ensureTraceLabel(trace.c_l, int(math.round(box.get_right(candle.body))), candle.c, str.tostring(candle.c))

                if bar_index - candle.h_idx < 5000
                    trace.h := ensureTraceLine(trace.h, candle.h_idx, candle.h, line.get_x1(candle.wick_up), candle.h, settings.trace_h_color, settings.trace_h_style, settings.trace_h_size)
                    if settings.label_show
                        trace.h_l := ensureTraceLabel(trace.h_l, int(math.round(box.get_right(candle.body))), candle.h, str.tostring(candle.h))

                if bar_index - candle.l_idx < 5000
                    trace.l := ensureTraceLine(trace.l, candle.l_idx, candle.l, line.get_x1(candle.wick_down), candle.l, settings.trace_l_color, settings.trace_l_style, settings.trace_l_size)
                    if settings.label_show
                        trace.l_l := ensureTraceLabel(trace.l_l, int(math.round(box.get_right(candle.body))), candle.l, str.tostring(candle.l))
    candleSet

int cnt = 0
int last = helper.HTFEnabled()

int offset = settings.offset
var CandleSet[] htfSets = array.from(htf1, htf2, htf3, htf4, htf5, htf6)

for i = 0 to array.size(htfSets) - 1 by 1
    array.get(htfSets, i).Monitor()

for i = 0 to array.size(htfSets) - 1 by 1
    CandleSet htf = array.get(htfSets, i)
    bool canProcess = htf.settings.show and helper.ValidTimeframe(htf.settings.htf) and cnt < last
    if canProcess
        bool showTrace = shouldShowTrace(cnt, last)
        htf.UpdateTime(offset)
        htf.Update(offset, showTrace).FindImbalance()
        cnt := cnt + 1
        int candleCount = htf.candles.size()
        offset := offset + (candleCount > 0 ? candleCount * settings.width + (candleCount - 1) * settings.buffer + settings.htf_buffer : settings.htf_buffer)
